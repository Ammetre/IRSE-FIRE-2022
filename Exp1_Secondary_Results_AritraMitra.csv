Comments,Surrounding Code Context,Class,Predicted Class
/*test 529*/,"-10.   int res = 0;
-9.   CURL *curl = NULL;
-8.   FILE *hd_src = NULL;
-7.   int hd;
-6.   struct_stat file_info;
-5.   CURLM *m = NULL;
-4.   int running;
-3.   start_test_timing();
-2.   if(!libtest_arg2) {
-1. #ifdef LIB529

/*test 529*/

1.     fprintf(stderr, ""Usage: lib529 [url] [uploadfile]\n"");
2. #else",Not Useful,1
/*test 525*/,"-2.     fprintf(stderr, ""Usage: lib529 [url] [uploadfile]\n"");
-1. #else

/*test 525*/

1.     fprintf(stderr, ""Usage: lib525 [url] [uploadfile]\n"");
2. #endif
3.     return TEST_ERR_USAGE;
4.   }
5.   hd_src = fopen(libtest_arg2, ""rb"");
6.   if(!hd_src) {
7.     fprintf(stderr, ""fopen failed with error: %d (%s)\n"",
8.             errno, strerror(errno));
9.     fprintf(stderr, ""Error opening file: (%s)\n"", libtest_arg2);
10.     return TEST_ERR_FOPEN;",Not Useful,1
/*done*/,"-10.   multi_add_handle(m, curl);
-9.   for(;;) {
-8.     struct timeval interval;
-7.     fd_set rd, wr, exc;
-6.     int maxfd = -99;
-5.     interval.tv_sec = 1;
-4.     interval.tv_usec = 0;
-3.     multi_perform(m, &running);
-2.     abort_on_test_timeout();
-1.     if(!running)

/*done*/

1.     FD_ZERO(&rd);
2.     FD_ZERO(&wr);
3.     FD_ZERO(&exc);
4.     multi_fdset(m, &rd, &wr, &exc, &maxfd);",Not Useful,0
/*test 529*/,"-10.   int res = 0;
-9.   CURL *curl = NULL;
-8.   FILE *hd_src = NULL;
-7.   int hd;
-6.   struct_stat file_info;
-5.   CURLM *m = NULL;
-4.   int running;
-3.   start_test_timing();
-2.   if(!libtest_arg2) {
-1. #ifdef LIB529

/*test 529*/

1.     fprintf(stderr, ""Usage: lib529 [url] [uploadfile]\n"");
2. #else",Not Useful,0
/*test 525*/,"-2.     fprintf(stderr, ""Usage: lib529 [url] [uploadfile]\n"");
-1. #else

/*test 525*/

1.     fprintf(stderr, ""Usage: lib525 [url] [uploadfile]\n"");
2. #endif
3.     return TEST_ERR_USAGE;
4.   }
5.   hd_src = fopen(libtest_arg2, ""rb"");
6.   if(!hd_src) {
7.     fprintf(stderr, ""fopen failed with error: %d (%s)\n"",
8.             errno, strerror(errno));
9.     fprintf(stderr, ""Error opening file: (%s)\n"", libtest_arg2);
10.     return TEST_ERR_FOPEN;",Not Useful,1
"/*argv1 = URL
 * argv2 = proxy
 * argv3 = non-zero means ASCII transfer*/","-9.  *
-8.  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
-7.  * copies of the Software, and permit persons to whom the Software is
-6.  * furnished to do so, under the terms of the COPYING file.
-5.  *
-4.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-3.  * KIND, either express or implied.
-2.  *
-1.  ***************************************************************************/
/* argv1 = URL
 * argv2 = proxy
 * argv3 = non-zero means ASCII transfer

/*argv1 = URL
 * argv2 = proxy
 * argv3 = non-zero means ASCII transfer*/

1.  */
2. #include ""test.h""
3. #include ""memdebug.h""
4. int test(char *URL)
5. {
6.   CURLcode res;
7.   CURL *curl;
8.   if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
9.     fprintf(stderr, ""curl_global_init() failed\n"");
10.     return TEST_ERR_MAJOR_BAD;",Not Useful,0
/*enable ascii/text mode*/,"-10.   if(!curl) {
-9.     fprintf(stderr, ""curl_easy_init() failed\n"");
-8.     curl_global_cleanup();
-7.     return TEST_ERR_MAJOR_BAD;
-6.   }
-5.   test_setopt(curl, CURLOPT_PROXY, libtest_arg2);
-4.   test_setopt(curl, CURLOPT_URL, URL);
-3.   test_setopt(curl, CURLOPT_PROXY_TRANSFER_MODE, 1L);
-2.   test_setopt(curl, CURLOPT_VERBOSE, 1L);
-1.   if(libtest_arg3) {

/*enable ascii/text mode*/

1.     test_setopt(curl, CURLOPT_TRANSFERTEXT, 1L);
2.   }
3.   res = curl_easy_perform(curl);
4. test_cleanup:
5.   curl_easy_cleanup(curl);
6.   curl_global_cleanup();
7.   return (int)res;
8. }",Not Useful,1
/*100 ms*/,"-10.   multi_add_handle(mhandle, handle);
-9.   multi_perform(mhandle, &still_running);
-8.   abort_on_test_timeout();
-7.   while(still_running) {
-6.     struct timeval timeout;
-5.     fd_set fdread;
-4.     fd_set fdwrite;
-3.     fd_set fdexcep;
-2.     int maxfd = -99;
-1.     timeout.tv_sec = 0;

/*100 ms*/

1.     FD_ZERO(&fdread);
2.     FD_ZERO(&fdwrite);
3.     FD_ZERO(&fdexcep);
4.     multi_fdset(mhandle, &fdread, &fdwrite, &fdexcep, &maxfd);",Not Useful,1
/*on failure don't abort just issue a warning*/,"-10.    * point the resulting soft limit is our limit. Trying to
-9.    * open more than soft limit file descriptors will fail.
-8.    */
-7.   if(rl.rlim_cur != rl.rlim_max) {
-6. #ifdef OPEN_MAX
-5.     if((rl.rlim_cur > 0) &&
-4.         (rl.rlim_cur < OPEN_MAX)) {
-3.       fprintf(stderr, ""raising soft limit up to OPEN_MAX\n"");
-2.       rl.rlim_cur = OPEN_MAX;
-1.       if(setrlimit(RLIMIT_NOFILE, &rl) != 0) {

/*on failure don't abort just issue a warning*/

1.         store_errmsg(""setrlimit() failed"", errno);
2.         fprintf(stderr, ""%s\n"", msgbuff);
3.         msgbuff[0] = '\0';
4.       }
5.     }
6. #endif
7.     fprintf(stderr, ""raising soft limit up to hard limit\n"");
8.     rl.rlim_cur = rl.rlim_max;
9.     if(setrlimit(RLIMIT_NOFILE, &rl) != 0) {",Not Useful,1
/*on failure don't abort just issue a warning*/,"-10.    * point the resulting soft limit is our limit. Trying to
-9.    * open more than soft limit file descriptors will fail.
-8.    */
-7.   if(rl.rlim_cur != rl.rlim_max) {
-6. #ifdef OPEN_MAX
-5.     if((rl.rlim_cur > 0) &&
-4.         (rl.rlim_cur < OPEN_MAX)) {
-3.       fprintf(stderr, ""raising soft limit up to OPEN_MAX\n"");
-2.       rl.rlim_cur = OPEN_MAX;
-1.       if(setrlimit(RLIMIT_NOFILE, &rl) != 0) {

/*on failure don't abort just issue a warning*/

1.         store_errmsg(""setrlimit() failed"", errno);
2.         fprintf(stderr, ""%s\n"", msgbuff);
3.         msgbuff[0] = '\0';
4.       }
5.     }
6. #endif
7.     fprintf(stderr, ""raising soft limit up to hard limit\n"");
8.     rl.rlim_cur = rl.rlim_max;
9.     if(setrlimit(RLIMIT_NOFILE, &rl) != 0) {",Not Useful,0
/*(rl.rlim_cur != rl.rlim_max)*/,"
  if(rl.rlim_cur != rl.rlim_max) {



/*(rl.rlim_cur != rl.rlim_max)*/

1. #ifdef OPEN_MAX
2.     if((rl.rlim_cur > 0) &&
3.         (rl.rlim_cur < OPEN_MAX)) {
4.       fprintf(stderr, ""raising soft limit up to OPEN_MAX\n"");
5.       rl.rlim_cur = OPEN_MAX;
6.       if(setrlimit(RLIMIT_NOFILE, &rl) != 0) {",Not Useful,0
/*soft limit minus SAFETY_MARGIN*/,"-5. #ifdef RLIM_INFINITY
-4.   if((rl.rlim_cur > 0) && (rl.rlim_cur != RLIM_INFINITY)) {
-3. #else
-2.   if(rl.rlim_cur > 0) {
-1. #endif

/*soft limit minus SAFETY_MARGIN*/

1.     num_open.rlim_max = rl.rlim_cur - SAFETY_MARGIN;
2.   }
3.   else {",Not Useful,1
"/*free the chunk of memory we were reserving so that it
     becomes becomes available to the test*/","-10.     msnprintf(strbuff1, sizeof(strbuff1), fmt, num_open.rlim_max);
-9.     msnprintf(strbuff, sizeof(strbuff), ""fopen fails with %s fds open"",
-8.               strbuff1);
-7.     fprintf(stderr, ""%s\n"", msgbuff);
-6.     msnprintf(strbuff, sizeof(strbuff), ""fopen fails with lots of fds open"");
-5.     store_errmsg(strbuff, 0);
-4.     close_file_descriptors();
-3.     free(memchunk);
-2.     return -10;
-1.   }

/*free the chunk of memory we were reserving so that it
     becomes becomes available to the test*/

1.   free(memchunk);",Not Useful,0
/*close file descriptors unless instructed to keep them*/,"-1.   free(memchunk);

/*close file descriptors unless instructed to keep them*/

1.   if(!keep_open) {
2.     close_file_descriptors();
3.   }
4.   return 0;
5. }
6. int test(char *URL)
7. {
8.   CURLcode res;
9.   CURL *curl;
10.   if(!strcmp(URL, ""check"")) {",Not Useful,1
/*failure*/,"-10.    * point the resulting soft limit is our limit. Trying to
-9.    * open more than soft limit file descriptors will fail.
-8.    */
-7.   if(rl.rlim_cur != rl.rlim_max) {
-6. #ifdef OPEN_MAX
-5.     if((rl.rlim_cur > 0) &&
-4.         (rl.rlim_cur < OPEN_MAX)) {
-3.       fprintf(stderr, ""raising soft limit up to OPEN_MAX\n"");
-2.       rl.rlim_cur = OPEN_MAX;
-1.       if(setrlimit(RLIMIT_NOFILE, &rl) != 0) {

/*failure*/

1.         store_errmsg(""setrlimit() failed"", errno);
2.         fprintf(stderr, ""%s\n"", msgbuff);
3.         msgbuff[0] = '\0';
4.       }
5.     }
6. #endif
7.     fprintf(stderr, ""raising soft limit up to hard limit\n"");
8.     rl.rlim_cur = rl.rlim_max;
9.     if(setrlimit(RLIMIT_NOFILE, &rl) != 0) {",Not Useful,1
/*defined(HAVE_GETRLIMIT) && defined(HAVE_SETRLIMIT)*/,"-10.     !defined(USE_WINSOCK)       && \
-9.     !defined(FD_SETSIZE)
-8. #error ""this test requires FD_SETSIZE""
-7. #endif
-6. #define SAFETY_MARGIN (11)
-5. #if defined(WIN32) || defined(_WIN32) || defined(MSDOS)
-4. #define DEV_NULL ""NUL""
-3. #else
-2. #define DEV_NULL ""/dev/null""
-1. #endif
#if defined(HAVE_GETRLIMIT) && defined(HAVE_SETRLIMIT)

/*defined(HAVE_GETRLIMIT) && defined(HAVE_SETRLIMIT)*/

1. static int *fd = NULL;
2. static struct rlimit num_open;
3. static char msgbuff[256];
4. static void store_errmsg(const char *msg, int err)
5. {
6.   if(!err)
7.     msnprintf(msgbuff, sizeof(msgbuff), ""%s"", msg);
8.   else
9.     msnprintf(msgbuff, sizeof(msgbuff), ""%s, errno %d, %s"", msg, err,
10.               strerror(err));",Not Useful,1
/*defined(HAVE_GETRLIMIT) && defined(HAVE_SETRLIMIT)*/,"-10.     !defined(USE_WINSOCK)       && \
-9.     !defined(FD_SETSIZE)
-8. #error ""this test requires FD_SETSIZE""
-7. #endif
-6. #define SAFETY_MARGIN (11)
-5. #if defined(WIN32) || defined(_WIN32) || defined(MSDOS)
-4. #define DEV_NULL ""NUL""
-3. #else
-2. #define DEV_NULL ""/dev/null""
-1. #endif
#if defined(HAVE_GETRLIMIT) && defined(HAVE_SETRLIMIT)

/*defined(HAVE_GETRLIMIT) && defined(HAVE_SETRLIMIT)*/

1. static int *fd = NULL;
2. static struct rlimit num_open;
3. static char msgbuff[256];
4. static void store_errmsg(const char *msg, int err)
5. {
6.   if(!err)
7.     msnprintf(msgbuff, sizeof(msgbuff), ""%s"", msg);
8.   else
9.     msnprintf(msgbuff, sizeof(msgbuff), ""%s, errno %d, %s"", msg, err,
10.               strerror(err));",Not Useful,1
/*errno.h value*/,"-5. #include ""getpart.h""
-4. #include ""util.h""
-3. #include ""timeval.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

/*errno.h value*/

1. #undef  EINVAL",Not Useful,1
/*errno.h value*/,"-5. #include ""getpart.h""
-4. #include ""util.h""
-3. #include ""timeval.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

/*errno.h value*/

1. #undef  EINVAL",Not Useful,1
/*WIN32*/,"-10.     fclose(logfp);
-9.   }
-8.   else {
-7.     int error = errno;
-6.     fprintf(stderr, ""fopen() failed with error: %d %s\n"",
-5.             error, strerror(error));
-4.     fprintf(stderr, ""Error opening file: %s\n"", serverlogfile);
-3.     fprintf(stderr, ""Msg not logged: %s %s\n"", timebuf, buffer);
-2.   }
-1. }
#ifdef WIN32

/*WIN32*/

111",Not Useful,1
/*USE_WINSOCK*/,"-3. #include ""getpart.h""
-2. #include ""util.h""
-1. #include ""timeval.h""
#ifdef USE_WINSOCK

/*USE_WINSOCK*/

1. #undef  EINTR",Not Useful,1
/*set by the main code to point to where the test dir is*/,"-3.   _flushall();
-2. }

/*set by the main code to point to where the test dir is*/

1. const char *path = ""."";
2. FILE *test2fopen(long testno)
3. {
4.   FILE *stream;
5.   char filename[256];",Not Useful,1
"/** Portable function used for waiting a specific amount of ms.
 * Waiting indefinitely with this function is not allowed, a
 * zero or negative timeout value will return immediately.
 *
 * Return values:
 *   -1 = system call error, or invalid timeout value
 *    0 = specified timeout has elapsed*/","-5.   msnprintf(filename, sizeof(filename), TEST_DATA_PATH, path, testno);
-4.   stream = fopen(filename, ""rb"");
-3.   return stream;
-2. }
-1. /*
 * Portable function used for waiting a specific amount of ms.
 * Waiting indefinitely with this function is not allowed, a
 * zero or negative timeout value will return immediately.
 *
 * Return values:
 *   -1 = system call error, or invalid timeout value
 *    0 = specified timeout has elapsed

/** Portable function used for waiting a specific amount of ms.
 * Waiting indefinitely with this function is not allowed, a
 * zero or negative timeout value will return immediately.
 *
 * Return values:
 *   -1 = system call error, or invalid timeout value
 *    0 = specified timeout has elapsed*/

1.  */
2. int wait_ms(int timeout_ms)
3. {
4. #if !defined(MSDOS) && !defined(USE_WINSOCK)
5. #ifndef HAVE_POLL_FINE
6.   struct timeval pending_tv;
7. #endif
8.   struct timeval initial_tv;
9.   int pending_ms;
10. #endif",Not Useful,1
/*HAVE_POLL_FINE*/,"-10.  * Waiting indefinitely with this function is not allowed, a
-9.  * zero or negative timeout value will return immediately.
-8.  *
-7.  * Return values:
-6.  *   -1 = system call error, or invalid timeout value
-5.  *    0 = specified timeout has elapsed
-4.  */
-3. int wait_ms(int timeout_ms)
-2. {
-1. #if !defined(MSDOS) && !defined(USE_WINSOCK)
#ifndef HAVE_POLL_FINE

/*HAVE_POLL_FINE*/

1.   struct timeval pending_tv;
2. #endif
3.   struct timeval initial_tv;
4.   int pending_ms;
5. #endif
6.   int r = 0;
7.   if(!timeout_ms)
8.     return 0;
9.   if(timeout_ms < 0) {
10.     errno = EINVAL;",Not Useful,0
/*USE_WINSOCK*/,"-3. #include ""getpart.h""
-2. #include ""util.h""
-1. #include ""timeval.h""
#ifdef USE_WINSOCK

/*USE_WINSOCK*/

1. #undef  EINTR",Not Useful,0
/*copy one single byte*/,"-10.   struct WriteThis *pooh = (struct WriteThis *)userp;
-9.   int eof = !*pooh->readptr;
-8.   if(size*nmemb < 1)
-7.     return 0;
-6. #ifndef LIB645
-5.   eof = pooh->sizeleft <= 0;
-4.   if(!eof)
-3.     pooh->sizeleft--;
-2. #endif
-1.   if(!eof) {

/*copy one single byte*/

3.   }",Not Useful,1
/*advance pointer*/,"-10.   int eof = !*pooh->readptr;
-9.   if(size*nmemb < 1)
-8.     return 0;
-7. #ifndef LIB645
-6.   eof = pooh->sizeleft <= 0;
-5.   if(!eof)
-4.     pooh->sizeleft--;
-3. #endif
-2.   if(!eof) {

/*advance pointer*/

2.   }",Not Useful,1
/*we return 1 byte at a time!*/,"-10.   if(size*nmemb < 1)
-9.     return 0;
-8. #ifndef LIB645
-7.   eof = pooh->sizeleft <= 0;
-6.   if(!eof)
-5.     pooh->sizeleft--;
-4. #endif
-3.   if(!eof) {

/*we return 1 byte at a time!*/

1.   }",Not Useful,0
/*no more data left to deliver*/,"-1.   }

/*no more data left to deliver*/

1. #endif
2. }
3. static int once(char *URL, bool oldstyle)
4. {
5.   CURL *curl;
6.   CURLcode res = CURLE_OK;
7.   curl_mime *mime = NULL;
8.   curl_mimepart *part = NULL;
9.   struct WriteThis pooh;
10.   struct WriteThis pooh2;",Not Useful,1
/*new style*/,"-9.   if(oldstyle) {
-8.     res = curl_mime_name(part, ""sendfile"");
-7.     if(!res)
-6.       res = curl_mime_data_cb(part, datasize, read_callback,
-5.                               NULL, NULL, &pooh);
-4.     if(!res)
-3.       res = curl_mime_filename(part, ""postit2.c"");
-2.   }
-1.   else {

/*new style*/

1.     res = curl_mime_name(part, ""sendfile alternative"");
2.     if(!res)
3.       res = curl_mime_data_cb(part, datasize, read_callback,
4.                               NULL, NULL, &pooh);
5.     if(!res)
6.       res = curl_mime_filename(part, ""file name 2"");
7.   }
8.   if(res)
9.     printf(""curl_mime_xxx(1) = %s\n"", curl_easy_strerror(res));
10.   /* Now add the same data with another name and make it not look like",Not Useful,0
/*First set the URL that is about to receive our POST.*/,"-10.     curl_global_cleanup();
-9.     return TEST_ERR_MAJOR_BAD;
-8.   }
-7.   res = curl_mime_name(part, ""somename"");
-6.   if(!res)
-5.     res = curl_mime_filename(part, ""somefile.txt"");
-4.   if(!res)
-3.     res = curl_mime_data(part, ""blah blah"", 9);
-2.   if(res)
-1.     printf(""curl_mime_xxx(5) = %s\n"", curl_easy_strerror(res));

/*First set the URL that is about to receive our POST.*/

1.   test_setopt(curl, CURLOPT_URL, URL);",Not Useful,1
/*send a multi-part mimepost*/,"-1.   test_setopt(curl, CURLOPT_URL, URL);

/*send a multi-part mimepost*/

1.   test_setopt(curl, CURLOPT_MIMEPOST, mime);",Not Useful,1
/*get verbose debug output please*/,"-1.   test_setopt(curl, CURLOPT_MIMEPOST, mime);

/*get verbose debug output please*/

1.   test_setopt(curl, CURLOPT_VERBOSE, 1L);",Not Useful,1
/*include headers in the output*/,"-1.   test_setopt(curl, CURLOPT_VERBOSE, 1L);

/*include headers in the output*/

1.   test_setopt(curl, CURLOPT_HEADER, 1L);",Not Useful,0
"/*Perform the request, res will get the return code*/","-1.   test_setopt(curl, CURLOPT_HEADER, 1L);

/*Perform the request, res will get the return code*/

1.   res = curl_easy_perform(curl);
2. test_cleanup:",Not Useful,1
/*always cleanup*/,"-2.   res = curl_easy_perform(curl);
-1. test_cleanup:

/*always cleanup*/

1.   curl_easy_cleanup(curl);",Not Useful,1
/*now cleanup the mimepost structure*/,"-1.   curl_easy_cleanup(curl);

/*now cleanup the mimepost structure*/

1.   curl_mime_free(mime);
2.   return res;
3. }
4. static int cyclic_add(void)
5. {
6.   CURL *easy = curl_easy_init();
7.   curl_mime *mime = curl_mime_init(easy);
8.   curl_mimepart *part = curl_mime_addpart(mime);
9.   CURLcode a1 = curl_mime_subparts(part, mime);
10.   if(a1 == CURLE_BAD_FUNCTION_ARGUMENT) {",Not Useful,1
/*old*/,"-2. #endif
-1. }
static int once(char *URL, bool oldstyle)

/*old*/

1. {
2.   CURL *curl;
3.   CURLcode res = CURLE_OK;
4.   curl_mime *mime = NULL;
5.   curl_mimepart *part = NULL;
6.   struct WriteThis pooh;
7.   struct WriteThis pooh2;
8.   curl_off_t datasize = -1;
9.   pooh.readptr = data;
10. #ifndef LIB645",Not Useful,1
/*new*/,"-9.   if(oldstyle) {
-8.     res = curl_mime_name(part, ""sendfile"");
-7.     if(!res)
-6.       res = curl_mime_data_cb(part, datasize, read_callback,
-5.                               NULL, NULL, &pooh);
-4.     if(!res)
-3.       res = curl_mime_filename(part, ""postit2.c"");
-2.   }
-1.   else {

/*new*/

1.     res = curl_mime_name(part, ""sendfile alternative"");
2.     if(!res)
3.       res = curl_mime_data_cb(part, datasize, read_callback,
4.                               NULL, NULL, &pooh);
5.     if(!res)
6.       res = curl_mime_filename(part, ""file name 2"");
7.   }
8.   if(res)
9.     printf(""curl_mime_xxx(1) = %s\n"", curl_easy_strerror(res));
10.   /* Now add the same data with another name and make it not look like",Not Useful,0
/*number of threads to fire up in parallel*/,"-10.  * is a known issue the test is no longer built or run. This code is here to
-9.  * allow for testing once someone gets to work on fixing this.
-8.  */
-7. #include ""test.h""
-6. #include ""testutil.h""
-5. #include ""warnless.h""
-4. #include ""memdebug.h""
-3. #ifdef HAVE_PTHREAD_H
-2. #include <pthread.h>
-1. #include <time.h>

/*number of threads to fire up in parallel*/

1. #define NUM_THREADS 67",Not Useful,1
/*for how many seconds each thread will loop*/,"-1. #define NUM_THREADS 67

/*for how many seconds each thread will loop*/

1. #define RUN_FOR_SECONDS 7
2. static pthread_mutex_t connlock;
3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
4. {",Not Useful,1
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful,1
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful,0
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful,1
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful,1
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful,1
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful,1
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful,1
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful,1
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful,1
/*ignores error*/,"-10. {
-9.   struct initurl *u = (struct initurl *)ptr;
-8.   int i;
-7.   time_t end = time(NULL) + RUN_FOR_SECONDS;
-6.   for(i = 0; time(NULL) < end; i++) {
-5.     CURL *curl = curl_easy_init();
-4.     curl_easy_setopt(curl, CURLOPT_URL, u->url);
-3.     curl_easy_setopt(curl, CURLOPT_VERBOSE, 0L);
-2.     curl_easy_setopt(curl, CURLOPT_SHARE, u->share);
-1.     curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_db);

/*ignores error*/

1.     curl_easy_cleanup(curl);
2.     fprintf(stderr, ""Thread %d transfer %d\n"", u->threadno, i);
3.   }
4.   return NULL;
5. }
6. int test(char *URL)
7. {
8.   pthread_t tid[NUM_THREADS];
9.   int i;
10.   CURLSH *share;",Not Useful,1
/*if this happens things are major weird*/,"-10.   struct_stat file_info;
-9.   if(!libtest_arg2) {
-8.     fprintf(stderr, ""Usage: <url> <file-to-upload>\n"");
-7.     return TEST_ERR_USAGE;
-6.   }
-5.   hd_src = fopen(libtest_arg2, ""rb"");
-4.   if(!hd_src) {
-3.     fprintf(stderr, ""fopen failed with error: %d %s\n"",
-2.             errno, strerror(errno));
-1.     fprintf(stderr, ""Error opening file: %s\n"", libtest_arg2);

/*if this happens things are major weird*/

1.   }",Not Useful,1
/*enable uploading*/,"-7.   curl = curl_easy_init();
-6.   if(!curl) {
-5.     fprintf(stderr, ""curl_easy_init() failed\n"");
-4.     curl_global_cleanup();
-3.     fclose(hd_src);
-2.     return TEST_ERR_MAJOR_BAD;
-1.   }

/*enable uploading*/

1.   test_setopt(curl, CURLOPT_UPLOAD, 1L);",Not Useful,0
/*enable verbose*/,"-1.   test_setopt(curl, CURLOPT_UPLOAD, 1L);

/*enable verbose*/

1.   test_setopt(curl, CURLOPT_VERBOSE, 1L);",Not Useful,1
/*now specify which file to upload*/,"-1.   test_setopt(curl, CURLOPT_URL, URL);

/*now specify which file to upload*/

1.   test_setopt(curl, CURLOPT_READDATA, hd_src);",Not Useful,1
/*Now run off and do what you've been told!*/,"-1.   test_setopt(curl, CURLOPT_READDATA, hd_src);

/*Now run off and do what you've been told!*/

1.   curl_easy_perform(curl);",Not Useful,1
"/*and now upload the exact same again, but without rewinding so it already
     is at end of file*/","-1.   curl_easy_perform(curl);

/*and now upload the exact same again, but without rewinding so it already
     is at end of file*/

1.   res = curl_easy_perform(curl);
2. test_cleanup:",Not Useful,1
/*close the local file*/,"-2.   res = curl_easy_perform(curl);
-1. test_cleanup:

/*close the local file*/

1.   fclose(hd_src);
2.   curl_easy_cleanup(curl);
3.   curl_global_cleanup();
4.   return res;
5. }",Not Useful,0
"/*****************************************************************************
*                      STRUCT DECLARATIONS AND DEFINES                       *
*****************************************************************************/","-1. #include ""memdebug.h""
/*****************************************************************************

/*****************************************************************************
*                      STRUCT DECLARATIONS AND DEFINES                       *
*****************************************************************************/

1. *                      STRUCT DECLARATIONS AND DEFINES                       *
2. *****************************************************************************/
3. #ifndef PKTSIZE",Not Useful,1
/*SEGSIZE defined in arpa/tftp.h*/,"-1. #ifndef PKTSIZE

/*SEGSIZE defined in arpa/tftp.h*/

1. #endif
2. struct testcase {",Not Useful,1
/*size of the data in buffer*/,"-3. #endif
-2. struct testcase {

/*size of the data in buffer*/

111",Not Useful,1
/*read pointer into the buffer*/,"-4. #endif
-3. struct testcase {

/*read pointer into the buffer*/

111",Not Useful,1
/*test case number*/,"-6. #endif
-5. struct testcase {

/*test case number*/

111",Not Useful,1
/*number of seconds between each packet*/,"-8. #endif
-7. struct testcase {

/*number of seconds between each packet*/

1. };
2. struct formats {
3.   const char *f_mode;
4.   int f_convert;
5. };
6. struct errmsg {
7.   int e_code;
8.   const char *e_msg;
9. };
10. typedef union {",Not Useful,1
"/*size of data in buffer, or flag*/","-1. struct bf {

/*size of data in buffer, or flag*/

111",Not Useful,0
/*room for data packet*/,"-2. struct bf {

/*room for data packet*/

1. };",Not Useful,1
/*UDP*/,"-10. #define opcode_DATA  3
-9. #define opcode_ACK   4
-8. #define opcode_ERROR 5
-7. #define TIMEOUT      5
-6. #undef MIN
-5. #define MIN(x,y) ((x)<(y)?(x):(y))
-4. #ifndef DEFAULT_LOGFILE
-3. #define DEFAULT_LOGFILE ""log/tftpd.log""
-2. #endif
-1. #define REQUEST_DUMP  ""log/server.input""

/*UDP*/

111",Not Useful,0
"/*****************************************************************************
*                              GLOBAL VARIABLES                              *
*****************************************************************************/","-1. #include ""memdebug.h""
/*****************************************************************************

/*****************************************************************************
*                              GLOBAL VARIABLES                              *
*****************************************************************************/

1. *                      STRUCT DECLARATIONS AND DEFINES                       *
2. *****************************************************************************/
3. #ifndef PKTSIZE",Not Useful,0
/*index of next buffer to use*/,"-10.   { EEXISTS,      ""File already exists"" },
-9.   { ENOUSER,      ""No such user"" },
-8.   { -1,           0 }
-7. };
-6. static const struct formats formata[] = {
-5.   { ""netascii"",   1 },
-4.   { ""octet"",      0 },
-3.   { NULL,         0 }
-2. };
-1. static struct bf bfs[2];

/*index of next buffer to use*/

111",Not Useful,0
/*index of buffer in use*/,"-10.   { ENOUSER,      ""No such user"" },
-9.   { -1,           0 }
-8. };
-7. static const struct formats formata[] = {
-6.   { ""netascii"",   1 },
-5.   { ""octet"",      0 },
-4.   { NULL,         0 }
-3. };
-2. static struct bf bfs[2];

/*index of buffer in use*/

111",Not Useful,1
"/*****************************************************************************
*                            FUNCTION PROTOTYPES                             *
*****************************************************************************/","-1. #include ""memdebug.h""
/*****************************************************************************

/*****************************************************************************
*                            FUNCTION PROTOTYPES                             *
*****************************************************************************/

1. *                      STRUCT DECLARATIONS AND DEFINES                       *
2. *****************************************************************************/
3. #ifndef PKTSIZE",Not Useful,0
/*HAVE_ALARM && SIGALRM*/,"-10. static int synchnet(curl_socket_t);
-9. static int do_tftp(struct testcase *test, struct tftphdr *tp, ssize_t size);
-8. static int validate_access(struct testcase *test, const char *fname, int mode);
-7. static void sendtftp(struct testcase *test, const struct formats *pf);
-6. static void recvtftp(struct testcase *test, const struct formats *pf);
-5. static void nak(int error);
-4. #if defined(HAVE_ALARM) && defined(SIGALRM)
-3. static void mysignal(int sig, void (*handler)(int));
-2. static void timer(int signum);
-1. static void justtimeout(int signum);

/*HAVE_ALARM && SIGALRM*/

111",Not Useful,1
"/*****************************************************************************
*                          FUNCTION IMPLEMENTATIONS                          *
*****************************************************************************/","-1. #include ""memdebug.h""
/*****************************************************************************

/*****************************************************************************
*                          FUNCTION IMPLEMENTATIONS                          *
*****************************************************************************/

1. *                      STRUCT DECLARATIONS AND DEFINES                       *
2. *****************************************************************************/
3. #ifndef PKTSIZE",Not Useful,1
/*HAVE_ALARM && SIGALRM*/,"-10. static int synchnet(curl_socket_t);
-9. static int do_tftp(struct testcase *test, struct tftphdr *tp, ssize_t size);
-8. static int validate_access(struct testcase *test, const char *fname, int mode);
-7. static void sendtftp(struct testcase *test, const struct formats *pf);
-6. static void recvtftp(struct testcase *test, const struct formats *pf);
-5. static void nak(int error);
-4. #if defined(HAVE_ALARM) && defined(SIGALRM)
-3. static void mysignal(int sig, void (*handler)(int));
-2. static void timer(int signum);
-1. static void justtimeout(int signum);

/*HAVE_ALARM && SIGALRM*/

111",Not Useful,1
/*init crlf flag*/,"-2. static struct tftphdr *rw_init(int x)
-1. {

/*init crlf flag*/

1.   prevchar = -1;",Not Useful,1
/*ahead or behind?*/,"-2.   current = 0;
-1.   bfs[1].counter = BF_FREE;

/*ahead or behind?*/

1.   return &bfs[0].buf.hdr;
2. }
3. static struct tftphdr *w_init(void)
4. {",Not Useful,0
/*write-behind*/,"-1. /*
 * init for either read-ahead or write-behind.

/*write-behind*/

1.  * zero for write-behind, one for read-head.
2.  */
3. static struct tftphdr *rw_init(int x)
4. {",Not Useful,1
/*read-ahead*/,"-1. /*
 * init for either read-ahead or write-behind.

/*read-ahead*/

1.  * zero for write-behind, one for read-head.
2.  */
3. static struct tftphdr *rw_init(int x)
4. {",Not Useful,1
"/*The former file reading code did this:
       b->counter = read(fileno(file), dp->th_data, SEGSIZE);*/","-2.   dp = &b->buf.hdr;
-1.   if(convert == 0) {

/*The former file reading code did this:
       b->counter = read(fileno(file), dp->th_data, SEGSIZE);*/

1.     size_t copy_n = MIN(SEGSIZE, test->rcount);
2.     memcpy(dp->th_data, test->rptr, copy_n);",Not Useful,1
"/*decrease amount, advance pointer*/","-2.     size_t copy_n = MIN(SEGSIZE, test->rcount);
-1.     memcpy(dp->th_data, test->rptr, copy_n);

/*decrease amount, advance pointer*/

1.     test->rcount -= copy_n;
2.     test->rptr += copy_n;
3.     b->counter = (int)copy_n;
4.     return;
5.   }
6.   p = dp->th_data;
7.   for(i = 0 ; i < SEGSIZE; i++) {
8.     if(newline) {
9.       if(prevchar == '\n')",Not Useful,1
"/*lf to cr,lf*/","-9.     test->rcount -= copy_n;
-8.     test->rptr += copy_n;
-7.     b->counter = (int)copy_n;
-6.     return;
-5.   }
-4.   p = dp->th_data;
-3.   for(i = 0 ; i < SEGSIZE; i++) {
-2.     if(newline) {
-1.       if(prevchar == '\n')

/*lf to cr,lf*/

1.       else",Not Useful,1
"/*cr to cr,nul*/","-1.       else

/*cr to cr,nul*/

1.       newline = 0;
2.     }
3.     else {
4.       if(test->rcount) {
5.         c = test->rptr[0];
6.         test->rptr++;
7.         test->rcount--;
8.       }
9.       else
10.         break;",Not Useful,1
/*set size of data to write*/,"-3. static int writeit(struct testcase *test, struct tftphdr * volatile *dpp,
-2.                    int ct, int convert)
-1. {

/*set size of data to write*/

111",Not Useful,1
/*switch to other buffer*/,"-4. static int writeit(struct testcase *test, struct tftphdr * volatile *dpp,
-3.                    int ct, int convert)
-2. {

/*switch to other buffer*/

111",Not Useful,1
/*if not free*/,"-7. {
-6.   int i;
-5.   char *p;
-4.   int c;
-3.   struct bf *b;
-2.   struct tftphdr *dp;

/*if not free*/

1.     return;",Not Useful,1
/*flush it*/,"-6. static int writeit(struct testcase *test, struct tftphdr * volatile *dpp,
-5.                    int ct, int convert)
-4. {

/*flush it*/

111",Not Useful,1
/*mark as alloc'd*/,"-7. static int writeit(struct testcase *test, struct tftphdr * volatile *dpp,
-6.                    int ct, int convert)
-5. {

/*mark as alloc'd*/

1.   *dpp =  &bfs[current].buf.hdr;",Not Useful,1
/*this is a lie of course*/,"-1.   *dpp =  &bfs[current].buf.hdr;

/*this is a lie of course*/

1. }",Not Useful,1
/*current character*/,"-10.  * CR, NUL -> CR  and CR, LF => LF.
-9.  * Note spec is undefined if we get CR as last byte of file or a
-8.  * CR followed by anything else.  In this case we leave it alone.
-7.  */
-6. static ssize_t write_behind(struct testcase *test, int convert)
-5. {
-4.   char *writebuf;
-3.   int count;
-2.   int ct;
-1.   char *p;

/*current character*/

1.   struct bf *b;
2.   struct tftphdr *dp;
3.   b = &bfs[nextone];",Not Useful,1
/*anything to flush?*/,"-3.   struct bf *b;
-2.   struct tftphdr *dp;
-1.   b = &bfs[nextone];

/*anything to flush?*/

111",Not Useful,1
/*just nop if nothing to do*/,"-4.   struct bf *b;
-3.   struct tftphdr *dp;
-2.   b = &bfs[nextone];

/*just nop if nothing to do*/

1.   if(!test->ofile) {
2.     char outfile[256];
3.     msnprintf(outfile, sizeof(outfile), ""log/upload.%ld"", test->testno);
4. #ifdef WIN32
5.     test->ofile = open(outfile, O_CREAT|O_RDWR|O_BINARY, 0777);
6. #else
7.     test->ofile = open(outfile, O_CREAT|O_RDWR, 0777);
8. #endif
9.     if(test->ofile == -1) {
10.       logmsg(""Couldn't create and/or open file %s for upload!"", outfile);",Not Useful,1
/*remember byte count*/,"-2.     }
-1.   }

/*remember byte count*/

111",Not Useful,1
/*reset flag*/,"-3.     }
-2.   }

/*reset flag*/

1.   dp = &b->buf.hdr;",Not Useful,1
/*incr for next time*/,"-1.   dp = &b->buf.hdr;

/*incr for next time*/

1.   writebuf = dp->th_data;
2.   if(count <= 0)",Not Useful,1
/*loop over the buffer*/,"-4.   if(convert == 0)
-3.     return write(test->ofile, writebuf, count);
-2.   p = writebuf;
-1.   ct = count;

/*loop over the buffer*/

111",Not Useful,1
/*pick up a character*/,"-5.   if(convert == 0)
-4.     return write(test->ofile, writebuf, count);
-3.   p = writebuf;
-2.   ct = count;

/*pick up a character*/

111",Not Useful,0
/*if prev char was cr*/,"-6.   if(convert == 0)
-5.     return write(test->ofile, writebuf, count);
-4.   p = writebuf;
-3.   ct = count;

/*if prev char was cr*/

111",Not Useful,1
"/*if have cr,lf then just*/","-7.   if(convert == 0)
-6.     return write(test->ofile, writebuf, count);
-5.   p = writebuf;
-4.   ct = count;

/*if have cr,lf then just*/

111",Not Useful,1
/*smash lf on top of the cr*/,"-8.   if(convert == 0)
-7.     return write(test->ofile, writebuf, count);
-6.   p = writebuf;
-5.   ct = count;

/*smash lf on top of the cr*/

1.       else",Not Useful,1
"/*if have cr,nul then*/","-1.       else

/*if have cr,nul then*/

111",Not Useful,1
/*just skip over the putc*/,"-2.       else

/*just skip over the putc*/

111",Not Useful,1
/*else just fall through and allow it*/,"-3.       else

/*else just fall through and allow it*/

1.     }",Not Useful,0
"/*formerly
       putc(c, file);*/","-5.       else

/*formerly
       putc(c, file);*/

1.     if(1 != write(test->ofile, &c, 1))
2.       break;
3.     skipit:
4.     prevchar = c;
5.   }
6.   return count;
7. }
8. /* When an error has occurred, it is possible that the two sides are out of
9.  * synch.  Ie: that what I think is the other side's response to packet N is
10.  * really their response to packet N-1.",Not Useful,1
/*store input protocol*/,"-7.   FILE *server = fopen(REQUEST_DUMP, ""ab"");
-6.   if(!server) {
-5.     int error = errno;
-4.     logmsg(""fopen() failed with error: %d %s"", error, strerror(error));
-3.     logmsg(""Error opening file: %s"", REQUEST_DUMP);
-2.     return -1;
-1.   }

/*store input protocol*/

1.   fprintf(server, ""opcode = %x\n"", tp->th_opcode);
2.   cp = (char *)&tp->th_stuff;
3.   filename = cp;
4.   do {
5.     bool endofit = true;
6.     while(cp < &buf.storage[size]) {
7.       if(*cp == '\0') {
8.         endofit = false;
9.         break;
10.       }",Not Useful,1
/*no more options*/,"-10.   do {
-9.     bool endofit = true;
-8.     while(cp < &buf.storage[size]) {
-7.       if(*cp == '\0') {
-6.         endofit = false;
-5.         break;
-4.       }
-3.       cp++;
-2.     }
-1.     if(endofit)

/*no more options*/

1.       break;",Not Useful,1
/*No more options*/,"-5.         option = cp;
-4.       }
-3.       toggle ^= 1;
-2.     }
-1.     else

/*No more options*/

1.       break;
2.   } while(1);
3.   if(*cp) {
4.     nak(EBADOP);
5.     fclose(server);
6.     return 3;
7.   }",Not Useful,0
/*get to the letter following the newline*/,"-4.       check = strchr(cmd, '\r');
-3.       if(!check)
-2.         check = strchr(cmd, '\n');
-1.       if(check) {

/*get to the letter following the newline*/

1.         while((*check == '\r') || (*check == '\n'))
2.           check++;
3.         if(!*check)",Not Useful,1
"/*if we reached a zero, get out*/","-3.         while((*check == '\r') || (*check == '\n'))
-2.           check++;
-1.         if(!*check)

/*if we reached a zero, get out*/

1.           break;
2.         cmd = check;
3.       }
4.       else
5.         break;
6.     }
7.     free(orgcmd);
8.   }",Not Useful,1
/** Validate file access.*/,"-2. }
-1. /*
 * Validate file access.

/** Validate file access.*/

1.  */
2. static int validate_access(struct testcase *test,
3.                            const char *filename, int mode)
4. {
5.   char *ptr;
6.   logmsg(""trying to get file: %s mode %x"", filename, mode);
7.   if(!strncmp(""verifiedserver"", filename, 14)) {
8.     char weare[128];
9.     size_t count = msnprintf(weare, sizeof(weare), ""WE ROOLZ: %""
10.                              CURL_FORMAT_CURL_OFF_T ""\r\n"", our_getpid());",Not Useful,1
/*set read pointer*/,"-10.                            const char *filename, int mode)
-9. {
-8.   char *ptr;
-7.   logmsg(""trying to get file: %s mode %x"", filename, mode);
-6.   if(!strncmp(""verifiedserver"", filename, 14)) {
-5.     char weare[128];
-4.     size_t count = msnprintf(weare, sizeof(weare), ""WE ROOLZ: %""
-3.                              CURL_FORMAT_CURL_OFF_T ""\r\n"", our_getpid());
-2.     logmsg(""Are-we-friendly question received"");
-1.     test->buffer = strdup(weare);

/*set read pointer*/

111",Not Useful,1
/*set total count*/,"-10. {
-9.   char *ptr;
-8.   logmsg(""trying to get file: %s mode %x"", filename, mode);
-7.   if(!strncmp(""verifiedserver"", filename, 14)) {
-6.     char weare[128];
-5.     size_t count = msnprintf(weare, sizeof(weare), ""WE ROOLZ: %""
-4.                              CURL_FORMAT_CURL_OFF_T ""\r\n"", our_getpid());
-3.     logmsg(""Are-we-friendly question received"");
-2.     test->buffer = strdup(weare);

/*set total count*/

111",Not Useful,1
/*set data left to read*/,"-10.   char *ptr;
-9.   logmsg(""trying to get file: %s mode %x"", filename, mode);
-8.   if(!strncmp(""verifiedserver"", filename, 14)) {
-7.     char weare[128];
-6.     size_t count = msnprintf(weare, sizeof(weare), ""WE ROOLZ: %""
-5.                              CURL_FORMAT_CURL_OFF_T ""\r\n"", our_getpid());
-4.     logmsg(""Are-we-friendly question received"");
-3.     test->buffer = strdup(weare);

/*set data left to read*/

111",Not Useful,0
/*find the last slash*/,"-1.   }

/*find the last slash*/

1.   ptr = strrchr(filename, '/');
2.   if(ptr) {
3.     char partbuf[80]=""data"";
4.     long partno;
5.     long testno;
6.     FILE *stream;",Not Useful,1
/*set read pointer*/,"-10.                            const char *filename, int mode)
-9. {
-8.   char *ptr;
-7.   logmsg(""trying to get file: %s mode %x"", filename, mode);
-6.   if(!strncmp(""verifiedserver"", filename, 14)) {
-5.     char weare[128];
-4.     size_t count = msnprintf(weare, sizeof(weare), ""WE ROOLZ: %""
-3.                              CURL_FORMAT_CURL_OFF_T ""\r\n"", our_getpid());
-2.     logmsg(""Are-we-friendly question received"");
-1.     test->buffer = strdup(weare);

/*set read pointer*/

111",Not Useful,0
/*set total count*/,"-10. {
-9.   char *ptr;
-8.   logmsg(""trying to get file: %s mode %x"", filename, mode);
-7.   if(!strncmp(""verifiedserver"", filename, 14)) {
-6.     char weare[128];
-5.     size_t count = msnprintf(weare, sizeof(weare), ""WE ROOLZ: %""
-4.                              CURL_FORMAT_CURL_OFF_T ""\r\n"", our_getpid());
-3.     logmsg(""Are-we-friendly question received"");
-2.     test->buffer = strdup(weare);

/*set total count*/

111",Not Useful,1
/*set data left to read*/,"-10.   char *ptr;
-9.   logmsg(""trying to get file: %s mode %x"", filename, mode);
-8.   if(!strncmp(""verifiedserver"", filename, 14)) {
-7.     char weare[128];
-6.     size_t count = msnprintf(weare, sizeof(weare), ""WE ROOLZ: %""
-5.                              CURL_FORMAT_CURL_OFF_T ""\r\n"", our_getpid());
-4.     logmsg(""Are-we-friendly question received"");
-3.     test->buffer = strdup(weare);

/*set data left to read*/

111",Not Useful,0
/*block count*/,"-5. static void sendtftp(struct testcase *test, const struct formats *pf)
-4. {
-3.   int size;
-2.   ssize_t n;

/*block count*/

111",Not Useful,1
/*block count*/,"-5. static void sendtftp(struct testcase *test, const struct formats *pf)
-4. {
-3.   int size;
-2.   ssize_t n;

/*block count*/

111",Not Useful,1
/*really?*/,"-10.       alarm(rexmtval);
-9. #endif
-8.       logmsg(""read"");
-7.       n = sread(peer, rdp, PKTSIZE);
-6.       logmsg(""read: %zd"", n);
-5. #ifdef HAVE_ALARM
-4.       alarm(0);
-3. #endif
-2.       if(got_exit_signal)
-1.         goto abort;

/*really?*/

1.         logmsg(""read: fail"");
2.         goto abort;
3.       }
4.       rdp->th_opcode = ntohs((unsigned short)rdp->th_opcode);
5.       rdp->th_block = ntohs(rdp->th_block);
6.       if(rdp->th_opcode == opcode_ERROR)
7.         goto abort;
8.       if(rdp->th_opcode == opcode_DATA) {
9.         if(rdp->th_block == recvblock) {",Not Useful,1
/*rexmit*/,"-2.         (void) synchnet(peer);
-1.         if(rdp->th_block == (recvblock-1))

/*rexmit*/

1.       }
2.     }
3.     size = writeit(test, &rdp, (int)(n - 4), pf->f_convert);",Not Useful,1
/*ahem*/,"-3.       }
-2.     }
-1.     size = writeit(test, &rdp, (int)(n - 4), pf->f_convert);

/*ahem*/

1.       if(size < 0)
2.         nak(errno + 100);
3.       else
4.         nak(ENOSPACE);
5.       goto abort;
6.     }
7.   } while(size == SEGSIZE);
8.   write_behind(test, pf->f_convert);",Not Useful,1
/*if read some data*/,"-6.   n = sread(peer, &buf.storage[0], sizeof(buf.storage));
-5. #ifdef HAVE_ALARM
-4.   alarm(0);
-3. #endif
-2.   if(got_exit_signal)
-1.     goto abort;

/*if read some data*/

111",Not Useful,0
/*and got a data block*/,"-7.   n = sread(peer, &buf.storage[0], sizeof(buf.storage));
-6. #ifdef HAVE_ALARM
-5.   alarm(0);
-4. #endif
-3.   if(got_exit_signal)
-2.     goto abort;

/*and got a data block*/

111",Not Useful,1
"/** This is a fake ntlm_auth, which is used for testing NTLM single-sign-on.
 * When DEBUGBUILD is defined, libcurl invoke this tool instead of real winbind
 * daemon helper /usr/bin/ntlm_auth. This tool will accept commands and
 * responses with a pre-written string saved in test case test2005.*/","-10.  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
-9.  * copies of the Software, and permit persons to whom the Software is
-8.  * furnished to do so, under the terms of the COPYING file.
-7.  *
-6.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-5.  * KIND, either express or implied.
-4.  *
-3.  ***************************************************************************/
-2. #include ""server_setup.h""
-1. /*
 * This is a fake ntlm_auth, which is used for testing NTLM single-sign-on.
 * When DEBUGBUILD is defined, libcurl invoke this tool instead of real winbind
 * daemon helper /usr/bin/ntlm_auth. This tool will accept commands and
 * responses with a pre-written string saved in test case test2005.

/** This is a fake ntlm_auth, which is used for testing NTLM single-sign-on.
 * When DEBUGBUILD is defined, libcurl invoke this tool instead of real winbind
 * daemon helper /usr/bin/ntlm_auth. This tool will accept commands and
 * responses with a pre-written string saved in test case test2005.*/

1.  */
2. #define ENABLE_CURLX_PRINTF",Not Useful,1
"/** The purpose of this tool is to figure out which, if any, features that are
 * disabled which should otherwise exist and work. These aren't visible in
 * regular curl -V output.
 *
 * Disabled protocols are visible in curl_version_info() and are not included
 * in this table.*/","-10.  *
-9.  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
-8.  * copies of the Software, and permit persons to whom the Software is
-7.  * furnished to do so, under the terms of the COPYING file.
-6.  *
-5.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-4.  * KIND, either express or implied.
-3.  *
-2.  ***************************************************************************/
-1. /*
 * The purpose of this tool is to figure out which, if any, features that are
 * disabled which should otherwise exist and work. These aren't visible in
 * regular curl -V output.
 *
 * Disabled protocols are visible in curl_version_info() and are not included
 * in this table.

/** The purpose of this tool is to figure out which, if any, features that are
 * disabled which should otherwise exist and work. These aren't visible in
 * regular curl -V output.
 *
 * Disabled protocols are visible in curl_version_info() and are not included
 * in this table.*/

1.  */
2. #include ""curl_setup.h""",Not Useful,0
"/*argv1 = URL
 * argv2 = proxy
 * argv3 = proxyuser:password*/","-9.  *
-8.  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
-7.  * copies of the Software, and permit persons to whom the Software is
-6.  * furnished to do so, under the terms of the COPYING file.
-5.  *
-4.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-3.  * KIND, either express or implied.
-2.  *
-1.  ***************************************************************************/
/* argv1 = URL
 * argv2 = proxy
 * argv3 = proxyuser:password

/*argv1 = URL
 * argv2 = proxy
 * argv3 = proxyuser:password*/

1.  */
2. #include ""test.h""
3. #include ""memdebug.h""
4. #define UPLOADTHIS ""this is the blurb we want to upload\n""
5. #ifndef LIB548
6. static size_t readcallback(char  *ptr,
7.                            size_t size,
8.                            size_t nmemb,
9.                            void *clientp)
10. {",Not Useful,0
/*bump*/,"-3.     fprintf(stderr, ""READ ALREADY DONE!\n"");
-2.     return 0;
-1.   }

/*bump*/

1.   if(size * nmemb > strlen(UPLOADTHIS)) {
2.     fprintf(stderr, ""READ!\n"");
3.     strcpy(ptr, UPLOADTHIS);
4.     return strlen(UPLOADTHIS);
5.   }
6.   fprintf(stderr, ""READ NOT FINE!\n"");
7.   return 0;
8. }
9. static curlioerr ioctlcallback(CURL *handle,
10.                                int cmd,",Not Useful,1
/*unused*/,"-10.     return strlen(UPLOADTHIS);
-9.   }
-8.   fprintf(stderr, ""READ NOT FINE!\n"");
-7.   return 0;
-6. }
-5. static curlioerr ioctlcallback(CURL *handle,
-4.                                int cmd,
-3.                                void *clientp)
-2. {
-1.   int *counter = (int *)clientp;

/*unused*/

1.   if(cmd == CURLIOCMD_RESTARTREAD) {
2.     fprintf(stderr, ""REWIND!\n"");",Not Useful,0
/*clear counter to make the read callback restart*/,"-2.   if(cmd == CURLIOCMD_RESTARTREAD) {
-1.     fprintf(stderr, ""REWIND!\n"");

/*clear counter to make the read callback restart*/

1.   }
2.   return CURLIOE_OK;
3. }
4. #endif
5. int test(char *URL)
6. {
7.   CURLcode res;
8.   CURL *curl;
9. #ifndef LIB548
10.   int counter = 0;",Not Useful,1
/*always cleanup*/,"-2.   res = curl_easy_perform(curl);
-1. test_cleanup:

/*always cleanup*/

1.   curl_easy_cleanup(curl);
2.   curl_global_cleanup();
3.   return (int)res;
4. }",Not Useful,0
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

/*errno.h value*/

1. #undef  EAGAIN",Not Useful,1
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

/*errno.h value*/

1. #undef  EAGAIN",Not Useful,1
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

/*errno.h value*/

1. #undef  EAGAIN",Not Useful,0
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

/*errno.h value*/

1. #undef  EAGAIN",Not Useful,1
/** read-wrapper to support reading from stdin on Windows.*/,"-3. };
-2. #ifdef WIN32
-1. /*
 * read-wrapper to support reading from stdin on Windows.

/** read-wrapper to support reading from stdin on Windows.*/

1.  */
2. static ssize_t read_wincon(int fd, void *buf, size_t count)
3. {
4.   HANDLE handle = NULL;
5.   DWORD mode, rcount = 0;
6.   BOOL success;
7.   if(fd == fileno(stdin)) {
8.     handle = GetStdHandle(STD_INPUT_HANDLE);
9.   }
10.   else {",Not Useful,1
/** write-wrapper to support writing to stdout and stderr on Windows.*/,"-10.   }
-9.   if(success) {
-8.     return rcount;
-7.   }
-6.   errno = GetLastError();
-5.   return -1;
-4. }
-3. #undef  read
-2. #define read(a,b,c) read_wincon(a,b,c)
-1. /*
 * write-wrapper to support writing to stdout and stderr on Windows.

/** write-wrapper to support writing to stdout and stderr on Windows.*/

1.  */
2. static ssize_t write_wincon(int fd, const void *buf, size_t count)
3. {
4.   HANDLE handle = NULL;
5.   DWORD mode, wcount = 0;
6.   BOOL success;
7.   if(fd == fileno(stdout)) {
8.     handle = GetStdHandle(STD_OUTPUT_HANDLE);
9.   }
10.   else if(fd == fileno(stderr)) {",Not Useful,1
/*actual handle to wait for during select*/,"-2.  */
-1. struct select_ws_wait_data {

/*actual handle to wait for during select*/

111",Not Useful,0
/*internal event to abort waiting thread*/,"-4.  */
-3. struct select_ws_wait_data {

/*internal event to abort waiting thread*/

111",Not Useful,1
/*get total size of file*/,"-10.         * - comparison of current position in file and total size of
-9.         *   the file can be used to check if we reached the end yet.
-8.         *
-7.         * Approach: Loop till either the internal event is signalled
-6.         *           or if the end of the file has already been reached.
-5.         */
-4.       while(WaitForMultipleObjectsEx(1, handles, FALSE, 0, FALSE)
-3.             == WAIT_TIMEOUT) {
-2.         ret = WaitForSingleObjectEx(mutex, 0, FALSE);
-1.         if(ret == WAIT_OBJECT_0) {

/*get total size of file*/

1.           length = 0;
2.           size.QuadPart = 0;
3.           size.LowPart = GetFileSize(handle, &length);
4.           if((size.LowPart != INVALID_FILE_SIZE) ||
5.              (GetLastError() == NO_ERROR)) {
6.             size.HighPart = length;",Not Useful,1
/*get the current position within the file*/,"-6.           length = 0;
-5.           size.QuadPart = 0;
-4.           size.LowPart = GetFileSize(handle, &length);
-3.           if((size.LowPart != INVALID_FILE_SIZE) ||
-2.              (GetLastError() == NO_ERROR)) {
-1.             size.HighPart = length;

/*get the current position within the file*/

1.             pos.QuadPart = 0;
2.             pos.LowPart = SetFilePointer(handle, 0, &pos.HighPart,
3.                                         FILE_CURRENT);
4.             if((pos.LowPart != INVALID_SET_FILE_POINTER) ||
5.                (GetLastError() == NO_ERROR)) {",Not Useful,1
"/*compare position with size, abort if not equal*/","-5.             pos.QuadPart = 0;
-4.             pos.LowPart = SetFilePointer(handle, 0, &pos.HighPart,
-3.                                         FILE_CURRENT);
-2.             if((pos.LowPart != INVALID_SET_FILE_POINTER) ||
-1.                (GetLastError() == NO_ERROR)) {

/*compare position with size, abort if not equal*/

1.               if(size.QuadPart == pos.QuadPart) {",Not Useful,1
/*sleep and continue waiting*/,"-1.               if(size.QuadPart == pos.QuadPart) {

/*sleep and continue waiting*/

1.                 SleepEx(0, FALSE);
2.                 ReleaseMutex(mutex);
3.                 continue;
4.               }
5.             }
6.           }",Not Useful,1
"/*there is some data available, stop waiting*/","-6.                 SleepEx(0, FALSE);
-5.                 ReleaseMutex(mutex);
-4.                 continue;
-3.               }
-2.             }
-1.           }

/*there is some data available, stop waiting*/

1.           logmsg(""[select_ws_wait_thread] data available, DISK: %p"", handle);
2.           SetEvent(signal);
3.           ReleaseMutex(mutex);
4.           break;
5.         }
6.         else if(ret == WAIT_ABANDONED) {",Not Useful,0
/*check if this is an actual console handle*/,"-10.         * - WaitForMultipleObjectsEx will be signalled on any kind of input,
-9.         *   including mouse and window size events we do not care about.
-8.         *
-7.         * Approach: Loop till either the internal event is signalled
-6.         *           or we get signalled for an actual key-event.
-5.         */
-4.       while(WaitForMultipleObjectsEx(2, handles, FALSE, INFINITE, FALSE)
-3.             == WAIT_OBJECT_0 + 1) {
-2.         ret = WaitForSingleObjectEx(mutex, 0, FALSE);
-1.         if(ret == WAIT_OBJECT_0) {

/*check if this is an actual console handle*/

1.           if(GetConsoleMode(handle, &ret)) {",Not Useful,1
/*retrieve an event from the console buffer*/,"-1.           if(GetConsoleMode(handle, &ret)) {

/*retrieve an event from the console buffer*/

1.             length = 0;
2.             if(PeekConsoleInput(handle, &inputrecord, 1, &length)) {",Not Useful,1
/*check if the event is not an actual key-event*/,"-2.             length = 0;
-1.             if(PeekConsoleInput(handle, &inputrecord, 1, &length)) {

/*check if the event is not an actual key-event*/

1.               if(length == 1 && inputrecord.EventType != KEY_EVENT) {",Not Useful,1
/*purge the non-key-event and continue waiting*/,"-1.               if(length == 1 && inputrecord.EventType != KEY_EVENT) {

/*purge the non-key-event and continue waiting*/

1.                 ReadConsoleInput(handle, &inputrecord, 1, &length);
2.                 ReleaseMutex(mutex);
3.                 continue;
4.               }
5.             }
6.           }",Not Useful,1
"/*there is some data available, stop waiting*/","-6.                 SleepEx(0, FALSE);
-5.                 ReleaseMutex(mutex);
-4.                 continue;
-3.               }
-2.             }
-1.           }

/*there is some data available, stop waiting*/

1.           logmsg(""[select_ws_wait_thread] data available, DISK: %p"", handle);
2.           SetEvent(signal);
3.           ReleaseMutex(mutex);
4.           break;
5.         }
6.         else if(ret == WAIT_ABANDONED) {",Not Useful,1
/*peek into the pipe and retrieve the amount of data available*/,"-7.           break;
-6.         }
-5.       }
-4.       break;
-3.     case FILE_TYPE_PIPE:
-2.        /* The handle represents an anonymous or named pipe, this means:
-1.         * - WaitForMultipleObjectsEx will always be signalled for it.
        * - peek into the pipe and retrieve the amount of data available.

/*peek into the pipe and retrieve the amount of data available*/

1.         *
2.         * Approach: Loop till either the internal event is signalled
3.         *           or there is data in the pipe available for reading.
4.         */
5.       while(WaitForMultipleObjectsEx(1, handles, FALSE, 0, FALSE)
6.             == WAIT_TIMEOUT) {
7.         ret = WaitForSingleObjectEx(mutex, 0, FALSE);
8.         if(ret == WAIT_OBJECT_0) {",Not Useful,1
"/*if there is no data available, sleep and continue waiting*/","-2.           length = 0;
-1.           if(PeekNamedPipe(handle, NULL, 0, NULL, &length, NULL)) {

/*if there is no data available, sleep and continue waiting*/

1.             if(length == 0) {
2.               SleepEx(0, FALSE);
3.               ReleaseMutex(mutex);
4.               continue;
5.             }
6.             else {
7.               logmsg(""[select_ws_wait_thread] PeekNamedPipe len: %d"", length);
8.             }
9.           }
10.           else {",Not Useful,1
"/*there is some data available, stop waiting*/","-6.                 SleepEx(0, FALSE);
-5.                 ReleaseMutex(mutex);
-4.                 continue;
-3.               }
-2.             }
-1.           }

/*there is some data available, stop waiting*/

1.           logmsg(""[select_ws_wait_thread] data available, DISK: %p"", handle);
2.           SetEvent(signal);
3.           ReleaseMutex(mutex);
4.           break;
5.         }
6.         else if(ret == WAIT_ABANDONED) {",Not Useful,1
"/*The handle has an unknown type, try to wait on it*/","-5.           break;
-4.         }
-3.       }
-2.       break;
-1.     default:

/*The handle has an unknown type, try to wait on it*/

1.       if(WaitForMultipleObjectsEx(2, handles, FALSE, INFINITE, FALSE)
2.          == WAIT_OBJECT_0 + 1) {
3.         if(WaitForSingleObjectEx(mutex, 0, FALSE) == WAIT_OBJECT_0) {
4.           logmsg(""[select_ws_wait_thread] data available, HANDLE: %p"", handle);
5.           SetEvent(signal);
6.           ReleaseMutex(mutex);
7.         }
8.       }
9.       break;
10.   }",Not Useful,1
/*allocate internal waiting data structure*/,"-10.       }
-9.       break;
-8.   }
-7.   return 0;
-6. }
-5. static HANDLE select_ws_wait(HANDLE handle, HANDLE signal,
-4.                              HANDLE abort, HANDLE mutex)
-3. {
-2.   struct select_ws_wait_data *data;
-1.   HANDLE thread = NULL;

/*allocate internal waiting data structure*/

1.   data = malloc(sizeof(struct select_ws_wait_data));
2.   if(data) {
3.     data->handle = handle;
4.     data->signal = signal;
5.     data->abort = abort;
6.     data->mutex = mutex;",Not Useful,1
/*free data if thread failed to launch*/,"-3.     thread = CreateThread(NULL, 0,
-2.                           &select_ws_wait_thread,
-1.                           data, 0, NULL);

/*free data if thread failed to launch*/

1.     if(!thread) {
2.       free(data);
3.     }
4.   }
5.   return thread;
6. }
7. struct select_ws_data {",Not Useful,1
/*check if the input value is valid*/,"-10.                      fd_set *exceptfds, struct timeval *tv)
-9. {
-8.   HANDLE abort, mutex, signal, handle, *handles;
-7.   DWORD timeout_ms, wait, nfd, nth, nws, i;
-6.   fd_set readsock, writesock, exceptsock;
-5.   struct select_ws_data *data;
-4.   WSANETWORKEVENTS wsaevents;
-3.   curl_socket_t wsasock;
-2.   int error, ret, fd;
-1.   WSAEVENT wsaevent;

/*check if the input value is valid*/

1.   if(nfds < 0) {
2.     errno = EINVAL;
3.     return -1;
4.   }",Not Useful,1
/*convert struct timeval to milliseconds*/,"-4.   if(nfds < 0) {
-3.     errno = EINVAL;
-2.     return -1;
-1.   }

/*convert struct timeval to milliseconds*/

1.   if(tv) {
2.     timeout_ms = (DWORD)curlx_tvtoms(tv);
3.   }
4.   else {
5.     timeout_ms = INFINITE;
6.   }",Not Useful,1
"/*first handle stdin, stdout and stderr*/","-2.     if(wait != WAIT_FAILED && (wait - WAIT_OBJECT_0) <= i &&
-1.        WaitForSingleObjectEx(handle, 0, FALSE) == WAIT_OBJECT_0) {

/*first handle stdin, stdout and stderr*/

1.       if(fd == fileno(stdin)) {",Not Useful,1
/*sockfd turns CURL_SOCKET_BAD when our connection has been closed*/,"-6.       FD_SET(sockfd, &fds_read);
-5.       maxfd = (int)sockfd;
-4.     }
-3.     break;
-2.   case ACTIVE:
-1.     sockfd = *sockfdp;

/*sockfd turns CURL_SOCKET_BAD when our connection has been closed*/

1.     if(CURL_SOCKET_BAD != sockfd) {
2.       FD_SET(sockfd, &fds_read);
3.       maxfd = (int)sockfd;
4.     }
5.     else {
6.       logmsg(""No socket to read on"");
7.       maxfd = 0;
8.     }
9.     break;
10.   case ACTIVE_DISCONNECT:",Not Useful,1
/*switch(*mode)*/,"-10.     logmsg(""process becomes orphan, exiting"");
-9.     return FALSE;
-8.   }
-7. #endif
-6.   timeout.tv_sec = 120;
-5.   timeout.tv_usec = 0;
-4.   FD_ZERO(&fds_read);
-3.   FD_ZERO(&fds_write);
-2.   FD_ZERO(&fds_err);
-1.   FD_SET((curl_socket_t)fileno(stdin), &fds_read);
  switch(*mode) {

/*switch(*mode)*/

1.   case PASSIVE_LISTEN:",Not Useful,1
/*timeout*/,"-5. };
-4. static int select_ws(int nfds, fd_set *readfds, fd_set *writefds,
-3.                      fd_set *exceptfds, struct timeval *tv)
-2. {
-1.   HANDLE abort, mutex, signal, handle, *handles;
  DWORD timeout_ms, wait, nfd, nth, nws, i;

/*timeout*/

1.   fd_set readsock, writesock, exceptsock;
2.   struct select_ws_data *data;
3.   WSANETWORKEVENTS wsaevents;
4.   curl_socket_t wsasock;
5.   int error, ret, fd;
6.   WSAEVENT wsaevent;",Not Useful,0
"/*send reply on stdout, just proving we are alive*/","-10.        4-digit hexadecimal data length + LF [if the command takes data]
-9.        data                       [the data being as long as set above]
-8.        Commands:
-7.        DATA - plain pass-through data
-6.     */
-5.     if(!read_stdin(buffer, 5))
-4.       return FALSE;
-3.     logmsg(""Received %c%c%c%c (on stdin)"",
-2.            buffer[0], buffer[1], buffer[2], buffer[3]);
-1.     if(!memcmp(""PING"", buffer, 4)) {

/*send reply on stdout, just proving we are alive*/

1.       if(!write_stdout(""PONG\n"", 5))
2.         return FALSE;
3.     }
4.     else if(!memcmp(""PORT"", buffer, 4)) {",Not Useful,1
/*just die*/,"-10.          Replies to PORT with ""IPv[num]/[port]"" */
-9.       msnprintf((char *)buffer, sizeof(buffer), ""%s/%hu\n"", ipv_inuse, port);
-8.       buffer_len = (ssize_t)strlen((char *)buffer);
-7.       msnprintf(data, sizeof(data), ""PORT\n%04zx\n"", buffer_len);
-6.       if(!write_stdout(data, 10))
-5.         return FALSE;
-4.       if(!write_stdout(buffer, buffer_len))
-3.         return FALSE;
-2.     }
-1.     else if(!memcmp(""QUIT"", buffer, 4)) {

/*just die*/

1.       logmsg(""quits"");
2.       return FALSE;
3.     }
4.     else if(!memcmp(""DATA"", buffer, 4)) {",Not Useful,0
/*store the new socket*/,"-10.       curl_socket_t newfd = accept(sockfd, NULL, NULL);
-9.       if(CURL_SOCKET_BAD == newfd) {
-8.         error = SOCKERRNO;
-7.         logmsg(""accept(%d, NULL, NULL) failed with error: (%d) %s"",
-6.                sockfd, error, strerror(error));
-5.       }
-4.       else {
-3.         logmsg(""====> Client connect"");
-2.         if(!write_stdout(""CNCT\n"", 5))
-1.           return FALSE;

/*store the new socket*/

111",Not Useful,0
/*we have connected*/,"-10.       if(CURL_SOCKET_BAD == newfd) {
-9.         error = SOCKERRNO;
-8.         logmsg(""accept(%d, NULL, NULL) failed with error: (%d) %s"",
-7.                sockfd, error, strerror(error));
-6.       }
-5.       else {
-4.         logmsg(""====> Client connect"");
-3.         if(!write_stdout(""CNCT\n"", 5))
-2.           return FALSE;

/*we have connected*/

1.       }
2.       return TRUE;
3.     }",Not Useful,1
"/*read from socket, pass on data to stdout*/","-3.       }
-2.       return TRUE;
-1.     }

/*read from socket, pass on data to stdout*/

1.     nread_socket = sread(sockfd, buffer, sizeof(buffer));
2.     if(nread_socket > 0) {
3.       msnprintf(data, sizeof(data), ""DATA\n%04zx\n"", nread_socket);
4.       if(!write_stdout(data, 10))
5.         return FALSE;
6.       if(!write_stdout(buffer, nread_socket))
7.         return FALSE;
8.       logmsg(""< %zd bytes data, client => server"", nread_socket);
9.       lograw(buffer, nread_socket);
10.     }",Not Useful,1
/*double the sleep for next attempt*/,"-10.                  error, strerror(error));
-9.           sclose(sock);
-8.           return CURL_SOCKET_BAD;
-7.         }
-6.         if(got_exit_signal) {
-5.           logmsg(""signalled to die, exiting..."");
-4.           sclose(sock);
-3.           return CURL_SOCKET_BAD;
-2.         }
-1.         totdelay += delay;

/*double the sleep for next attempt*/

1.       }
2.     }
3.   } while(rc && maxretr--);
4.   if(rc) {
5.     logmsg(""setsockopt(SO_REUSEADDR) failed %d times in %d ms. Error: (%d) %s"",
6.            attempt, totdelay, error, strerror(error));
7.     logmsg(""Continuing anyway..."");
8.   }",Not Useful,0
/*ENABLE_IPV6*/,"-8. #endif
-7. #define DEFAULT_PORT 8999
-6. #ifndef DEFAULT_LOGFILE
-5. #define DEFAULT_LOGFILE ""log/sockfilt.log""
-4. #endif
-3. const char *serverlogfile = DEFAULT_LOGFILE;
-2. static bool verbose = FALSE;
-1. static bool bind_only = FALSE;
#ifdef ENABLE_IPV6

/*ENABLE_IPV6*/

1. static bool use_ipv6 = FALSE;
2. #endif
3. static const char *ipv_inuse = ""IPv4"";
4. static unsigned short port = DEFAULT_PORT;",Not Useful,1
/*start accepting connections*/,"-4.   if(bind_only) {
-3.     logmsg(""instructed to bind port without listening"");
-2.     return sock;
-1.   }

/*start accepting connections*/

1.   rc = listen(sock, 5);
2.   if(0 != rc) {
3.     error = SOCKERRNO;
4.     logmsg(""listen(%d, 5) failed with error: (%d) %s"",
5.            sock, error, strerror(error));
6.     sclose(sock);
7.     return CURL_SOCKET_BAD;
8.   }
9.   return sock;
10. }",Not Useful,1
/*default*/,"-10.       width += 2;
-9.       optr += 2;
-8.       left -= 2;
-7.       break;
-6.     case '\r':
-5.       msnprintf(optr, left, ""\\r"");
-4.       width += 2;
-3.       optr += 2;
-2.       left -= 2;
-1.       break;
    default:

/*default*/

1.       msnprintf(optr, left, ""%c"", (ISGRAPH(ptr[i]) ||
2.                                    ptr[i] == 0x20) ?ptr[i]:'.');
3.       width++;
4.       optr++;
5.       left--;
6.       break;
7.     }
8.     if(width>60) {
9.       logmsg(""'%s'"", data);
10.       width = 0;",Not Useful,1
/*ENABLE_IPV6*/,"-8. #endif
-7. #define DEFAULT_PORT 8999
-6. #ifndef DEFAULT_LOGFILE
-5. #define DEFAULT_LOGFILE ""log/sockfilt.log""
-4. #endif
-3. const char *serverlogfile = DEFAULT_LOGFILE;
-2. static bool verbose = FALSE;
-1. static bool bind_only = FALSE;
#ifdef ENABLE_IPV6

/*ENABLE_IPV6*/

1. static bool use_ipv6 = FALSE;
2. #endif
3. static const char *ipv_inuse = ""IPv4"";
4. static unsigned short port = DEFAULT_PORT;",Not Useful,1
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

/*errno.h value*/

1. #undef  EAGAIN",Not Useful,0
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

/*errno.h value*/

1. #undef  EAGAIN",Not Useful,1
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

/*errno.h value*/

1. #undef  EAGAIN",Not Useful,1
/*previous test number we served*/,"-10.   , socket_domain_inet6 = AF_INET6
-9. #endif
-8. #ifdef USE_UNIX_SOCKETS
-7.   , socket_domain_unix = AF_UNIX
-6. #endif
-5. } socket_domain = AF_INET;
-4. static bool use_gopher = FALSE;
-3. static int serverlogslocked = 0;
-2. static bool is_proxy = FALSE;
-1. #define REQBUFSIZ (2*1024*1024)

/*previous test number we served*/

111",Not Useful,1
/*previous part number we served*/,"-10. #endif
-9. #ifdef USE_UNIX_SOCKETS
-8.   , socket_domain_unix = AF_UNIX
-7. #endif
-6. } socket_domain = AF_INET;
-5. static bool use_gopher = FALSE;
-4. static int serverlogslocked = 0;
-3. static bool is_proxy = FALSE;
-2. #define REQBUFSIZ (2*1024*1024)

/*previous part number we served*/

111",Not Useful,1
/*buffer area for the incoming request*/,"-1. struct httprequest {

/*buffer area for the incoming request*/

111",Not Useful,1
/*if a CONNECT*/,"-2. struct httprequest {

/*if a CONNECT*/

111",Not Useful,1
/*the port number CONNECT used*/,"-3. struct httprequest {

/*the port number CONNECT used*/

111",Not Useful,1
/*where to start checking of the request*/,"-4. struct httprequest {

/*where to start checking of the request*/

111",Not Useful,1
/*size of the incoming request*/,"-5. struct httprequest {

/*size of the incoming request*/

111",Not Useful,1
/*test number found in the request*/,"-6. struct httprequest {

/*test number found in the request*/

111",Not Useful,1
/*part number found in the request*/,"-7. struct httprequest {

/*part number found in the request*/

111",Not Useful,1
/*Authorization header present in the incoming request*/,"-10.   char reqbuf[REQBUFSIZ]; /* buffer area for the incoming request */
-9.   bool connect_request; /* if a CONNECT */
-8.   unsigned short connect_port; /* the port number CONNECT used */
-7.   size_t checkindex; /* where to start checking of the request */
-6.   size_t offset;     /* size of the incoming request */
-5.   long testno;       /* test number found in the request */
-4.   long partno;       /* part number found in the request */
-3.   bool open;      /* keep connection open info, as found in the request */
-2.   bool auth_req;  /* authentication required, don't wait for body unless
-1.                      there's an Authorization header */
  bool auth;      /* Authorization header present in the incoming request */

/*Authorization header present in the incoming request*/

111",Not Useful,1
/*Content-Length of the incoming request*/,"-10.   bool connect_request; /* if a CONNECT */
-9.   unsigned short connect_port; /* the port number CONNECT used */
-8.   size_t checkindex; /* where to start checking of the request */
-7.   size_t offset;     /* size of the incoming request */
-6.   long testno;       /* test number found in the request */
-5.   long partno;       /* part number found in the request */
-4.   bool open;      /* keep connection open info, as found in the request */
-3.   bool auth_req;  /* authentication required, don't wait for body unless
-2.                      there's an Authorization header */
-1.   bool auth;      /* Authorization header present in the incoming request */
  size_t cl;      /* Content-Length of the incoming request */

/*Content-Length of the incoming request*/

111",Not Useful,1
/*Authorization digest header found*/,"-10.   unsigned short connect_port; /* the port number CONNECT used */
-9.   size_t checkindex; /* where to start checking of the request */
-8.   size_t offset;     /* size of the incoming request */
-7.   long testno;       /* test number found in the request */
-6.   long partno;       /* part number found in the request */
-5.   bool open;      /* keep connection open info, as found in the request */
-4.   bool auth_req;  /* authentication required, don't wait for body unless
-3.                      there's an Authorization header */
-2.   bool auth;      /* Authorization header present in the incoming request */
-1.   size_t cl;      /* Content-Length of the incoming request */
  bool digest;    /* Authorization digest header found */

/*Authorization digest header found*/

111",Not Useful,0
/*Authorization ntlm header found*/,"-10.   size_t checkindex; /* where to start checking of the request */
-9.   size_t offset;     /* size of the incoming request */
-8.   long testno;       /* test number found in the request */
-7.   long partno;       /* part number found in the request */
-6.   bool open;      /* keep connection open info, as found in the request */
-5.   bool auth_req;  /* authentication required, don't wait for body unless
-4.                      there's an Authorization header */
-3.   bool auth;      /* Authorization header present in the incoming request */
-2.   size_t cl;      /* Content-Length of the incoming request */
-1.   bool digest;    /* Authorization digest header found */
  bool ntlm;      /* Authorization ntlm header found */

/*Authorization ntlm header found*/

111",Not Useful,1
"/*if non-zero, delay this number of seconds between
                     writes in the response*/","-10.   size_t offset;     /* size of the incoming request */
-9.   long testno;       /* test number found in the request */
-8.   long partno;       /* part number found in the request */
-7.   bool open;      /* keep connection open info, as found in the request */
-6.   bool auth_req;  /* authentication required, don't wait for body unless
-5.                      there's an Authorization header */
-4.   bool auth;      /* Authorization header present in the incoming request */
-3.   size_t cl;      /* Content-Length of the incoming request */
-2.   bool digest;    /* Authorization digest header found */
-1.   bool ntlm;      /* Authorization ntlm header found */
  int writedelay; /* if non-zero, delay this number of seconds between
                     writes in the response */

/*if non-zero, delay this number of seconds between
                     writes in the response*/

111",Not Useful,0
"/*if non-zero, the server is instructed to not read this
                     many bytes from a PUT/POST request. Ie the client sends N
                     bytes said in Content-Length, but the server only reads N
                     - skip bytes.*/","-10.   long partno;       /* part number found in the request */
-9.   bool open;      /* keep connection open info, as found in the request */
-8.   bool auth_req;  /* authentication required, don't wait for body unless
-7.                      there's an Authorization header */
-6.   bool auth;      /* Authorization header present in the incoming request */
-5.   size_t cl;      /* Content-Length of the incoming request */
-4.   bool digest;    /* Authorization digest header found */
-3.   bool ntlm;      /* Authorization ntlm header found */
-2.   int writedelay; /* if non-zero, delay this number of seconds between
-1.                      writes in the response */
  int skip;       /* if non-zero, the server is instructed to not read this
                     many bytes from a PUT/POST request. Ie the client sends N
                     bytes said in Content-Length, but the server only reads N
                     - skip bytes. */

/*if non-zero, the server is instructed to not read this
                     many bytes from a PUT/POST request. Ie the client sends N
                     bytes said in Content-Length, but the server only reads N
                     - skip bytes.*/

111",Not Useful,1
"/*doing a special command, see defines above*/","-10.   bool auth;      /* Authorization header present in the incoming request */
-9.   size_t cl;      /* Content-Length of the incoming request */
-8.   bool digest;    /* Authorization digest header found */
-7.   bool ntlm;      /* Authorization ntlm header found */
-6.   int writedelay; /* if non-zero, delay this number of seconds between
-5.                      writes in the response */
-4.   int skip;       /* if non-zero, the server is instructed to not read this
-3.                      many bytes from a PUT/POST request. Ie the client sends N
-2.                      bytes said in Content-Length, but the server only reads N
-1.                      - skip bytes. */
  int rcmd;       /* doing a special command, see defines above */

/*doing a special command, see defines above*/

111",Not Useful,1
/*times ProcessRequest() gets called*/,"-10.   bool digest;    /* Authorization digest header found */
-9.   bool ntlm;      /* Authorization ntlm header found */
-8.   int writedelay; /* if non-zero, delay this number of seconds between
-7.                      writes in the response */
-6.   int skip;       /* if non-zero, the server is instructed to not read this
-5.                      many bytes from a PUT/POST request. Ie the client sends N
-4.                      bytes said in Content-Length, but the server only reads N
-3.                      - skip bytes. */
-2.   int rcmd;       /* doing a special command, see defines above */
-1.   int prot_version;  /* HTTP version * 10 */
  int callcount;  /* times ProcessRequest() gets called */

/*times ProcessRequest() gets called*/

111",Not Useful,1
/*upgrade request found and allowed*/,"-10.                      many bytes from a PUT/POST request. Ie the client sends N
-9.                      bytes said in Content-Length, but the server only reads N
-8.                      - skip bytes. */

/*upgrade request found and allowed*/

111",Not Useful,1
"/*similar to swsclose in response: close connection after
                     response is sent*/","-10.                      bytes said in Content-Length, but the server only reads N
-9.                      - skip bytes. */

/*similar to swsclose in response: close connection after
                     response is sent*/

1.   int done_processing;
2. };
3. #define MAX_SOCKETS 1024
4. static curl_socket_t all_sockets[MAX_SOCKETS];
5. static size_t num_sockets = 0;
6. static int ProcessRequest(struct httprequest *req);
7. static void storerequest(const char *reqbuf, size_t totalsize);
8. #define DEFAULT_PORT 8999
9. #ifndef DEFAULT_LOGFILE
10. #define DEFAULT_LOGFILE ""log/sws.log""",Not Useful,0
/*very-big-path support*/,"-2. #define DEFAULT_CMDFILE ""log/ftpserver.cmd""
-1. const char *cmdfile = DEFAULT_CMDFILE;

/*very-big-path support*/

1. #define MAXDOCNAMELEN 140000
2. #define MAXDOCNAMELEN_TXT ""139999""
3. #define REQUEST_KEYWORD_SIZE 256
4. #define REQUEST_KEYWORD_SIZE_TXT ""255""
5. #define CMD_AUTH_REQUIRED ""auth_required""",Not Useful,1
/*close connection*/,"-10.                      bytes said in Content-Length, but the server only reads N
-9.                      - skip bytes. */

/*close connection*/

1.                      response is sent */
2.   int done_processing;
3. };
4. #define MAX_SOCKETS 1024
5. static curl_socket_t all_sockets[MAX_SOCKETS];
6. static size_t num_sockets = 0;
7. static int ProcessRequest(struct httprequest *req);
8. static void storerequest(const char *reqbuf, size_t totalsize);
9. #define DEFAULT_PORT 8999
10. #ifndef DEFAULT_LOGFILE",Not Useful,1
"/*IETF//DTD HTML 2.0//EN\"">\n""*/","-5. static const char *doc404 = ""HTTP/1.1 404 Not Found\r\n""
-4.     ""Server: "" SWSVERSION ""\r\n""
-3.     ""Connection: close\r\n""
-2.     ""Content-Type: text/html""
-1.     END_OF_HEADERS

/*IETF//DTD HTML 2.0//EN\"">\n""*/

1.     ""<HTML><HEAD>\n""
2.     ""<TITLE>404 Not Found</TITLE>\n""
3.     ""</HEAD><BODY>\n""
4.     ""<H1>Not Found</H1>\n""
5.     ""The requested URL was not found on this server.\n""
6.     ""<P><HR><ADDRESS>"" SWSVERSION ""</ADDRESS>\n"" ""</BODY></HTML>\n"";",Not Useful,1
/*returns true if the current socket is an IP one*/,"-1. static int already_recv_zeroed_chunk = FALSE;

/*returns true if the current socket is an IP one*/

1. static bool socket_domain_is_ip(void)
2. {
3.   switch(socket_domain) {
4.   case AF_INET:
5. #ifdef ENABLE_IPV6
6.   case AF_INET6:
7. #endif
8.     return true;
9.   default:",Not Useful,1
/*case AF_UNIX:*/,"-9. static bool socket_domain_is_ip(void)
-8. {
-7.   switch(socket_domain) {
-6.   case AF_INET:
-5. #ifdef ENABLE_IPV6
-4.   case AF_INET6:
-3. #endif
-2.     return true;
-1.   default:

/*case AF_UNIX:*/

1.     return false;
2.   }
3. }",Not Useful,1
"/*based on the testno, parse the correct server commands*/","-10.     while(fgets(buf, sizeof(buf), f)) {
-9.       if(1 == sscanf(buf, ""Testnum %d"", &testnum)) {
-8.         logmsg(""[%s] cmdfile says testnum %d"", cmdfile, testnum);
-7.         req->testno = testnum;
-6.       }
-5.     }
-4.     fclose(f);
-3.   }
-2.   return 0;
-1. }

/*based on the testno, parse the correct server commands*/

1. static int parse_servercmd(struct httprequest *req)
2. {
3.   FILE *stream;
4.   int error;
5.   stream = test2fopen(req->testno);
6.   req->close = FALSE;
7.   req->connmon = FALSE;
8.   if(!stream) {
9.     error = errno;
10.     logmsg(""fopen() failed with error: %d %s"", error, strerror(error));",Not Useful,1
/*closes connection*/,"-10. {
-9.   FILE *stream;
-8.   int error;
-7.   stream = test2fopen(req->testno);
-6.   req->close = FALSE;
-5.   req->connmon = FALSE;
-4.   if(!stream) {
-3.     error = errno;
-2.     logmsg(""fopen() failed with error: %d %s"", error, strerror(error));
-1.     logmsg(""  Couldn't open test file %ld"", req->testno);

/*closes connection*/

111",Not Useful,1
/*closes connection*/,"-10. {
-9.   FILE *stream;
-8.   int error;
-7.   stream = test2fopen(req->testno);
-6.   req->close = FALSE;
-5.   req->connmon = FALSE;
-4.   if(!stream) {
-3.     error = errno;
-2.     logmsg(""fopen() failed with error: %d %s"", error, strerror(error));
-1.     logmsg(""  Couldn't open test file %ld"", req->testno);

/*closes connection*/

111",Not Useful,1
/*try to deal with CRLF or just LF*/,"-10.         logmsg(""instructed to reject Expect: 100-continue"");
-9.         req->noexpect = TRUE;
-8.       }
-7.       else if(1 == sscanf(cmd, ""writedelay: %d"", &num)) {
-6.         logmsg(""instructed to delay %d secs between packets"", num);
-5.         req->writedelay = num;
-4.       }
-3.       else {
-2.         logmsg(""Unknown <servercmd> instruction found: %s"", cmd);
-1.       }

/*try to deal with CRLF or just LF*/

1.       check = strchr(cmd, '\r');
2.       if(!check)
3.         check = strchr(cmd, '\n');
4.       if(check) {",Not Useful,1
/*get to the letter following the newline*/,"-4.       check = strchr(cmd, '\r');
-3.       if(!check)
-2.         check = strchr(cmd, '\n');
-1.       if(check) {

/*get to the letter following the newline*/

1.         while((*check == '\r') || (*check == '\n'))
2.           check++;
3.         if(!*check)",Not Useful,1
"/*if we reached a zero, get out*/","-3.         while((*check == '\r') || (*check == '\n'))
-2.           check++;
-1.         if(!*check)

/*if we reached a zero, get out*/

1.           break;
2.         cmd = check;
3.       }
4.       else
5.         break;
6.     }
7.     free(orgcmd);
8.   }",Not Useful,1
/*find the last slash*/,"-10.   }
-9.   else if((req->testno == DOCNUMBER_NOTHING) &&
-8.      sscanf(line,
-7.             ""%"" REQUEST_KEYWORD_SIZE_TXT""s %"" MAXDOCNAMELEN_TXT ""s HTTP/%d.%d"",
-6.             request,
-5.             doc,
-4.             &prot_major,
-3.             &prot_minor) == 4) {
-2.     char *ptr;
-1.     req->prot_version = prot_major*10 + prot_minor;

/*find the last slash*/

1.     ptr = strrchr(doc, '/');",Not Useful,1
/*get the number after it*/,"-1.     ptr = strrchr(doc, '/');

/*get the number after it*/

1.     if(ptr) {
2.       if((strlen(doc) + strlen(request)) < 400)
3.         msnprintf(logbuf, sizeof(logbuf), ""Got request: %s %s HTTP/%d.%d"",
4.                   request, doc, prot_major, prot_minor);
5.       else
6.         msnprintf(logbuf, sizeof(logbuf), ""Got a *HUGE* request HTTP/%d.%d"",
7.                   prot_major, prot_minor);
8.       logmsg(""%s"", logbuf);
9.       if(!strncmp(""/verifiedserver"", ptr, 15)) {
10.         logmsg(""Are-we-friendly question received"");",Not Useful,1
/*skip the slash*/,"-1.       }

/*skip the slash*/

111",Not Useful,1
/*find the last dot*/,"-10.             req->connect_port = curlx_ultous(ulnum);
-9.         }
-8.         logmsg(""Port number: %d, test case number: %ld"",
-7.                req->connect_port, req->testno);
-6.       }
-5.     }
-4.     if(req->testno == DOCNUMBER_NOTHING) {

/*find the last dot*/

1.       ptr = strrchr(doc, '.');",Not Useful,1
/*skip the dot*/,"-2.       if(ptr) {
-1.         long num;

/*skip the dot*/

1.         num = strtol(ptr, &ptr, 10);
2.         if(num) {
3.           req->testno = num;
4.           if(req->testno > 10000) {
5.             req->partno = req->testno % 10000;
6.             req->testno /= 10000;
7.             logmsg(""found test %d in requested host name"", req->testno);
8.           }
9.           else
10.             req->partno = 0;",Not Useful,1
/*not complete yet*/,"
    logmsg(""request not complete yet"");



/*not complete yet*/

111",Not Useful,1
/*find the last slash in the line*/,"-1.     char *ptr;

/*find the last slash in the line*/

1.     ptr = strrchr(line, '/');
2.     if(ptr) {",Not Useful,1
/*skip the slash*/,"-1.       }

/*skip the slash*/

111",Not Useful,1
/*closes connection*/,"-10. {
-9.   FILE *stream;
-8.   int error;
-7.   stream = test2fopen(req->testno);
-6.   req->close = FALSE;
-5.   req->connmon = FALSE;
-4.   if(!stream) {
-3.     error = errno;
-2.     logmsg(""fopen() failed with error: %d %s"", error, strerror(error));
-1.     logmsg(""  Couldn't open test file %ld"", req->testno);

/*closes connection*/

111",Not Useful,0
/*header found*/,"-10.   unsigned short connect_port; /* the port number CONNECT used */
-9.   size_t checkindex; /* where to start checking of the request */
-8.   size_t offset;     /* size of the incoming request */
-7.   long testno;       /* test number found in the request */
-6.   long partno;       /* part number found in the request */
-5.   bool open;      /* keep connection open info, as found in the request */
-4.   bool auth_req;  /* authentication required, don't wait for body unless
-3.                      there's an Authorization header */
-2.   bool auth;      /* Authorization header present in the incoming request */
-1.   size_t cl;      /* Content-Length of the incoming request */
  bool digest;    /* Authorization digest header found */

/*header found*/

111",Not Useful,1
/*NTLM found*/,"-1.     req->partno += 1002;

/*NTLM found*/

1.     logmsg(""Received NTLM type-3, sending back data %ld"", req->partno);
2.     if(req->cl) {
3.       logmsg(""  Expecting %zu POSTed bytes"", req->cl);
4.     }
5.   }
6.   else if(!req->ntlm &&
7.           strstr(req->reqbuf, ""Authorization: NTLM TlRMTVNTUAAB"")) {",Not Useful,1
/*NTLM found*/,"-1.     req->partno += 1002;

/*NTLM found*/

1.     logmsg(""Received NTLM type-3, sending back data %ld"", req->partno);
2.     if(req->cl) {
3.       logmsg(""  Expecting %zu POSTed bytes"", req->cl);
4.     }
5.   }
6.   else if(!req->ntlm &&
7.           strstr(req->reqbuf, ""Authorization: NTLM TlRMTVNTUAAB"")) {",Not Useful,1
/*we allow upgrade and there was one!*/,"-2.   }
-1.   if(req->upgrade && strstr(req->reqbuf, ""Upgrade:"")) {

/*we allow upgrade and there was one!*/

1.     logmsg(""Found Upgrade: in request and allows it"");
2.     req->upgrade_request = TRUE;
3.   }
4.   if(req->cl > 0) {
5.     if(req->cl <= req->offset - (end - req->reqbuf) - strlen(end_of_headers))",Not Useful,0
/*continue with business as usual*/,"-10.   bool persistent = TRUE;
-9.   bool sendfailure = FALSE;
-8.   size_t responsesize;
-7.   int error = 0;
-6.   int res;
-5.   const char *responsedump = is_proxy?RESPONSE_PROXY_DUMP:RESPONSE_DUMP;
-4.   static char weare[256];
-3.   switch(req->rcmd) {
-2.   default:
-1.   case RCMD_NORMALREQ:

/*continue with business as usual*/

1.   case RCMD_STREAM:
2. #define STREAMTHIS ""a string to stream 01234567890\n""
3.     count = strlen(STREAMTHIS);
4.     for(;;) {
5.       written = swrite(sock, STREAMTHIS, count);
6.       if(got_exit_signal)
7.         return -1;
8.       if(written != (ssize_t)count) {
9.         logmsg(""Stopped streaming"");
10.         break;",Not Useful,1
/*Do nothing. Sit idle. Pretend it rains.*/,"-10.       written = swrite(sock, STREAMTHIS, count);
-9.       if(got_exit_signal)
-8.         return -1;
-7.       if(written != (ssize_t)count) {
-6.         logmsg(""Stopped streaming"");
-5.         break;
-4.       }
-3.     }
-2.     return -1;
-1.   case RCMD_IDLE:

/*Do nothing. Sit idle. Pretend it rains.*/

1.     return 0;
2.   }
3.   req->open = FALSE;
4.   if(req->testno < 0) {
5.     size_t msglen;
6.     char msgbuf[64];
7.     switch(req->testno) {
8.     case DOCNUMBER_QUIT:
9.       logmsg(""Replying to QUIT"");
10.       buffer = docquit;",Not Useful,0
/*write to file as well*/,"-10.     retry:
-9.     written = swrite(sock, buffer, num);
-8.     if(written < 0) {
-7.       if((EWOULDBLOCK == SOCKERRNO) || (EAGAIN == SOCKERRNO)) {
-6.         wait_ms(10);
-5.         goto retry;
-4.       }
-3.       sendfailure = TRUE;
-2.       break;
-1.     }

/*write to file as well*/

1.     fwrite(buffer, 1, (size_t)written, dump);
2.     count -= written;
3.     buffer += written;
4.     if(req->writedelay) {
5.       int quarters = req->writedelay * 4;
6.       logmsg(""Pausing %d seconds"", req->writedelay);
7.       while((quarters > 0) && !got_exit_signal) {
8.         quarters--;
9.         wait_ms(250);
10.       }",Not Useful,1
/*USE_UNIX_SOCKETS*/,"-6. #endif
-5. static enum {
-4.   socket_domain_inet = AF_INET
-3. #ifdef ENABLE_IPV6
-2.   , socket_domain_inet6 = AF_INET6
-1. #endif
#ifdef USE_UNIX_SOCKETS

/*USE_UNIX_SOCKETS*/

1.   , socket_domain_unix = AF_UNIX
2. #endif
3. } socket_domain = AF_INET;
4. static bool use_gopher = FALSE;
5. static int serverlogslocked = 0;
6. static bool is_proxy = FALSE;
7. #define REQBUFSIZ (2*1024*1024)",Not Useful,0
/*number of bytes to client*/,"-10. #define data_or_ctrl(x) ((x)?""DATA"":""CTRL"")
-9. #define CTRL  0
-8. #define DATA  1
-7. static void http_connect(curl_socket_t *infdp,
-6.                          curl_socket_t rootfd,
-5.                          const char *ipaddr,
-4.                          unsigned short ipport)
-3. {
-2.   curl_socket_t serverfd[2] = {CURL_SOCKET_BAD, CURL_SOCKET_BAD};
-1.   curl_socket_t clientfd[2] = {CURL_SOCKET_BAD, CURL_SOCKET_BAD};

/*number of bytes to client*/

111",Not Useful,1
/*number of bytes to server*/,"-10. #define CTRL  0
-9. #define DATA  1
-8. static void http_connect(curl_socket_t *infdp,
-7.                          curl_socket_t rootfd,
-6.                          const char *ipaddr,
-5.                          unsigned short ipport)
-4. {
-3.   curl_socket_t serverfd[2] = {CURL_SOCKET_BAD, CURL_SOCKET_BAD};
-2.   curl_socket_t clientfd[2] = {CURL_SOCKET_BAD, CURL_SOCKET_BAD};

/*number of bytes to server*/

1.   char readclient[2][256];
2.   char readserver[2][256];
3.   bool poll_client_rd[2] = { TRUE, TRUE };
4.   bool poll_server_rd[2] = { TRUE, TRUE };
5.   bool poll_client_wr[2] = { TRUE, TRUE };
6.   bool poll_server_wr[2] = { TRUE, TRUE };
7.   bool primary = FALSE;
8.   bool secondary = FALSE;",Not Useful,1
/*1000 ms*/,"-5.   max_tunnel_idx = CTRL;
-4.   primary = TRUE;
-3.   while(!got_exit_signal) {
-2.     fd_set input;
-1.     fd_set output;

/*1000 ms*/

1.     ssize_t rc;
2.     curl_socket_t maxfd = (curl_socket_t)-1;
3.     FD_ZERO(&input);
4.     FD_ZERO(&output);
5.     if((clientfd[DATA] == CURL_SOCKET_BAD) &&
6.        (serverfd[DATA] == CURL_SOCKET_BAD) &&
7.        poll_client_rd[CTRL] && poll_client_wr[CTRL] &&
8.        poll_server_rd[CTRL] && poll_server_wr[CTRL]) {
9.       /* listener socket is monitored to allow client to establish
10.          secondary tunnel only when this tunnel is not established",Not Useful,0
/*----------------------------------------------------------*/,"-2.       bool tcp_fin_wr = FALSE;
-1.       timeout_count = 0;

/*----------------------------------------------------------*/

111",Not Useful,1
/*----------------------------------------------------------*/,"-2.       bool tcp_fin_wr = FALSE;
-1.       timeout_count = 0;

/*----------------------------------------------------------*/

111",Not Useful,1
/*read from client*/,"-5.       for(i = 0; i <= max_tunnel_idx; i++) {
-4.         size_t len;
-3.         if(clientfd[i] != CURL_SOCKET_BAD) {
-2.           len = sizeof(readclient[i]) - tos[i];
-1.           if(len && FD_ISSET(clientfd[i], &input)) {

/*read from client*/

1.             rc = sread(clientfd[i], &readclient[i][tos[i]], len);
2.             if(rc <= 0) {
3.               logmsg(""[%s] got %zd, STOP READING client"", data_or_ctrl(i), rc);
4.               shutdown(clientfd[i], SHUT_RD);
5.               poll_client_rd[i] = FALSE;
6.             }
7.             else {
8.               logmsg(""[%s] READ %zd bytes from client"", data_or_ctrl(i), rc);
9.               logmsg(""[%s] READ \""%s\"""", data_or_ctrl(i),
10.                      data_to_hex(&readclient[i][tos[i]], rc));",Not Useful,1
/*read from server*/,"-10.               logmsg(""[%s] READ %zd bytes from client"", data_or_ctrl(i), rc);
-9.               logmsg(""[%s] READ \""%s\"""", data_or_ctrl(i),
-8.                      data_to_hex(&readclient[i][tos[i]], rc));
-7.               tos[i] += rc;
-6.             }
-5.           }
-4.         }
-3.         if(serverfd[i] != CURL_SOCKET_BAD) {
-2.           len = sizeof(readserver[i])-toc[i];
-1.           if(len && FD_ISSET(serverfd[i], &input)) {

/*read from server*/

1.             rc = sread(serverfd[i], &readserver[i][toc[i]], len);
2.             if(rc <= 0) {
3.               logmsg(""[%s] got %zd, STOP READING server"", data_or_ctrl(i), rc);
4.               shutdown(serverfd[i], SHUT_RD);
5.               poll_server_rd[i] = FALSE;
6.             }
7.             else {
8.               logmsg(""[%s] READ %zd bytes from server"", data_or_ctrl(i), rc);
9.               logmsg(""[%s] READ \""%s\"""", data_or_ctrl(i),
10.                      data_to_hex(&readserver[i][toc[i]], rc));",Not Useful,1
/*write to client*/,"-10.             else {
-9.               logmsg(""[%s] READ %zd bytes from server"", data_or_ctrl(i), rc);
-8.               logmsg(""[%s] READ \""%s\"""", data_or_ctrl(i),
-7.                      data_to_hex(&readserver[i][toc[i]], rc));
-6.               toc[i] += rc;
-5.             }
-4.           }
-3.         }
-2.         if(clientfd[i] != CURL_SOCKET_BAD) {
-1.           if(toc[i] && FD_ISSET(clientfd[i], &output)) {

/*write to client*/

1.             rc = swrite(clientfd[i], readserver[i], toc[i]);
2.             if(rc <= 0) {
3.               logmsg(""[%s] got %zd, STOP WRITING client"", data_or_ctrl(i), rc);
4.               shutdown(clientfd[i], SHUT_WR);
5.               poll_client_wr[i] = FALSE;
6.               tcp_fin_wr = TRUE;
7.             }
8.             else {
9.               logmsg(""[%s] SENT %zd bytes to client"", data_or_ctrl(i), rc);
10.               logmsg(""[%s] SENT \""%s\"""", data_or_ctrl(i),",Not Useful,1
/*write to server*/,"-10.               logmsg(""[%s] SENT \""%s\"""", data_or_ctrl(i),
-9.                      data_to_hex(readserver[i], rc));
-8.               if(toc[i] - rc)
-7.                 memmove(&readserver[i][0], &readserver[i][rc], toc[i]-rc);
-6.               toc[i] -= rc;
-5.             }
-4.           }
-3.         }
-2.         if(serverfd[i] != CURL_SOCKET_BAD) {
-1.           if(tos[i] && FD_ISSET(serverfd[i], &output)) {

/*write to server*/

1.             rc = swrite(serverfd[i], readclient[i], tos[i]);
2.             if(rc <= 0) {
3.               logmsg(""[%s] got %zd, STOP WRITING server"", data_or_ctrl(i), rc);
4.               shutdown(serverfd[i], SHUT_WR);
5.               poll_server_wr[i] = FALSE;
6.               tcp_fin_wr = TRUE;
7.             }
8.             else {
9.               logmsg(""[%s] SENT %zd bytes to server"", data_or_ctrl(i), rc);
10.               logmsg(""[%s] SENT \""%s\"""", data_or_ctrl(i),",Not Useful,1
/*----------------------------------------------------------*/,"-2.       bool tcp_fin_wr = FALSE;
-1.       timeout_count = 0;

/*----------------------------------------------------------*/

111",Not Useful,1
/*----------------------------------------------------------*/,"-2.       bool tcp_fin_wr = FALSE;
-1.       timeout_count = 0;

/*----------------------------------------------------------*/

111",Not Useful,1
/*(rc > 0)*/,"-10.         }
-9.       }
-8.     }
-7.     if(got_exit_signal)
-6.       break;
-5.     do {
-4.       rc = select((int)maxfd + 1, &input, &output, NULL, &timeout);
-3.     } while(rc < 0 && errno == EINTR && !got_exit_signal);
-2.     if(got_exit_signal)
-1.       break;
    if(rc > 0) {

/*(rc > 0)*/

111",Not Useful,1
/*left to implement*/,"-10.        (clientfd[i] != CURL_SOCKET_BAD)) {
-9.       logmsg(""[%s] ABORTING"", data_or_ctrl(i));
-8.     }
-7.   }
-6.   *infdp = CURL_SOCKET_BAD;
-5. }
-4. static void http2(struct httprequest *req)
-3. {
-2.   (void)req;
-1.   logmsg(""switched to http2"");

/*left to implement*/

1. }",Not Useful,0
/*nothing to accept*/,"-10.   }
-9.   msgsock = accept(sock, NULL, NULL);
-8.   if(got_exit_signal) {
-7.     if(CURL_SOCKET_BAD != msgsock)
-6.       sclose(msgsock);
-5.     return CURL_SOCKET_BAD;
-4.   }
-3.   if(CURL_SOCKET_BAD == msgsock) {
-2.     error = SOCKERRNO;
-1.     if(EAGAIN == error || EWOULDBLOCK == error) {

/*nothing to accept*/

1.       return 0;
2.     }
3.     logmsg(""MAJOR ERROR: accept() failed with error: (%d) %s"",
4.            error, strerror(error));
5.     return CURL_SOCKET_BAD;
6.   }
7.   if(0 != curlx_nonblock(msgsock, TRUE)) {
8.     error = SOCKERRNO;
9.     logmsg(""curlx_nonblock failed with error: (%d) %s"",
10.            error, strerror(error));",Not Useful,0
/*bounce treatment requested*/,"-4.       return rc;
-3.     }
-2.   }
-1.   if(prevbounce) {

/*bounce treatment requested*/

1.     if((req->testno == prevtestno) &&
2.        (req->partno == prevpartno)) {
3.       req->partno++;
4.       logmsg(""BOUNCE part number to %ld"", req->partno);
5.     }
6.     else {
7.       prevbounce = FALSE;
8.       prevtestno = -1;
9.       prevpartno = -1;
10.     }",Not Useful,0
"/*an upgrade request, switch to http2 here*/","-10.     if(!is_proxy) {
-9.       logmsg(""received CONNECT but isn't running as proxy!"");
-8.       return 1;
-7.     }
-6.     else {
-5.       http_connect(&msgsock, listensock, connecthost, req->connect_port);
-4.       return -1;
-3.     }
-2.   }
-1.   if(req->upgrade_request) {

/*an upgrade request, switch to http2 here*/

1.     http2(req);
2.     return -1;
3.   }",Not Useful,0
/*a default CONNECT port is basically pointless but still ...*/,"-10.   const char *pidname = "".http.pid"";
-9.   const char *portname = "".http.port"";
-8.   struct httprequest *req = NULL;
-7.   int rc = 0;
-6.   int error;
-5.   int arg = 1;
-4.   const char *connecthost = ""127.0.0.1"";
-3.   const char *socket_type = ""IPv4"";
-2.   char port_str[11];
-1.   const char *location_str = port_str;

/*a default CONNECT port is basically pointless but still ...*/

1.   size_t socket_idx;
2.   while(argc>arg) {
3.     if(!strcmp(""--version"", argv[arg])) {
4.       puts(""sws IPv4""
5. #ifdef ENABLE_IPV6
6.              ""/IPv6""
7. #endif
8. #ifdef USE_UNIX_SOCKETS
9.              ""/unix""
10. #endif",Not Useful,1
/*gopher style is much simpler*/,"-10.         serverlogfile = argv[arg++];
-9.     }
-8.     else if(!strcmp(""--cmdfile"", argv[arg])) {
-7.       arg++;
-6.       if(argc>arg)
-5.         cmdfile = argv[arg++];
-4.     }
-3.     else if(!strcmp(""--gopher"", argv[arg])) {
-2.       arg++;
-1.       use_gopher = TRUE;

/*gopher style is much simpler*/

1.     }
2.     else if(!strcmp(""--ipv4"", argv[arg])) {
3.       socket_type = ""IPv4"";
4.       socket_domain = AF_INET;
5.       location_str = port_str;
6.       arg++;
7.     }
8.     else if(!strcmp(""--ipv6"", argv[arg])) {
9. #ifdef ENABLE_IPV6
10.       socket_type = ""IPv6"";",Not Useful,1
"/*listen succeeds, so let's assume a valid listening Unix socket*/","-8.   rc = listen(sock, 5);
-7.   if(0 != rc) {
-6.     error = SOCKERRNO;
-5.     logmsg(""listen() failed with error: (%d) %s"",
-4.            error, strerror(error));
-3.     goto sws_cleanup;
-2.   }
-1. #ifdef USE_UNIX_SOCKETS

/*listen succeeds, so let's assume a valid listening Unix socket*/

1.   unlink_socket = true;
2. #endif",Not Useful,1
/*250 ms*/,"-4.   init_httprequest(req);
-3.   for(;;) {
-2.     fd_set input;
-1.     fd_set output;

/*250 ms*/

1.     curl_socket_t maxfd = (curl_socket_t)-1;
2.     int active;",Not Useful,0
/*Listen on all sockets*/,"-3.     FD_ZERO(&input);
-2.     FD_ZERO(&output);
-1.     for(socket_idx = 0; socket_idx < num_sockets; ++socket_idx) {

/*Listen on all sockets*/

1.       FD_SET(all_sockets[socket_idx], &input);
2.       if(all_sockets[socket_idx] > maxfd)
3.         maxfd = all_sockets[socket_idx];
4.     }
5.     if(got_exit_signal)
6.       goto sws_cleanup;
7.     do {
8.       rc = select((int)maxfd + 1, &input, &output, NULL, &timeout);
9.     } while(rc < 0 && errno == EINTR && !got_exit_signal);
10.     if(got_exit_signal)",Not Useful,1
/*Timed out - try again*/,"-10.     } while(rc < 0 && errno == EINTR && !got_exit_signal);
-9.     if(got_exit_signal)
-8.       goto sws_cleanup;
-7.     if(rc < 0) {
-6.       error = SOCKERRNO;
-5.       logmsg(""select() failed with error: (%d) %s"",
-4.              error, strerror(error));
-3.       goto sws_cleanup;
-2.     }
-1.     if(rc == 0) {

/*Timed out - try again*/

1.       continue;
2.     }",Not Useful,1
"/*When instructed to close connection after server-reply we
                 wait a very small amount of time before doing so. If this
                 is not done client might get an ECONNRESET before reading
                 a single byte of server-reply.*/","-10.                                   connecthost);
-9.           if(got_exit_signal)
-8.             goto sws_cleanup;
-7.           if(rc < 0) {
-6.             logmsg(""====> Client disconnect %d"", req->connmon);
-5.             if(req->connmon) {
-4.               const char *keepopen = ""[DISCONNECT]\n"";
-3.               storerequest(keepopen, strlen(keepopen));
-2.             }
-1.             if(!req->open)

/*When instructed to close connection after server-reply we
                 wait a very small amount of time before doing so. If this
                 is not done client might get an ECONNRESET before reading
                 a single byte of server-reply.*/

1.               wait_ms(50);
2.             if(all_sockets[socket_idx] != CURL_SOCKET_BAD) {
3.               sclose(all_sockets[socket_idx]);
4.               all_sockets[socket_idx] = CURL_SOCKET_BAD;
5.             }
6.             serverlogslocked -= 1;
7.             if(!serverlogslocked)
8.               clear_advisor_read_lock(SERVERLOGS_LOCK);
9.             if(req->testno == DOCNUMBER_QUIT)
10.               goto sws_cleanup;",Not Useful,1
/*copy one single byte*/,"-10. static size_t read_callback(char *ptr, size_t size, size_t nmemb, void *userp)
-9. {
-8.   struct WriteThis *pooh = (struct WriteThis *)userp;
-7.   int eof = !*pooh->readptr;
-6.   if(size*nmemb < 1)
-5.     return 0;
-4.   eof = pooh->sizeleft <= 0;
-3.   if(!eof)
-2.     pooh->sizeleft--;
-1.   if(!eof) {

/*copy one single byte*/

111",Not Useful,1
/*advance pointer*/,"-10. {
-9.   struct WriteThis *pooh = (struct WriteThis *)userp;
-8.   int eof = !*pooh->readptr;
-7.   if(size*nmemb < 1)
-6.     return 0;
-5.   eof = pooh->sizeleft <= 0;
-4.   if(!eof)
-3.     pooh->sizeleft--;
-2.   if(!eof) {

/*advance pointer*/

111",Not Useful,0
"/*Now free the mime structure: it should unbind it from the first
     easy handle.*/","-6.   easy2 = curl_easy_duphandle(easy);
-5.   if(!easy2) {
-4.     fprintf(stderr, ""curl_easy_duphandle() failed\n"");
-3.     res = TEST_ERR_FAILURE;
-2.     goto test_cleanup;
-1.   }

/*Now free the mime structure: it should unbind it from the first
     easy handle.*/

1.   curl_mime_free(mime);",Not Useful,1
/*Already cleaned up.*/,"-1.   curl_mime_free(mime);

/*Already cleaned up.*/

111",Not Useful,0
"/*Free the duplicated handle: it should call free_callback again.
     If the mime copy was bad or not automatically released, valgrind
     will signal it.*/","-6.   result = curl_easy_perform(easy2);
-5.   if(result) {
-4.     fprintf(stderr, ""curl_easy_perform(duplicated) failed\n"");
-3.     res = (int) result;
-2.     goto test_cleanup;
-1.   }

/*Free the duplicated handle: it should call free_callback again.
     If the mime copy was bad or not automatically released, valgrind
     will signal it.*/

1.   curl_easy_cleanup(easy2);",Not Useful,1
/*Already cleaned up.*/,"-1.   curl_mime_free(mime);

/*Already cleaned up.*/

111",Not Useful,0
/*Test CURLINFO_SCHEME*/,"-10.  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
-9.  * copies of the Software, and permit persons to whom the Software is
-8.  * furnished to do so, under the terms of the COPYING file.
-7.  *
-6.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-5.  * KIND, either express or implied.
-4.  *
-3.  ***************************************************************************/
-2. #include ""test.h""
-1. #include ""memdebug.h""

/*Test CURLINFO_SCHEME*/

1. int test(char *URL)
2. {
3.   CURL *curl, *dupe = NULL;
4.   char *scheme;
5.   int res = CURLE_OK;
6.   global_init(CURL_GLOBAL_ALL);
7.   easy_init(curl);",Not Useful,1
/*number of sockets actually stored in array*/,"-10.  ***************************************************************************/
-9. #include ""test.h""
-8. #include <fcntl.h>
-7. #include ""testutil.h""
-6. #include ""warnless.h""
-5. #include ""memdebug.h""
-4. #define TEST_HANG_TIMEOUT 60 * 1000
-3. struct Sockets
-2. {
-1.   curl_socket_t *sockets;

/*number of sockets actually stored in array*/

111",Not Useful,1
/*max number of sockets that fit in allocated array*/,"-10. #include ""test.h""
-9. #include <fcntl.h>
-8. #include ""testutil.h""
-7. #include ""warnless.h""
-6. #include ""memdebug.h""
-5. #define TEST_HANG_TIMEOUT 60 * 1000
-4. struct Sockets
-3. {
-2.   curl_socket_t *sockets;

/*max number of sockets that fit in allocated array*/

1. };
2. struct ReadWriteSockets
3. {
4.   struct Sockets read, write;
5. };",Not Useful,1
/*cleanup in test_cleanup*/,"-10.     sockets->sockets = malloc(sizeof(curl_socket_t) * 20U);
-9.     if(!sockets->sockets)
-8.       return;
-7.     sockets->max_count = 20;
-6.   }
-5.   else if(sockets->count + 1 > sockets->max_count) {
-4.     curl_socket_t *oldptr = sockets->sockets;
-3.     sockets->sockets = realloc(oldptr, sizeof(curl_socket_t) *
-2.                                (sockets->max_count + 20));
-1.     if(!sockets->sockets) {

/*cleanup in test_cleanup*/

1.       sockets->sockets = oldptr;
2.       return;
3.     }
4.     sockets->max_count += 20;
5.   }",Not Useful,1
/*unused*/,"-4. static int curlSocketCallback(CURL *easy, curl_socket_t s, int action,
-3.                               void *userp, void *socketp)
-2. {
-1.   struct ReadWriteSockets *sockets = userp;

/*unused*/

111",Not Useful,1
/*unused*/,"-4. static int curlSocketCallback(CURL *easy, curl_socket_t s, int action,
-3.                               void *userp, void *socketp)
-2. {
-1.   struct ReadWriteSockets *sockets = userp;

/*unused*/

111",Not Useful,1
/*unused*/,"-4. static int curlSocketCallback(CURL *easy, curl_socket_t s, int action,
-3.                               void *userp, void *socketp)
-2. {
-1.   struct ReadWriteSockets *sockets = userp;

/*unused*/

111",Not Useful,0
/*get the file size of the local file*/,"-10.     fprintf(stderr, ""Usage: lib582 [url] [filename] [username]\n"");
-9.     return TEST_ERR_USAGE;
-8.   }
-7.   hd_src = fopen(libtest_arg2, ""rb"");
-6.   if(!hd_src) {
-5.     fprintf(stderr, ""fopen() failed with error: %d (%s)\n"",
-4.             errno, strerror(errno));
-3.     fprintf(stderr, ""Error opening file: (%s)\n"", libtest_arg2);
-2.     return TEST_ERR_FOPEN;
-1.   }

/*get the file size of the local file*/

1.   hd = fstat(fileno(hd_src), &file_info);
2.   if(hd == -1) {",Not Useful,0
/*enable uploading*/,"-10.     fclose(hd_src);
-9.     return TEST_ERR_FSTAT;
-8.   }
-7.   fprintf(stderr, ""Set to upload %d bytes\n"", (int)file_info.st_size);
-6.   res_global_init(CURL_GLOBAL_ALL);
-5.   if(res) {
-4.     fclose(hd_src);
-3.     return res;
-2.   }
-1.   easy_init(curl);

/*enable uploading*/

1.   easy_setopt(curl, CURLOPT_UPLOAD, 1L);",Not Useful,1
/*specify target*/,"-1.   easy_setopt(curl, CURLOPT_UPLOAD, 1L);

/*specify target*/

1.   easy_setopt(curl, CURLOPT_URL, URL);",Not Useful,1
/*go verbose*/,"-1.   easy_setopt(curl, CURLOPT_URL, URL);

/*go verbose*/

1.   easy_setopt(curl, CURLOPT_VERBOSE, 1L);",Not Useful,1
/*now specify which file to upload*/,"-1.   easy_setopt(curl, CURLOPT_VERBOSE, 1L);

/*now specify which file to upload*/

1.   easy_setopt(curl, CURLOPT_READDATA, hd_src);
2.   easy_setopt(curl, CURLOPT_USERPWD, libtest_arg3);
3.   easy_setopt(curl, CURLOPT_SSH_PUBLIC_KEYFILE, ""curl_client_key.pub"");
4.   easy_setopt(curl, CURLOPT_SSH_PRIVATE_KEYFILE, ""curl_client_key"");
5.   easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
6.   easy_setopt(curl, CURLOPT_INFILESIZE_LARGE, (curl_off_t)file_info.st_size);
7.   multi_init(m);
8.   multi_setopt(m, CURLMOPT_SOCKETFUNCTION, curlSocketCallback);
9.   multi_setopt(m, CURLMOPT_SOCKETDATA, &sockets);
10.   multi_setopt(m, CURLMOPT_TIMERFUNCTION, curlTimerCallback);",Not Useful,1
/*Curl's timer has elapsed.*/,"-3.     checkFdSet(m, &sockets.read, &readSet, CURL_CSELECT_IN, ""read"");
-2.     checkFdSet(m, &sockets.write, &writeSet, CURL_CSELECT_OUT, ""write"");
-1.     if(timeout.tv_sec != -1 && getMicroSecondTimeout(&timeout) == 0) {

/*Curl's timer has elapsed.*/

1.       notifyCurl(m, CURL_SOCKET_TIMEOUT, 0, ""timeout"");
2.     }
3.     abort_on_test_timeout();
4.   }
5.   if(!success) {
6.     fprintf(stderr, ""Error uploading file.\n"");
7.     res = TEST_ERR_MAJOR_BAD;
8.   }
9. test_cleanup:",Not Useful,1
/*we don't use this*/,"-10. #include ""memdebug.h""
-9. int test(char *URL)
-8. {
-7.   const unsigned char a[] = {0x2f, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
-6.                              0x91, 0xa2, 0xb3, 0xc4, 0xd5, 0xe6, 0xf7};
-5.   CURLcode res = CURLE_OK;
-4.   char *ptr = NULL;
-3.   int asize;
-2.   int outlen = 0;
-1.   char *raw;

/*we don't use this*/

1.   if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
2.     fprintf(stderr, ""curl_global_init() failed\n"");
3.     return TEST_ERR_MAJOR_BAD;
4.   }
5.   asize = (int)sizeof(a);
6.   ptr = curl_easy_escape(NULL, (char *)a, asize);
7.   printf(""%s\n"", ptr);
8.   curl_free(ptr);",Not Useful,0
/*deprecated API*/,"-8.   if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
-7.     fprintf(stderr, ""curl_global_init() failed\n"");
-6.     return TEST_ERR_MAJOR_BAD;
-5.   }
-4.   asize = (int)sizeof(a);
-3.   ptr = curl_easy_escape(NULL, (char *)a, asize);
-2.   printf(""%s\n"", ptr);
-1.   curl_free(ptr);

/*deprecated API*/

1.   ptr = curl_escape((char *)a, asize);
2.   if(!ptr) {
3.     res = TEST_ERR_MAJOR_BAD;
4.     goto test_cleanup;
5.   }
6.   printf(""%s\n"", ptr);
7.   raw = curl_easy_unescape(NULL, ptr, (int)strlen(ptr), &outlen);
8.   printf(""outlen == %d\n"", outlen);
9.   printf(""unescape == original? %s\n"",
10.          memcmp(raw, a, outlen) ? ""no"" : ""YES"");",Not Useful,1
/*deprecated API*/,"-8.   if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
-7.     fprintf(stderr, ""curl_global_init() failed\n"");
-6.     return TEST_ERR_MAJOR_BAD;
-5.   }
-4.   asize = (int)sizeof(a);
-3.   ptr = curl_easy_escape(NULL, (char *)a, asize);
-2.   printf(""%s\n"", ptr);
-1.   curl_free(ptr);

/*deprecated API*/

1.   ptr = curl_escape((char *)a, asize);
2.   if(!ptr) {
3.     res = TEST_ERR_MAJOR_BAD;
4.     goto test_cleanup;
5.   }
6.   printf(""%s\n"", ptr);
7.   raw = curl_easy_unescape(NULL, ptr, (int)strlen(ptr), &outlen);
8.   printf(""outlen == %d\n"", outlen);
9.   printf(""unescape == original? %s\n"",
10.          memcmp(raw, a, outlen) ? ""no"" : ""YES"");",Not Useful,1
/*unused*/,"-10. int test(char *URL)
-9. {
-8.   CURLM *handle;
-7.   int res = CURLE_OK;
-6.   static const char * const bl_servers[] =
-5.      {""Microsoft-IIS/6.0"", ""nginx/0.8.54"", NULL};
-4.   static const char * const bl_sites[] =
-3.      {""curl.se:443"", ""example.com:80"", NULL};
-2.   global_init(CURL_GLOBAL_ALL);
-1.   handle = curl_multi_init();

/*unused*/

1.   curl_multi_setopt(handle, CURLMOPT_PIPELINING_SERVER_BL, bl_servers);
2.   curl_multi_setopt(handle, CURLMOPT_PIPELINING_SITE_BL, bl_sites);
3.   curl_multi_cleanup(handle);
4.   curl_global_cleanup();
5.   return 0;
6. }",Not Useful,1
/*done*/,"-10.       easy_setopt(easy[num_handles], CURLOPT_HEADER, 1L);
-9.       multi_add_handle(multi, easy[num_handles]);
-8.       num_handles += 1;
-7.       state = NeedSocketForNewHandle;
-6.     }
-5.     multi_perform(multi, &running);
-4.     fprintf(stderr, ""%s:%d running %d state %d\n"",
-3.             __FILE__, __LINE__, running, state);
-2.     abort_on_test_timeout();
-1.     if(!running && state == NoMoreHandles)

/*done*/

1.     FD_ZERO(&fdread);
2.     FD_ZERO(&fdwrite);
3.     FD_ZERO(&fdexcep);
4.     multi_fdset(multi, &fdread, &fdwrite, &fdexcep, &maxfd);",Not Useful,1
/** This is the list of basic details you need to tweak to get things right.*/,"-10.  * copies of the Software, and permit persons to whom the Software is
-9.  * furnished to do so, under the terms of the COPYING file.
-8.  *
-7.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-6.  * KIND, either express or implied.
-5.  *
-4.  ***************************************************************************/
-3. #include ""test.h""
-2. #include ""memdebug.h""
-1. /*
 * This is the list of basic details you need to tweak to get things right.

/** This is the list of basic details you need to tweak to get things right.*/

1.  */
2. #define TO ""<recipient@example.com>""
3. #define FROM ""<sender@example.com>""
4. static const char *payload_text[] = {
5.   ""From: different\r\n"",
6.   ""To: another\r\n"",
7.   ""\r\n"",
8.   ""\r\n"",
9.   "".\r\n"",
10.   "".\r\n"",",Not Useful,1
/*provide this to the rest*/,"-10.   if(argc< 2) {
-9.     fprintf(stderr, ""Pass URL as argument please\n"");
-8.     return 1;
-7.   }
-6.   test_argc = argc;
-5.   test_argv = argv;
-4.   if(argc>2)
-3.     libtest_arg2 = argv[2];
-2.   if(argc>3)
-1.     libtest_arg3 = argv[3];

/*provide this to the rest*/

1.   fprintf(stderr, ""URL: %s\n"", URL);
2.   result = test(URL);
3. #ifdef USE_NSS
4.   if(PR_Initialized())",Not Useful,1
"/*prevent valgrind from reporting possibly lost memory (fd cache, ...)*/","-4.   fprintf(stderr, ""URL: %s\n"", URL);
-3.   result = test(URL);
-2. #ifdef USE_NSS
-1.   if(PR_Initialized())

/*prevent valgrind from reporting possibly lost memory (fd cache, ...)*/

1.     PR_Cleanup();
2. #endif
3. #ifdef WIN32",Not Useful,1
/*just to please curl_base64.h we create a fake struct*/,"-10.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-9.  * KIND, either express or implied.
-8.  *
-7.  ***************************************************************************/
-6. #include ""server_setup.h""
-5. #include ""getpart.h""
-4. #define ENABLE_CURLX_PRINTF

/*just to please curl_base64.h we create a fake struct*/

1. struct Curl_easy {
2.   int fake;
3. };
4. #include ""curl_base64.h""
5. #include ""curl_memory.h""",Not Useful,1
/*dest buffer*/,"-10.  *
-9.  * Destination buffer will be enlarged and relocated as needed.
-8.  *
-7.  * Calling function is responsible to provide preallocated destination
-6.  * buffer and also to deallocate it when no longer needed.
-5.  *
-4.  * This function may return:
-3.  *   GPE_OUT_OF_MEMORY
-2.  *   GPE_OK
-1.  */

/*dest buffer*/

111",Not Useful,1
/*dest buffer data length*/,"-10.  * Destination buffer will be enlarged and relocated as needed.
-9.  *
-8.  * Calling function is responsible to provide preallocated destination
-7.  * buffer and also to deallocate it when no longer needed.
-6.  *
-5.  * This function may return:
-4.  *   GPE_OUT_OF_MEMORY
-3.  *   GPE_OK
-2.  */

/*dest buffer data length*/

111",Not Useful,0
/*dest buffer allocated size*/,"-10.  *
-9.  * Calling function is responsible to provide preallocated destination
-8.  * buffer and also to deallocate it when no longer needed.
-7.  *
-6.  * This function may return:
-5.  *   GPE_OUT_OF_MEMORY
-4.  *   GPE_OK
-3.  */

/*dest buffer allocated size*/

111",Not Useful,0
/*source buffer*/,"-10.     if(!newptr)
-9.       return GPE_OUT_OF_MEMORY;
-8.     *buffer = newptr;
-7.     *bufsize *= 2;
-6.   }
-5.   return GPE_OK;
-4. }
-3. /*
-2.  * appenddata()
-1.  *
 * This appends data from a given source buffer to the end of the used part of

/*source buffer*/

1.  * a destination buffer. Arguments relative to the destination buffer are, the
2.  * address of a pointer to the destination buffer 'dst_buf', the length of data
3.  * in destination buffer excluding potential null string termination 'dst_len',
4.  * the allocated size of destination buffer 'dst_alloc'. All three destination
5.  * buffer arguments may be modified by this function. Arguments relative to the
6.  * source buffer are, a pointer to the source buffer 'src_buf' and indication
7.  * whether the source buffer is base64 encoded or not 'src_b64'.
8.  *
9.  * If the source buffer is indicated to be base64 encoded, this appends the
10.  * decoded data, binary or whatever, to the destination. The source buffer",Not Useful,0
/*!= 0 if source is base64 encoded*/,"-10.  *
-9.  * This function may return:
-8.  *   GPE_OUT_OF_MEMORY
-7.  *   GPE_OK
-6.  */

/*!= 0 if source is base64 encoded*/

1. {
2.   size_t need_alloc = 0;
3.   if(!src_len)
4.     return GPE_OK;
5.   need_alloc = src_len + *dst_len + 1;
6.   if(src_b64) {
7.     if(src_buf[src_len - 1] == '\r')
8.       src_len--;
9.     if(src_buf[src_len - 1] == '\n')
10.       src_len--;",Not Useful,0
/*enlarge destination buffer if required*/,"-10.   size_t need_alloc = 0;
-9.   if(!src_len)
-8.     return GPE_OK;
-7.   need_alloc = src_len + *dst_len + 1;
-6.   if(src_b64) {
-5.     if(src_buf[src_len - 1] == '\r')
-4.       src_len--;
-3.     if(src_buf[src_len - 1] == '\n')
-2.       src_len--;
-1.   }

/*enlarge destination buffer if required*/

1.   if(need_alloc > *dst_alloc) {
2.     size_t newsize = need_alloc * 2;
3.     char *newptr = realloc(*dst_buf, newsize);
4.     if(!newptr) {
5.       return GPE_OUT_OF_MEMORY;
6.     }
7.     *dst_alloc = newsize;
8.     *dst_buf = newptr;
9.   }",Not Useful,1
/*memcpy to support binary blobs*/,"-9.   if(need_alloc > *dst_alloc) {
-8.     size_t newsize = need_alloc * 2;
-7.     char *newptr = realloc(*dst_buf, newsize);
-6.     if(!newptr) {
-5.       return GPE_OUT_OF_MEMORY;
-4.     }
-3.     *dst_alloc = newsize;
-2.     *dst_buf = newptr;
-1.   }

/*memcpy to support binary blobs*/

1.   memcpy(*dst_buf + *dst_len, src_buf, src_len);
2.   *dst_len += src_len;
3.   *(*dst_buf + *dst_len) = '\0';
4.   return GPE_OK;
5. }",Not Useful,1
/*dest buffer*/,"-10.  *
-9.  * Destination buffer will be enlarged and relocated as needed.
-8.  *
-7.  * Calling function is responsible to provide preallocated destination
-6.  * buffer and also to deallocate it when no longer needed.
-5.  *
-4.  * This function may return:
-3.  *   GPE_OUT_OF_MEMORY
-2.  *   GPE_OK
-1.  */

/*dest buffer*/

111",Not Useful,1
/*dest buffer data length*/,"-10.  * Destination buffer will be enlarged and relocated as needed.
-9.  *
-8.  * Calling function is responsible to provide preallocated destination
-7.  * buffer and also to deallocate it when no longer needed.
-6.  *
-5.  * This function may return:
-4.  *   GPE_OUT_OF_MEMORY
-3.  *   GPE_OK
-2.  */

/*dest buffer data length*/

111",Not Useful,1
/*base64 decode the given buffer*/,"-6. {
-5.   CURLcode error = CURLE_OK;
-4.   unsigned char *buf64 = NULL;
-3.   size_t src_len = 0;
-2.   if(!*len)
-1.     return GPE_OK;

/*base64 decode the given buffer*/

1.   error = Curl_base64_decode(*buf, &buf64, &src_len);
2.   if(error)
3.     return GPE_OUT_OF_MEMORY;
4.   if(!src_len) {",Not Useful,0
/*memcpy to support binary blobs*/,"-9.   if(need_alloc > *dst_alloc) {
-8.     size_t newsize = need_alloc * 2;
-7.     char *newptr = realloc(*dst_buf, newsize);
-6.     if(!newptr) {
-5.       return GPE_OUT_OF_MEMORY;
-4.     }
-3.     *dst_alloc = newsize;
-2.     *dst_buf = newptr;
-1.   }

/*memcpy to support binary blobs*/

1.   memcpy(*dst_buf + *dst_len, src_buf, src_len);
2.   *dst_len += src_len;
3.   *(*dst_buf + *dst_len) = '\0';
4.   return GPE_OK;
5. }",Not Useful,1
/*current outermost section*/,"-10.  *
-9.  * This function may return:
-8.  *   GPE_NO_BUFFER_SPACE
-7.  *   GPE_OUT_OF_MEMORY
-6.  *   GPE_OK
-5.  */
-4. int getpart(char **outbuf, size_t *outlen,
-3.             const char *main, const char *sub, FILE *stream)
-2. {
-1. # define MAX_TAG_LEN 200

/*current outermost section*/

111",Not Useful,1
/*current main section*/,"-10.  * This function may return:
-9.  *   GPE_NO_BUFFER_SPACE
-8.  *   GPE_OUT_OF_MEMORY
-7.  *   GPE_OK
-6.  */
-5. int getpart(char **outbuf, size_t *outlen,
-4.             const char *main, const char *sub, FILE *stream)
-3. {
-2. # define MAX_TAG_LEN 200

/*current main section*/

111",Not Useful,0
/*current sub section*/,"-10.  *   GPE_NO_BUFFER_SPACE
-9.  *   GPE_OUT_OF_MEMORY
-8.  *   GPE_OK
-7.  */
-6. int getpart(char **outbuf, size_t *outlen,
-5.             const char *main, const char *sub, FILE *stream)
-4. {
-3. # define MAX_TAG_LEN 200

/*current sub section*/

111",Not Useful,1
/*potential tag*/,"-10.  *   GPE_OUT_OF_MEMORY
-9.  *   GPE_OK
-8.  */
-7. int getpart(char **outbuf, size_t *outlen,
-6.             const char *main, const char *sub, FILE *stream)
-5. {
-4. # define MAX_TAG_LEN 200

/*potential tag*/

111",Not Useful,1
/*potential attributes*/,"-10.  *   GPE_OK
-9.  */
-8. int getpart(char **outbuf, size_t *outlen,
-7.             const char *main, const char *sub, FILE *stream)
-6. {
-5. # define MAX_TAG_LEN 200

/*potential attributes*/

1.   char *buffer = NULL;
2.   char *ptr;
3.   char *end;
4.   union {
5.     ssize_t sig;
6.      size_t uns;
7.   } len;
8.   size_t bufsize = 0;
9.   size_t outalloc = 256;
10.   size_t datalen;",Not Useful,1
/*while*/,"-1. #include ""memdebug.h""
#define EAT_SPACE(p) while(*(p) && ISSPACE(*(p))) (p)++

/*while*/

1. #define EAT_WORD(p)  while(*(p) && !ISSPACE(*(p)) && ('>' != *(p))) (p)++
2. #ifdef DEBUG_GETPART
3. #define show(x) printf x
4. #else
5. #define show(x) Curl_nop_stmt
6. #endif
7. #if defined(_MSC_VER) && defined(_DLL)",Not Useful,1
/*this doesn't set the PATH part*/,"-10.   CURL *handle = NULL;
-9.   CURLcode res = 0;
-8.   CURLU *urlp = NULL;
-7.   global_init(CURL_GLOBAL_ALL);
-6.   easy_init(handle);
-5.   urlp = curl_url();
-4.   if(!urlp) {
-3.     fprintf(stderr, ""problem init URL api."");
-2.     goto test_cleanup;
-1.   }

/*this doesn't set the PATH part*/

1.   if(curl_url_set(urlp, CURLUPART_HOST, ""www.example.com"", 0) ||
2.      curl_url_set(urlp, CURLUPART_SCHEME, ""http"", 0) ||
3.      curl_url_set(urlp, CURLUPART_PORT, ""80"", 0)) {
4.     fprintf(stderr, ""problem setting CURLUPART"");
5.     goto test_cleanup;
6.   }
7.   easy_setopt(handle, CURLOPT_CURLU, urlp);
8.   easy_setopt(handle, CURLOPT_VERBOSE, 1L);
9.   easy_setopt(handle, CURLOPT_PROXY, URL);
10.   res = curl_easy_perform(handle);",Not Useful,1
/*no wakeup*/,"-10. {
-9.   CURLM *multi = NULL;
-8.   int numfds;
-7.   int i;
-6.   int res = 0;
-5.   struct timeval time_before_wait, time_after_wait;
-4.   (void)URL;
-3.   start_test_timing();
-2.   global_init(CURL_GLOBAL_ALL);
-1.   multi_init(multi);

/*no wakeup*/

1.   time_before_wait = tutil_tvnow();
2.   multi_poll(multi, NULL, 0, 1000, &numfds);
3.   time_after_wait = tutil_tvnow();
4.   if(tutil_tvdiff(time_after_wait, time_before_wait) < 500) {
5.     fprintf(stderr, ""%s:%d curl_multi_poll returned too early\n"",
6.             __FILE__, __LINE__);
7.     res = TEST_ERR_MAJOR_BAD;
8.     goto test_cleanup;
9.   }
10.   abort_on_test_timeout();",Not Useful,1
"/*Check range/resume returned error codes and data presence.

  The input parameters are:
  - CURLOPT_RANGE/CURLOPT_RESUME_FROM
  - CURLOPT_FAILONERROR
  - Returned http code (2xx/416)
  - Content-Range header present in reply.*/","-10.  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
-9.  * copies of the Software, and permit persons to whom the Software is
-8.  * furnished to do so, under the terms of the COPYING file.
-7.  *
-6.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-5.  * KIND, either express or implied.
-4.  *
-3.  ***************************************************************************/
-2. #include ""test.h""
-1. /*
  Check range/resume returned error codes and data presence.

  The input parameters are:
  - CURLOPT_RANGE/CURLOPT_RESUME_FROM
  - CURLOPT_FAILONERROR
  - Returned http code (2xx/416)
  - Content-Range header present in reply.

/*Check range/resume returned error codes and data presence.

  The input parameters are:
  - CURLOPT_RANGE/CURLOPT_RESUME_FROM
  - CURLOPT_FAILONERROR
  - Returned http code (2xx/416)
  - Content-Range header present in reply.*/

1. */
2. #include ""memdebug.h""",Not Useful,1
/*TIMEVALUE in the future*/,"-10. int test(char *URL)
-9. {
-8.   long unmet;
-7.   CURL *curl = NULL;
-6.   int res = 0;
-5.   global_init(CURL_GLOBAL_ALL);
-4.   easy_init(curl);
-3.   easy_setopt(curl, CURLOPT_URL, URL);
-2.   easy_setopt(curl, CURLOPT_HEADER, 1L);
-1.   easy_setopt(curl, CURLOPT_TIMECONDITION, (long)CURL_TIMECOND_IFMODSINCE);

/*TIMEVALUE in the future*/

1.   easy_setopt(curl, CURLOPT_TIMEVALUE, 1566210680L);
2.   res = curl_easy_perform(curl);
3.   if(res)
4.     goto test_cleanup;
5.   curl_easy_getinfo(curl, CURLINFO_CONDITION_UNMET, &unmet);
6.   if(unmet != 1L) {",Not Useful,0
/*TIMEVALUE in the past*/,"-2.     goto test_cleanup;
-1.   }

/*TIMEVALUE in the past*/

1.   easy_setopt(curl, CURLOPT_TIMEVALUE, 1L);
2.   res = curl_easy_perform(curl);
3.   if(res)
4.     goto test_cleanup;
5.   curl_easy_getinfo(curl, CURLINFO_CONDITION_UNMET, &unmet);
6.   if(unmet) {",Not Useful,1
/*this is where we should be*/,"-2.     goto test_cleanup;
-1.   }

/*this is where we should be*/

1. test_cleanup:",Not Useful,1
/*unused parameter*/,"-10.   else {
-9.     data->paused = 1;
-8.     return CURL_READFUNC_PAUSE;
-7.   }
-6. }
-5. static size_t write_callback(char *ptr, size_t size, size_t nmemb,
-4.                              void *userdata)
-3. {
-2.   struct cb_data *data = (struct cb_data *)userdata;
-1.   size_t totalsize = nmemb * size;

/*unused parameter*/

1.   (void)ptr;",Not Useful,1
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

/*errno.h value*/

1. #undef  ERANGE",Not Useful,1
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

/*errno.h value*/

1. #undef  ERANGE",Not Useful,1
/*previous test number we served*/,"-8. #endif
-7. #ifdef ENABLE_IPV6
-6. static bool use_ipv6 = FALSE;
-5. #endif
-4. static const char *ipv_inuse = ""IPv4"";
-3. static int serverlogslocked = 0;
-2. #define REQBUFSIZ 150000
-1. #define REQBUFSIZ_TXT ""149999""

/*previous test number we served*/

111",Not Useful,1
/*previous part number we served*/,"-9. #endif
-8. #ifdef ENABLE_IPV6
-7. static bool use_ipv6 = FALSE;
-6. #endif
-5. static const char *ipv_inuse = ""IPv4"";
-4. static int serverlogslocked = 0;
-3. #define REQBUFSIZ 150000
-2. #define REQBUFSIZ_TXT ""149999""

/*previous part number we served*/

111",Not Useful,0
/*buffer area for the incoming request*/,"-9. typedef enum {
-8.   RPROT_NONE = 0,
-7.   RPROT_RTSP = 1,
-6.   RPROT_HTTP = 2
-5. } reqprot_t;
-4. #define SET_RTP_PKT_CHN(p,c)  ((p)[1] = (unsigned char)((c) & 0xFF))
-3. #define SET_RTP_PKT_LEN(p,l) (((p)[2] = (unsigned char)(((l) >> 8) & 0xFF)), \
-2.                               ((p)[3] = (unsigned char)((l) & 0xFF)))
-1. struct httprequest {

/*buffer area for the incoming request*/

111",Not Useful,0
/*where to start checking of the request*/,"-10. typedef enum {
-9.   RPROT_NONE = 0,
-8.   RPROT_RTSP = 1,
-7.   RPROT_HTTP = 2
-6. } reqprot_t;
-5. #define SET_RTP_PKT_CHN(p,c)  ((p)[1] = (unsigned char)((c) & 0xFF))
-4. #define SET_RTP_PKT_LEN(p,l) (((p)[2] = (unsigned char)(((l) >> 8) & 0xFF)), \
-3.                               ((p)[3] = (unsigned char)((l) & 0xFF)))
-2. struct httprequest {

/*where to start checking of the request*/

111",Not Useful,0
/*size of the incoming request*/,"-10.   RPROT_NONE = 0,
-9.   RPROT_RTSP = 1,
-8.   RPROT_HTTP = 2
-7. } reqprot_t;
-6. #define SET_RTP_PKT_CHN(p,c)  ((p)[1] = (unsigned char)((c) & 0xFF))
-5. #define SET_RTP_PKT_LEN(p,l) (((p)[2] = (unsigned char)(((l) >> 8) & 0xFF)), \
-4.                               ((p)[3] = (unsigned char)((l) & 0xFF)))
-3. struct httprequest {

/*size of the incoming request*/

111",Not Useful,1
/*test number found in the request*/,"-10.   RPROT_RTSP = 1,
-9.   RPROT_HTTP = 2
-8. } reqprot_t;
-7. #define SET_RTP_PKT_CHN(p,c)  ((p)[1] = (unsigned char)((c) & 0xFF))
-6. #define SET_RTP_PKT_LEN(p,l) (((p)[2] = (unsigned char)(((l) >> 8) & 0xFF)), \
-5.                               ((p)[3] = (unsigned char)((l) & 0xFF)))
-4. struct httprequest {

/*test number found in the request*/

111",Not Useful,1
/*part number found in the request*/,"-10.   RPROT_HTTP = 2
-9. } reqprot_t;
-8. #define SET_RTP_PKT_CHN(p,c)  ((p)[1] = (unsigned char)((c) & 0xFF))
-7. #define SET_RTP_PKT_LEN(p,l) (((p)[2] = (unsigned char)(((l) >> 8) & 0xFF)), \
-6.                               ((p)[3] = (unsigned char)((l) & 0xFF)))
-5. struct httprequest {

/*part number found in the request*/

111",Not Useful,0
/*Authorization header present in the incoming request*/,"-10.                               ((p)[3] = (unsigned char)((l) & 0xFF)))
-9. struct httprequest {

/*Authorization header present in the incoming request*/

111",Not Useful,0
/*Content-Length of the incoming request*/,"-10. struct httprequest {

/*Content-Length of the incoming request*/

111",Not Useful,1
/*Authorization digest header found*/,"-10.   char reqbuf[REQBUFSIZ]; /* buffer area for the incoming request */
-9.   size_t checkindex; /* where to start checking of the request */
-8.   size_t offset;     /* size of the incoming request */
-7.   long testno;       /* test number found in the request */
-6.   long partno;       /* part number found in the request */
-5.   bool open;      /* keep connection open info, as found in the request */
-4.   bool auth_req;  /* authentication required, don't wait for body unless
-3.                      there's an Authorization header */
-2.   bool auth;      /* Authorization header present in the incoming request */
-1.   size_t cl;      /* Content-Length of the incoming request */
  bool digest;    /* Authorization digest header found */

/*Authorization digest header found*/

111",Not Useful,1
/*Authorization ntlm header found*/,"-10.   size_t checkindex; /* where to start checking of the request */
-9.   size_t offset;     /* size of the incoming request */
-8.   long testno;       /* test number found in the request */
-7.   long partno;       /* part number found in the request */
-6.   bool open;      /* keep connection open info, as found in the request */
-5.   bool auth_req;  /* authentication required, don't wait for body unless
-4.                      there's an Authorization header */
-3.   bool auth;      /* Authorization header present in the incoming request */
-2.   size_t cl;      /* Content-Length of the incoming request */
-1.   bool digest;    /* Authorization digest header found */
  bool ntlm;      /* Authorization ntlm header found */

/*Authorization ntlm header found*/

111",Not Useful,1
"/*if non-zero, expect this many requests to do a ""piped""
                     request/response*/","-10.   size_t offset;     /* size of the incoming request */
-9.   long testno;       /* test number found in the request */
-8.   long partno;       /* part number found in the request */
-7.   bool open;      /* keep connection open info, as found in the request */
-6.   bool auth_req;  /* authentication required, don't wait for body unless
-5.                      there's an Authorization header */
-4.   bool auth;      /* Authorization header present in the incoming request */
-3.   size_t cl;      /* Content-Length of the incoming request */
-2.   bool digest;    /* Authorization digest header found */
-1.   bool ntlm;      /* Authorization ntlm header found */
  int pipe;       /* if non-zero, expect this many requests to do a ""piped""
                     request/response */

/*if non-zero, expect this many requests to do a ""piped""
                     request/response*/

111",Not Useful,1
"/*if non-zero, the server is instructed to not read this
                     many bytes from a PUT/POST request. Ie the client sends N
                     bytes said in Content-Length, but the server only reads N
                     - skip bytes.*/","-10.   long partno;       /* part number found in the request */
-9.   bool open;      /* keep connection open info, as found in the request */
-8.   bool auth_req;  /* authentication required, don't wait for body unless
-7.                      there's an Authorization header */
-6.   bool auth;      /* Authorization header present in the incoming request */
-5.   size_t cl;      /* Content-Length of the incoming request */
-4.   bool digest;    /* Authorization digest header found */
-3.   bool ntlm;      /* Authorization ntlm header found */
-2.   int pipe;       /* if non-zero, expect this many requests to do a ""piped""
-1.                      request/response */
  int skip;       /* if non-zero, the server is instructed to not read this
                     many bytes from a PUT/POST request. Ie the client sends N
                     bytes said in Content-Length, but the server only reads N
                     - skip bytes. */

/*if non-zero, the server is instructed to not read this
                     many bytes from a PUT/POST request. Ie the client sends N
                     bytes said in Content-Length, but the server only reads N
                     - skip bytes.*/

111",Not Useful,1
"/*doing a special command, see defines above*/","-10.   bool auth;      /* Authorization header present in the incoming request */
-9.   size_t cl;      /* Content-Length of the incoming request */
-8.   bool digest;    /* Authorization digest header found */
-7.   bool ntlm;      /* Authorization ntlm header found */
-6.   int pipe;       /* if non-zero, expect this many requests to do a ""piped""
-5.                      request/response */
-4.   int skip;       /* if non-zero, the server is instructed to not read this
-3.                      many bytes from a PUT/POST request. Ie the client sends N
-2.                      bytes said in Content-Length, but the server only reads N
-1.                      - skip bytes. */
  int rcmd;       /* doing a special command, see defines above */

/*doing a special command, see defines above*/

111",Not Useful,1
"/*request protocol, HTTP or RTSP*/","-10.   size_t cl;      /* Content-Length of the incoming request */
-9.   bool digest;    /* Authorization digest header found */
-8.   bool ntlm;      /* Authorization ntlm header found */
-7.   int pipe;       /* if non-zero, expect this many requests to do a ""piped""
-6.                      request/response */
-5.   int skip;       /* if non-zero, the server is instructed to not read this
-4.                      many bytes from a PUT/POST request. Ie the client sends N
-3.                      bytes said in Content-Length, but the server only reads N
-2.                      - skip bytes. */
-1.   int rcmd;       /* doing a special command, see defines above */
  reqprot_t protocol; /* request protocol, HTTP or RTSP */

/*request protocol, HTTP or RTSP*/

111",Not Useful,1
/*very-big-path support*/,"-10. static int ProcessRequest(struct httprequest *req);
-9. static void storerequest(char *reqbuf, size_t totalsize);
-8. #define DEFAULT_PORT 8999
-7. #ifndef DEFAULT_LOGFILE
-6. #define DEFAULT_LOGFILE ""log/rtspd.log""
-5. #endif
-4. const char *serverlogfile = DEFAULT_LOGFILE;
-3. #define RTSPDVERSION ""curl test suite RTSP server/0.1""
-2. #define REQUEST_DUMP  ""log/server.input""
-1. #define RESPONSE_DUMP ""log/server.response""

/*very-big-path support*/

1. #define MAXDOCNAMELEN 140000
2. #define MAXDOCNAMELEN_TXT ""139999""
3. #define REQUEST_KEYWORD_SIZE 256
4. #define REQUEST_KEYWORD_SIZE_TXT ""255""
5. #define CMD_AUTH_REQUIRED ""auth_required""",Not Useful,1
"/*IETF//DTD HTML 2.0//EN\"">\n""*/","-5. static const char *doc404_HTTP = ""HTTP/1.1 404 Not Found\r\n""
-4.     ""Server: "" RTSPDVERSION ""\r\n""
-3.     ""Connection: close\r\n""
-2.     ""Content-Type: text/html""
-1.     END_OF_HEADERS

/*IETF//DTD HTML 2.0//EN\"">\n""*/

1.     ""<HTML><HEAD>\n""
2.     ""<TITLE>404 Not Found</TITLE>\n""
3.     ""</HEAD><BODY>\n""
4.     ""<H1>Not Found</H1>\n""
5.     ""The requested URL was not found on this server.\n""
6.     ""<P><HR><ADDRESS>"" RTSPDVERSION ""</ADDRESS>\n"" ""</BODY></HTML>\n"";",Not Useful,1
/*find the last slash*/,"-10.     }
-9.     else if(!strcmp(prot_str, ""RTSP"")) {
-8.       req->protocol = RPROT_RTSP;
-7.     }
-6.     else {
-5.       req->protocol = RPROT_NONE;
-4.       logmsg(""got unknown protocol %s"", prot_str);
-3.       return 1;
-2.     }
-1.     req->prot_version = prot_major*10 + prot_minor;

/*find the last slash*/

1.     ptr = strrchr(doc, '/');",Not Useful,1
/*get the number after it*/,"-1.     ptr = strrchr(doc, '/');

/*get the number after it*/

1.     if(ptr) {
2.       FILE *stream;
3.       if((strlen(doc) + strlen(request)) < 200)
4.         msnprintf(logbuf, sizeof(logbuf), ""Got request: %s %s %s/%d.%d"",
5.                   request, doc, prot_str, prot_major, prot_minor);
6.       else
7.         msnprintf(logbuf, sizeof(logbuf), ""Got a *HUGE* request %s/%d.%d"",
8.                   prot_str, prot_major, prot_minor);
9.       logmsg(""%s"", logbuf);
10.       if(!strncmp(""/verifiedserver"", ptr, 15)) {",Not Useful,1
/*skip the slash*/,"-1.       }

/*skip the slash*/

111",Not Useful,1
/*skip all non-numericals following the slash*/,"-2.       }

/*skip all non-numericals following the slash*/

1.       while(*ptr && !ISDIGIT(*ptr))
2.         ptr++;
3.       req->testno = strtol(ptr, &ptr, 10);
4.       if(req->testno > 10000) {
5.         req->partno = req->testno % 10000;
6.         req->testno /= 10000;
7.       }
8.       else
9.         req->partno = 0;
10.       msnprintf(logbuf, sizeof(logbuf), ""Requested test number %ld part %ld"",",Not Useful,0
/*closes connection*/,"-10.       else
-9.         req->partno = 0;
-8.       msnprintf(logbuf, sizeof(logbuf), ""Requested test number %ld part %ld"",
-7.                 req->testno, req->partno);
-6.       logmsg(""%s"", logbuf);
-5.       stream = test2fopen(req->testno);
-4.       if(!stream) {
-3.         int error = errno;
-2.         logmsg(""fopen() failed with error: %d %s"", error, strerror(error));
-1.         logmsg(""Couldn't open test file %ld"", req->testno);

/*closes connection*/

111",Not Useful,1
/*closes connection*/,"-10.       else
-9.         req->partno = 0;
-8.       msnprintf(logbuf, sizeof(logbuf), ""Requested test number %ld part %ld"",
-7.                 req->testno, req->partno);
-6.       logmsg(""%s"", logbuf);
-5.       stream = test2fopen(req->testno);
-4.       if(!stream) {
-3.         int error = errno;
-2.         logmsg(""fopen() failed with error: %d %s"", error, strerror(error));
-1.         logmsg(""Couldn't open test file %ld"", req->testno);

/*closes connection*/

111",Not Useful,1
"/*Make our scratch buffer enough to fit all the
                 * desired data and one for padding*/","-10.             else if(1 == sscanf(ptr, ""skip: %d"", &num)) {
-9.               logmsg(""instructed to skip this number of bytes %d"", num);
-8.               req->skip = num;
-7.             }
-6.             else if(3 == sscanf(ptr, ""rtp: part %d channel %d size %d"",
-5.                                 &rtp_partno, &rtp_channel, &rtp_size)) {
-4.               if(rtp_partno == req->partno) {
-3.                 int i = 0;
-2.                 logmsg(""RTP: part %d channel %d size %d"",
-1.                        rtp_partno, rtp_channel, rtp_size);

/*Make our scratch buffer enough to fit all the
                 * desired data and one for padding*/

1.                 rtp_scratch = malloc(rtp_size + 4 + RTP_DATA_SIZE);",Not Useful,1
/*HTTP 1.0 closes connection by default*/,"-10.       }
-9.     }
-8.     else {
-7.       if(sscanf(req->reqbuf, ""CONNECT %"" MAXDOCNAMELEN_TXT ""s HTTP/%d.%d"",
-6.                 doc, &prot_major, &prot_minor) == 3) {
-5.         msnprintf(logbuf, sizeof(logbuf),
-4.                   ""Received a CONNECT %s HTTP/%d.%d request"",
-3.                   doc, prot_major, prot_minor);
-2.         logmsg(""%s"", logbuf);
-1.         if(req->prot_version == 10)

/*HTTP 1.0 closes connection by default*/

1.         if(!strncmp(doc, ""bad"", 3))",Not Useful,1
/*we don't have a complete request yet!*/,"-10.         else
-9.           req->testno = DOCNUMBER_CONNECT;
-8.       }
-7.       else {
-6.         logmsg(""Did not find test number in PATH"");
-5.         req->testno = DOCNUMBER_404;
-4.       }
-3.     }
-2.   }
-1.   if(!end) {

/*we don't have a complete request yet!*/

1.     logmsg(""ProcessRequest returned without a complete request"");",Not Useful,0
/*not complete yet*/,"-1.     logmsg(""ProcessRequest returned without a complete request"");

/*not complete yet*/

1.   }
2.   logmsg(""ProcessRequest found a complete request"");
3.   if(req->pipe)",Not Useful,1
/*closes connection*/,"-10.       else
-9.         req->partno = 0;
-8.       msnprintf(logbuf, sizeof(logbuf), ""Requested test number %ld part %ld"",
-7.                 req->testno, req->partno);
-6.       logmsg(""%s"", logbuf);
-5.       stream = test2fopen(req->testno);
-4.       if(!stream) {
-3.         int error = errno;
-2.         logmsg(""fopen() failed with error: %d %s"", error, strerror(error));
-1.         logmsg(""Couldn't open test file %ld"", req->testno);

/*closes connection*/

111",Not Useful,1
/*done*/,"-10.       if((strlen(doc) + strlen(request)) < 200)
-9.         msnprintf(logbuf, sizeof(logbuf), ""Got request: %s %s %s/%d.%d"",
-8.                   request, doc, prot_str, prot_major, prot_minor);
-7.       else
-6.         msnprintf(logbuf, sizeof(logbuf), ""Got a *HUGE* request %s/%d.%d"",
-5.                   prot_str, prot_major, prot_minor);
-4.       logmsg(""%s"", logbuf);
-3.       if(!strncmp(""/verifiedserver"", ptr, 15)) {
-2.         logmsg(""Are-we-friendly question received"");
-1.         req->testno = DOCNUMBER_WERULEZ;

/*done*/

1.       }
2.       if(!strncmp(""/quit"", ptr, 5)) {
3.         logmsg(""Request-to-quit received"");
4.         req->testno = DOCNUMBER_QUIT;",Not Useful,1
/*chunked data coming in*/,"-9.       }
-8.       req->cl = clen - req->skip;
-7.       logmsg(""Found Content-Length: %lu in the request"", clen);
-6.       if(req->skip)
-5.         logmsg(""... but will abort after %zu bytes"", req->cl);
-4.       break;
-3.     }
-2.     else if(strncasecompare(""Transfer-Encoding: chunked"", line,
-1.                             strlen(""Transfer-Encoding: chunked""))) {

/*chunked data coming in*/

1.       chunked = TRUE;
2.     }
3.     if(chunked) {
4.       if(strstr(req->reqbuf, ""\r\n0\r\n\r\n""))",Not Useful,0
/*Authorization: header present!*/,"-6.     }
-5.     line = strchr(line, '\n');
-4.     if(line)
-3.       line++;
-2.   } while(line);
-1.   if(!req->auth && strstr(req->reqbuf, ""Authorization:"")) {

/*Authorization: header present!*/

1.     if(req->auth_req)
2.       logmsg(""Authorization header found, as required"");
3.   }
4.   if(!req->digest && strstr(req->reqbuf, ""Authorization: Digest"")) {",Not Useful,1
/*header found*/,"-10.   char reqbuf[REQBUFSIZ]; /* buffer area for the incoming request */
-9.   size_t checkindex; /* where to start checking of the request */
-8.   size_t offset;     /* size of the incoming request */
-7.   long testno;       /* test number found in the request */
-6.   long partno;       /* part number found in the request */
-5.   bool open;      /* keep connection open info, as found in the request */
-4.   bool auth_req;  /* authentication required, don't wait for body unless
-3.                      there's an Authorization header */
-2.   bool auth;      /* Authorization header present in the incoming request */
-1.   size_t cl;      /* Content-Length of the incoming request */
  bool digest;    /* Authorization digest header found */

/*header found*/

111",Not Useful,0
/*If the client is passing this type-3 NTLM header*/,"-4.     logmsg(""Received Digest request, sending back data %ld"", req->partno);
-3.   }
-2.   else if(!req->ntlm &&
-1.           strstr(req->reqbuf, ""Authorization: NTLM TlRMTVNTUAAD"")) {

/*If the client is passing this type-3 NTLM header*/

1.     req->partno += 1002;",Not Useful,1
/*NTLM found*/,"-1.     req->partno += 1002;

/*NTLM found*/

1.     logmsg(""Received NTLM type-3, sending back data %ld"", req->partno);
2.     if(req->cl) {
3.       logmsg(""  Expecting %zu POSTed bytes"", req->cl);
4.     }
5.   }
6.   else if(!req->ntlm &&
7.           strstr(req->reqbuf, ""Authorization: NTLM TlRMTVNTUAAB"")) {",Not Useful,1
/*If the client is passing this type-1 NTLM header*/,"-7.     logmsg(""Received NTLM type-3, sending back data %ld"", req->partno);
-6.     if(req->cl) {
-5.       logmsg(""  Expecting %zu POSTed bytes"", req->cl);
-4.     }
-3.   }
-2.   else if(!req->ntlm &&
-1.           strstr(req->reqbuf, ""Authorization: NTLM TlRMTVNTUAAB"")) {

/*If the client is passing this type-1 NTLM header*/

1.     req->partno += 1001;",Not Useful,0
/*NTLM found*/,"-1.     req->partno += 1002;

/*NTLM found*/

1.     logmsg(""Received NTLM type-3, sending back data %ld"", req->partno);
2.     if(req->cl) {
3.       logmsg(""  Expecting %zu POSTed bytes"", req->cl);
4.     }
5.   }
6.   else if(!req->ntlm &&
7.           strstr(req->reqbuf, ""Authorization: NTLM TlRMTVNTUAAB"")) {",Not Useful,1
/*close connection after this request*/,"-4.     req->partno += 1;
-3.     logmsg(""Received Basic request, sending back data %ld"", req->partno);
-2.   }
-1.   if(strstr(req->reqbuf, ""Connection: close""))

/*close connection after this request*/

1.   if(!req->pipe &&
2.      req->open &&
3.      req->prot_version >= 11 &&
4.      req->reqbuf + req->offset > end + strlen(END_OF_HEADERS) &&
5.      (!strncmp(req->reqbuf, ""GET"", strlen(""GET"")) ||
6.       !strncmp(req->reqbuf, ""HEAD"", strlen(""HEAD"")))) {",Not Useful,1
"/*If we have a persistent connection, HTTP version >= 1.1
       and GET/HEAD request, enable pipelining.*/","-6.   if(!req->pipe &&
-5.      req->open &&
-4.      req->prot_version >= 11 &&
-3.      req->reqbuf + req->offset > end + strlen(END_OF_HEADERS) &&
-2.      (!strncmp(req->reqbuf, ""GET"", strlen(""GET"")) ||
-1.       !strncmp(req->reqbuf, ""HEAD"", strlen(""HEAD"")))) {

/*If we have a persistent connection, HTTP version >= 1.1
       and GET/HEAD request, enable pipelining.*/

1.     req->checkindex = (end - req->reqbuf) + strlen(END_OF_HEADERS);
2.     req->pipelining = TRUE;
3.   }
4.   while(req->pipe) {
5.     if(got_exit_signal)",Not Useful,1
/*done*/,"-10.       if((strlen(doc) + strlen(request)) < 200)
-9.         msnprintf(logbuf, sizeof(logbuf), ""Got request: %s %s %s/%d.%d"",
-8.                   request, doc, prot_str, prot_major, prot_minor);
-7.       else
-6.         msnprintf(logbuf, sizeof(logbuf), ""Got a *HUGE* request %s/%d.%d"",
-5.                   prot_str, prot_major, prot_minor);
-4.       logmsg(""%s"", logbuf);
-3.       if(!strncmp(""/verifiedserver"", ptr, 15)) {
-2.         logmsg(""Are-we-friendly question received"");
-1.         req->testno = DOCNUMBER_WERULEZ;

/*done*/

1.       }
2.       if(!strncmp(""/quit"", ptr, 5)) {
3.         logmsg(""Request-to-quit received"");
4.         req->testno = DOCNUMBER_QUIT;",Not Useful,0
"/*If authentication is required and no auth was provided, end now. This
     makes the server NOT wait for PUT/POST data and you can then make the
     test case send a rejection before any such data has been sent. Test case
     154 uses this.*/","-7.     line = &req->reqbuf[req->checkindex];
-6.     end = strstr(line, END_OF_HEADERS);
-5.     if(!end)
-4.       break;
-3.     req->checkindex += (end - line) + strlen(END_OF_HEADERS);
-2.     req->pipe--;
-1.   }

/*If authentication is required and no auth was provided, end now. This
     makes the server NOT wait for PUT/POST data and you can then make the
     test case send a rejection before any such data has been sent. Test case
     154 uses this.*/

1.   if(req->auth_req && !req->auth)",Not Useful,1
/*done*/,"-10.       if((strlen(doc) + strlen(request)) < 200)
-9.         msnprintf(logbuf, sizeof(logbuf), ""Got request: %s %s %s/%d.%d"",
-8.                   request, doc, prot_str, prot_major, prot_minor);
-7.       else
-6.         msnprintf(logbuf, sizeof(logbuf), ""Got a *HUGE* request %s/%d.%d"",
-5.                   prot_str, prot_major, prot_minor);
-4.       logmsg(""%s"", logbuf);
-3.       if(!strncmp(""/verifiedserver"", ptr, 15)) {
-2.         logmsg(""Are-we-friendly question received"");
-1.         req->testno = DOCNUMBER_WERULEZ;

/*done*/

1.       }
2.       if(!strncmp(""/quit"", ptr, 5)) {
3.         logmsg(""Request-to-quit received"");
4.         req->testno = DOCNUMBER_QUIT;",Not Useful,1
/*done*/,"-10.       if((strlen(doc) + strlen(request)) < 200)
-9.         msnprintf(logbuf, sizeof(logbuf), ""Got request: %s %s %s/%d.%d"",
-8.                   request, doc, prot_str, prot_major, prot_minor);
-7.       else
-6.         msnprintf(logbuf, sizeof(logbuf), ""Got a *HUGE* request %s/%d.%d"",
-5.                   prot_str, prot_major, prot_minor);
-4.       logmsg(""%s"", logbuf);
-3.       if(!strncmp(""/verifiedserver"", ptr, 15)) {
-2.         logmsg(""Are-we-friendly question received"");
-1.         req->testno = DOCNUMBER_WERULEZ;

/*done*/

1.       }
2.       if(!strncmp(""/quit"", ptr, 5)) {
3.         logmsg(""Request-to-quit received"");
4.         req->testno = DOCNUMBER_QUIT;",Not Useful,1
/*not complete yet*/,"-1.     logmsg(""ProcessRequest returned without a complete request"");

/*not complete yet*/

1.   }
2.   logmsg(""ProcessRequest found a complete request"");
3.   if(req->pipe)",Not Useful,0
/*done*/,"-10.       if((strlen(doc) + strlen(request)) < 200)
-9.         msnprintf(logbuf, sizeof(logbuf), ""Got request: %s %s %s/%d.%d"",
-8.                   request, doc, prot_str, prot_major, prot_minor);
-7.       else
-6.         msnprintf(logbuf, sizeof(logbuf), ""Got a *HUGE* request %s/%d.%d"",
-5.                   prot_str, prot_major, prot_minor);
-4.       logmsg(""%s"", logbuf);
-3.       if(!strncmp(""/verifiedserver"", ptr, 15)) {
-2.         logmsg(""Are-we-friendly question received"");
-1.         req->testno = DOCNUMBER_WERULEZ;

/*done*/

1.       }
2.       if(!strncmp(""/quit"", ptr, 5)) {
3.         logmsg(""Request-to-quit received"");
4.         req->testno = DOCNUMBER_QUIT;",Not Useful,1
/*** Init the httprequest structure properly for the upcoming request ***/,"-10.   int fail = 0;
-9.   int done_processing = 0;
-8.   char *reqbuf = req->reqbuf;
-7.   ssize_t got = 0;
-6.   char *pipereq = NULL;
-5.   size_t pipereq_length = 0;
-4.   if(req->pipelining) {
-3.     pipereq = reqbuf + req->checkindex;
-2.     pipereq_length = req->offset - req->checkindex;
-1.   }

/*** Init the httprequest structure properly for the upcoming request ***/

1.   req->checkindex = 0;
2.   req->offset = 0;
3.   req->testno = DOCNUMBER_NOTHING;
4.   req->partno = 0;
5.   req->open = TRUE;
6.   req->auth_req = FALSE;
7.   req->auth = FALSE;
8.   req->cl = 0;
9.   req->digest = FALSE;
10.   req->ntlm = FALSE;",Not Useful,1
/*** end of httprequest init ***/,"-10.   req->digest = FALSE;
-9.   req->ntlm = FALSE;
-8.   req->pipe = 0;
-7.   req->skip = 0;
-6.   req->rcmd = RCMD_NORMALREQ;
-5.   req->protocol = RPROT_NONE;
-4.   req->prot_version = 0;
-3.   req->pipelining = FALSE;
-2.   req->rtp_buffer = NULL;
-1.   req->rtp_buffersize = 0;

/*** end of httprequest init ***/

1.   while(!done_processing && (req->offset < REQBUFSIZ-1)) {
2.     if(pipereq_length && pipereq) {
3.       memmove(reqbuf, pipereq, pipereq_length);
4.       got = curlx_uztosz(pipereq_length);
5.       pipereq_length = 0;
6.     }
7.     else {
8.       if(req->skip)
9.         /* we are instructed to not read the entire thing, so we make sure to
10.            only read what we're supposed to and NOT read the enire thing the",Not Useful,0
/*Do nothing. Sit idle. Pretend it rains.*/,"-10.       written = swrite(sock, STREAMTHIS, count);
-9.       if(got_exit_signal)
-8.         return -1;
-7.       if(written != (ssize_t)count) {
-6.         logmsg(""Stopped streaming"");
-5.         break;
-4.       }
-3.     }
-2.     return -1;
-1.   case RCMD_IDLE:

/*Do nothing. Sit idle. Pretend it rains.*/

1.     return 0;
2.   }
3.   req->open = FALSE;
4.   if(req->testno < 0) {
5.     size_t msglen;
6.     char msgbuf[64];
7.     switch(req->testno) {
8.     case DOCNUMBER_QUIT:
9.       logmsg(""Replying to QUIT"");
10.       buffer = docquit;",Not Useful,1
"/*non-zero means error, break out of loop*/","-5.     req.pipelining = FALSE;
-4.     do {
-3.       if(got_exit_signal)
-2.         break;
-1.       if(get_request(msgsock, &req))

/*non-zero means error, break out of loop*/

1.         break;
2.       if(prevbounce) {",Not Useful,0
/*we don't use this*/,"-10.  ***************************************************************************/
-9. #include ""test.h""
-8. #include ""memdebug.h""
-7. int test(char *URL)
-6. {
-5.   unsigned char a[] = {0x2f, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
-4.                        0x91, 0xa2, 0xb3, 0xc4, 0xd5, 0xe6, 0xf7};
-3.   CURLcode res = CURLE_OK;
-2.   char *ptr = NULL;
-1.   int asize;

/*we don't use this*/

1.   if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
2.     fprintf(stderr, ""curl_global_init() failed\n"");
3.     return TEST_ERR_MAJOR_BAD;
4.   }
5.   ptr = malloc(558);
6.   Curl_safefree(ptr);
7.   asize = (int)sizeof(a);
8.   ptr = curl_easy_escape(NULL, (char *)a, asize);
9.   if(ptr)
10.     curl_free(ptr);",Not Useful,1
/*test function*/,"-10.   (void)useptr;
-9.   printf(""-> Mutex lock\n"");
-8. }
-7. static void my_unlock(CURL *handle, curl_lock_data data, void *useptr)
-6. {
-5.   (void)handle;
-4.   (void)data;
-3.   (void)useptr;
-2.   printf(""<- Mutex unlock\n"");
-1. }

/*test function*/

1. int test(char *URL)
2. {
3.   CURLcode res = CURLE_OK;
4.   CURLSH *share;
5.   int i;
6.   global_init(CURL_GLOBAL_ALL);
7.   share = curl_share_init();
8.   if(!share) {
9.     fprintf(stderr, ""curl_share_init() failed\n"");
10.     curl_global_cleanup();",Not Useful,1
/*use the share object*/,"-4.   for(i = 0; i < 3; i++) {
-3.     CURL *curl = curl_easy_init();
-2.     if(curl) {
-1.       curl_easy_setopt(curl, CURLOPT_URL, URL);

/*use the share object*/

1.       curl_easy_setopt(curl, CURLOPT_SHARE, share);",Not Useful,1
/*always cleanup*/,"-3.       if(res != CURLE_OK)
-2.         fprintf(stderr, ""curl_easy_perform() failed: %s\n"",
-1.                 curl_easy_strerror(res));

/*always cleanup*/

1.       curl_easy_cleanup(curl);
2.     }
3.   }
4.   curl_share_cleanup(share);
5.   curl_global_cleanup();
6.   return 0;
7. }",Not Useful,0
"/** Make sure libcurl does not send a `Content-Length: -1` header when HTTP POST
 * size is unknown.*/","-10.  *
-9.  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
-8.  * copies of the Software, and permit persons to whom the Software is
-7.  * furnished to do so, under the terms of the COPYING file.
-6.  *
-5.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-4.  * KIND, either express or implied.
-3.  *
-2.  ***************************************************************************/
-1. /*
 * Make sure libcurl does not send a `Content-Length: -1` header when HTTP POST
 * size is unknown.

/** Make sure libcurl does not send a `Content-Length: -1` header when HTTP POST
 * size is unknown.*/

1.  */
2. #include ""test.h""
3. #include ""memdebug.h""
4. static char data[]=""dummy"";
5. struct WriteThis {
6.   char *readptr;
7.   size_t sizeleft;
8. };
9. static size_t read_callback(char *ptr, size_t size, size_t nmemb, void *userp)
10. {",Not Useful,1
/*copy one single byte*/,"-10. struct WriteThis {
-9.   char *readptr;
-8.   size_t sizeleft;
-7. };
-6. static size_t read_callback(char *ptr, size_t size, size_t nmemb, void *userp)
-5. {
-4.   struct WriteThis *pooh = (struct WriteThis *)userp;
-3.   if(size*nmemb < 1)
-2.     return 0;
-1.   if(pooh->sizeleft) {

/*copy one single byte*/

111",Not Useful,0
/*advance pointer*/,"-10.   char *readptr;
-9.   size_t sizeleft;
-8. };
-7. static size_t read_callback(char *ptr, size_t size, size_t nmemb, void *userp)
-6. {
-5.   struct WriteThis *pooh = (struct WriteThis *)userp;
-4.   if(size*nmemb < 1)
-3.     return 0;
-2.   if(pooh->sizeleft) {

/*advance pointer*/

111",Not Useful,1
/*less data left*/,"-10.   size_t sizeleft;
-9. };
-8. static size_t read_callback(char *ptr, size_t size, size_t nmemb, void *userp)
-7. {
-6.   struct WriteThis *pooh = (struct WriteThis *)userp;
-5.   if(size*nmemb < 1)
-4.     return 0;
-3.   if(pooh->sizeleft) {

/*less data left*/

111",Not Useful,1
/*First set the URL that is about to receive our POST.*/,"-10.   if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
-9.     fprintf(stderr, ""curl_global_init() failed\n"");
-8.     return TEST_ERR_MAJOR_BAD;
-7.   }
-6.   curl = curl_easy_init();
-5.   if(!curl) {
-4.     fprintf(stderr, ""curl_easy_init() failed\n"");
-3.     curl_global_cleanup();
-2.     return TEST_ERR_MAJOR_BAD;
-1.   }

/*First set the URL that is about to receive our POST.*/

1.   test_setopt(curl, CURLOPT_URL, URL);",Not Useful,1
/*we want to use our own progress function*/,"-1.   test_setopt(curl, CURLOPT_URL, URL);

/*we want to use our own progress function*/

1.   test_setopt(curl, CURLOPT_NOPROGRESS, 0L);
2.   test_setopt(curl, CURLOPT_PROGRESSFUNCTION, progress_callback);",Not Useful,1
/*get verbose debug output please*/,"-2.   test_setopt(curl, CURLOPT_NOPROGRESS, 0L);
-1.   test_setopt(curl, CURLOPT_PROGRESSFUNCTION, progress_callback);

/*get verbose debug output please*/

1.   test_setopt(curl, CURLOPT_VERBOSE, 1L);",Not Useful,0
/*follow redirects*/,"-1.   test_setopt(curl, CURLOPT_VERBOSE, 1L);

/*follow redirects*/

1.   test_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);",Not Useful,1
/*include headers in the output*/,"-1.   test_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);

/*include headers in the output*/

1.   test_setopt(curl, CURLOPT_HEADER, 1L);",Not Useful,1
"/*Perform the request, res will get the return code*/","-1.   test_setopt(curl, CURLOPT_HEADER, 1L);

/*Perform the request, res will get the return code*/

1.   res = curl_easy_perform(curl);
2.   if(!res) {
3.     FILE *moo;
4.     res = curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD,
5.                             &content_length);
6.     moo = fopen(libtest_arg2, ""wb"");
7.     if(moo) {
8.       fprintf(moo, ""CL %.0f\n"", content_length);
9.       fclose(moo);
10.     }",Not Useful,0
/*always cleanup*/,"-10.     FILE *moo;
-9.     res = curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD,
-8.                             &content_length);
-7.     moo = fopen(libtest_arg2, ""wb"");
-6.     if(moo) {
-5.       fprintf(moo, ""CL %.0f\n"", content_length);
-4.       fclose(moo);
-3.     }
-2.   }
-1. test_cleanup:

/*always cleanup*/

1.   curl_easy_cleanup(curl);
2.   curl_global_cleanup();
3.   return res;
4. }",Not Useful,1
/*Total bytes curl wants*/,"-5. #include ""test.h""
-4. #include ""memdebug.h""
-3. static char data [] = ""Hello Cloud!\n"";
-2. static size_t read_callback(char *ptr, size_t size, size_t nmemb, void *stream)
-1. {

/*Total bytes curl wants*/

1.   if(amount < strlen(data)) {
2.     return strlen(data);
3.   }
4.   (void)stream;
5.   memcpy(ptr, data, strlen(data));
6.   return strlen(data);
7. }
8. int test(char *URL)
9. {
10.   CURL *curl = NULL;",Not Useful,0
/*the smallest!*/,"-10.     return TEST_ERR_MAJOR_BAD;
-9.   }
-8.   curl = curl_easy_init();
-7.   if(!curl) {
-6.     fprintf(stderr, ""curl_easy_init() failed\n"");
-5.     curl_global_cleanup();
-4.     return TEST_ERR_MAJOR_BAD;
-3.   }
-2.   test_setopt(curl, CURLOPT_URL, URL);
-1.   test_setopt(curl, CURLOPT_HEADER, 1L);

/*the smallest!*/

1.   res = curl_easy_perform(curl);
2. test_cleanup:
3.   curl_easy_cleanup(curl);
4.   curl_global_cleanup();
5.   return (int)res;
6. }",Not Useful,0
/*done*/,"-10.     multi_add_handle(m, curl[i]);
-9.     for(;;) {
-8.       struct timeval interval;
-7.       fd_set rd, wr, exc;
-6.       int maxfd = -99;
-5.       interval.tv_sec = 1;
-4.       interval.tv_usec = 0;
-3.       multi_perform(m, &running);
-2.       abort_on_test_timeout();
-1.       if(!running)

/*done*/

1.       FD_ZERO(&rd);
2.       FD_ZERO(&wr);
3.       FD_ZERO(&exc);
4.       multi_fdset(m, &rd, &wr, &exc, &maxfd);",Not Useful,1
/*Generate our SPN*/,"-4.     Curl_auth_cleanup_spnego(nego);
-3.     return CURLE_LOGIN_DENIED;
-2.   }
-1.   if(!nego->spn) {

/*Generate our SPN*/

1.     char *spn = Curl_auth_build_spn(service, NULL, host);
2.     if(!spn)
3.       return CURLE_OUT_OF_MEMORY;",Not Useful,1
/*Populate the SPN structure*/,"-3.     char *spn = Curl_auth_build_spn(service, NULL, host);
-2.     if(!spn)
-1.       return CURLE_OUT_OF_MEMORY;

/*Populate the SPN structure*/

1.     spn_token.value = spn;
2.     spn_token.length = strlen(spn);",Not Useful,1
/*Import the SPN*/,"-2.     spn_token.value = spn;
-1.     spn_token.length = strlen(spn);

/*Import the SPN*/

1.     major_status = gss_import_name(&minor_status, &spn_token,
2.                                    GSS_C_NT_HOSTBASED_SERVICE,
3.                                    &nego->spn);
4.     if(GSS_ERROR(major_status)) {
5.       Curl_gss_log_error(data, ""gss_import_name() failed: "",
6.                          major_status, minor_status);
7.       free(spn);
8.       return CURLE_AUTH_ERROR;
9.     }
10.     free(spn);",Not Useful,1
"/*Setup the challenge ""input"" security buffer*/","-4.     if(!chlg) {
-3.       infof(data, ""SPNEGO handshake failure (empty challenge message)"");
-2.       return CURLE_BAD_CONTENT_ENCODING;
-1.     }

/*Setup the challenge ""input"" security buffer*/

1.     input_token.value = chlg;
2.     input_token.length = chlglen;
3.   }",Not Useful,1
/*Free our security context*/,"-10.  * This is used to clean up the SPNEGO (Negotiate) specific data.
-9.  *
-8.  * Parameters:
-7.  *
-6.  * nego     [in/out] - The Negotiate data struct being cleaned up.
-5.  *
-4.  */
-3. void Curl_auth_cleanup_spnego(struct negotiatedata *nego)
-2. {
-1.   OM_uint32 minor_status;

/*Free our security context*/

1.   if(nego->context != GSS_C_NO_CONTEXT) {
2.     gss_delete_sec_context(&minor_status, &nego->context, GSS_C_NO_BUFFER);
3.     nego->context = GSS_C_NO_CONTEXT;
4.   }",Not Useful,0
/*Free the output token*/,"-4.   if(nego->context != GSS_C_NO_CONTEXT) {
-3.     gss_delete_sec_context(&minor_status, &nego->context, GSS_C_NO_BUFFER);
-2.     nego->context = GSS_C_NO_CONTEXT;
-1.   }

/*Free the output token*/

1.   if(nego->output_token.value) {
2.     gss_release_buffer(&minor_status, &nego->output_token);
3.     nego->output_token.value = NULL;
4.     nego->output_token.length = 0;
5.   }",Not Useful,1
/*Free the SPN*/,"-5.   if(nego->output_token.value) {
-4.     gss_release_buffer(&minor_status, &nego->output_token);
-3.     nego->output_token.value = NULL;
-2.     nego->output_token.length = 0;
-1.   }

/*Free the SPN*/

1.   if(nego->spn != GSS_C_NO_NAME) {
2.     gss_release_name(&minor_status, &nego->spn);
3.     nego->spn = GSS_C_NO_NAME;
4.   }",Not Useful,1
/*Query the security package for Negotiate*/,"-10.  * This is used to evaluate if SPNEGO (Negotiate) is supported.
-9.  *
-8.  * Parameters: None
-7.  *
-6.  * Returns TRUE if Negotiate is supported by Windows SSPI.
-5.  */
-4. bool Curl_auth_is_spnego_supported(void)
-3. {
-2.   PSecPkgInfo SecurityPackage;
-1.   SECURITY_STATUS status;

/*Query the security package for Negotiate*/

1.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *)
2.                                               TEXT(SP_NAME_NEGOTIATE),
3.                                               &SecurityPackage);",Not Useful,1
/*Query the security package for Negotiate*/,"-10.  * This is used to evaluate if SPNEGO (Negotiate) is supported.
-9.  *
-8.  * Parameters: None
-7.  *
-6.  * Returns TRUE if Negotiate is supported by Windows SSPI.
-5.  */
-4. bool Curl_auth_is_spnego_supported(void)
-3. {
-2.   PSecPkgInfo SecurityPackage;
-1.   SECURITY_STATUS status;

/*Query the security package for Negotiate*/

1.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *)
2.                                               TEXT(SP_NAME_NEGOTIATE),
3.                                               &SecurityPackage);",Not Useful,0
/*Do we have credentials to use or are we using single sign-on?*/,"-5.     nego->output_token = malloc(nego->token_max);
-4.     if(!nego->output_token)
-3.       return CURLE_OUT_OF_MEMORY;
-2.  }
-1.   if(!nego->credentials) {

/*Do we have credentials to use or are we using single sign-on?*/

1.     if(user && *user) {",Not Useful,1
/*Allow proper cleanup of the identity structure*/,"-3.       result = Curl_create_sspi_identity(user, password, &nego->identity);
-2.       if(result)
-1.         return result;

/*Allow proper cleanup of the identity structure*/

1.       nego->p_identity = &nego->identity;
2.     }
3.     else",Not Useful,1
/*Acquire our credentials handle*/,"-3.     nego->credentials = calloc(1, sizeof(CredHandle));
-2.     if(!nego->credentials)
-1.       return CURLE_OUT_OF_MEMORY;

/*Acquire our credentials handle*/

1.     nego->status =
2.       s_pSecFn->AcquireCredentialsHandle(NULL,
3.                                          (TCHAR *)TEXT(SP_NAME_NEGOTIATE),
4.                                          SECPKG_CRED_OUTBOUND, NULL,
5.                                          nego->p_identity, NULL, NULL,
6.                                          nego->credentials, &expiry);
7.     if(nego->status != SEC_E_OK)
8.       return CURLE_AUTH_ERROR;",Not Useful,1
/*Base64 encode the already generated response*/,"-10.  * nego        [in/out] - The Negotiate data struct being used and modified.
-9.  * outptr      [in/out] - The address where a pointer to newly allocated memory
-8.  *                        holding the result will be stored upon completion.
-7.  * outlen      [out]    - The length of the output message.
-6.  *
-5.  * Returns CURLE_OK on success.
-4.  */
-3. CURLcode Curl_auth_create_spnego_message(struct negotiatedata *nego,
-2.                                          char **outptr, size_t *outlen)
-1. {

/*Base64 encode the already generated response*/

1.   CURLcode result = Curl_base64_encode((const char *) nego->output_token,
2.                                        nego->output_token_length, outptr,
3.                                        outlen);
4.   if(!result && (!*outptr || !*outlen)) {
5.     free(*outptr);
6.     result = CURLE_REMOTE_ACCESS_DENIED;
7.   }
8.   return result;
9. }
10. /*",Not Useful,1
/*Free our security context*/,"-10.  *
-9.  * This is used to clean up the SPNEGO (Negotiate) specific data.
-8.  *
-7.  * Parameters:
-6.  *
-5.  * nego     [in/out] - The Negotiate data struct being cleaned up.
-4.  *
-3.  */
-2. void Curl_auth_cleanup_spnego(struct negotiatedata *nego)
-1. {

/*Free our security context*/

1.   if(nego->context) {
2.     s_pSecFn->DeleteSecurityContext(nego->context);
3.     free(nego->context);
4.     nego->context = NULL;
5.   }",Not Useful,1
/*Free our credentials handle*/,"-5.   if(nego->context) {
-4.     s_pSecFn->DeleteSecurityContext(nego->context);
-3.     free(nego->context);
-2.     nego->context = NULL;
-1.   }

/*Free our credentials handle*/

1.   if(nego->credentials) {
2.     s_pSecFn->FreeCredentialsHandle(nego->credentials);
3.     free(nego->credentials);
4.     nego->credentials = NULL;
5.   }",Not Useful,1
/*Free our identity*/,"-5.   if(nego->credentials) {
-4.     s_pSecFn->FreeCredentialsHandle(nego->credentials);
-3.     free(nego->credentials);
-2.     nego->credentials = NULL;
-1.   }

/*Free our identity*/

1.   Curl_sspi_free_identity(nego->p_identity);
2.   nego->p_identity = NULL;",Not Useful,1
/*Free the SPN and output token*/,"-2.   Curl_sspi_free_identity(nego->p_identity);
-1.   nego->p_identity = NULL;

/*Free the SPN and output token*/

1.   Curl_safefree(nego->spn);
2.   Curl_safefree(nego->output_token);",Not Useful,1
/*HAVE_BASENAME*/,"
#ifndef HAVE_BASENAME



/*HAVE_BASENAME*/

1. char *tool_basename(char *path)
2. {
3.   char *s1;
4.   char *s2;
5.   s1 = strrchr(path, '/');
6.   s2 = strrchr(path, '\\');
7.   if(s1 && s2) {
8.     path = (s1 > s2) ? s1 + 1 : s2 + 1;
9.   }
10.   else if(s1)",Not Useful,1
/*HAVE_MEMRCHR*/,"-1. #include ""memdebug.h""
#ifndef HAVE_MEMRCHR

/*HAVE_MEMRCHR*/

111",Not Useful,0
/*Finalise the digest*/,"-3.   if(Curl_bufref_len(chlg))
-2.     Curl_HMAC_update(ctxt, Curl_bufref_ptr(chlg),
-1.                      curlx_uztoui(Curl_bufref_len(chlg)));

/*Finalise the digest*/

1.   Curl_HMAC_final(ctxt, digest);",Not Useful,0
/*Generate the response*/,"-1.   Curl_HMAC_final(ctxt, digest);

/*Generate the response*/

1.   response = aprintf(
2.     ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
3.     userp, digest[0], digest[1], digest[2], digest[3], digest[4],
4.     digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
5.     digest[11], digest[12], digest[13], digest[14], digest[15]);
6.   if(!response)
7.     return CURLE_OUT_OF_MEMORY;
8.   Curl_bufref_set(out, response, strlen(response), curl_free);
9.   return CURLE_OK;
10. }",Not Useful,0
/*Query the security package for Digest*/,"-10. * This is used to evaluate if DIGEST is supported.
-9. *
-8. * Parameters: None
-7. *
-6. * Returns TRUE if DIGEST is supported by Windows SSPI.
-5. */
-4. bool Curl_auth_is_digest_supported(void)
-3. {
-2.   PSecPkgInfo SecurityPackage;
-1.   SECURITY_STATUS status;

/*Query the security package for Digest*/

1.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_DIGEST),
2.                                               &SecurityPackage);",Not Useful,0
/*Query the security package for DigestSSP*/,"-4.   if(!Curl_bufref_len(chlg)) {
-3.     infof(data, ""DIGEST-MD5 handshake failure (empty challenge message)"");
-2.     return CURLE_BAD_CONTENT_ENCODING;
-1.   }

/*Query the security package for DigestSSP*/

1.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_DIGEST),
2.                                               &SecurityPackage);
3.   if(status != SEC_E_OK) {
4.     failf(data, ""SSPI: couldn't get auth info"");
5.     return CURLE_AUTH_ERROR;
6.   }
7.   token_max = SecurityPackage->cbMaxToken;",Not Useful,1
/*Allow proper cleanup of the identity structure*/,"-6.     result = Curl_create_sspi_identity(userp, passwdp, &identity);
-5.     if(result) {
-4.       free(spn);
-3.       free(output_token);
-2.       return result;
-1.     }

/*Allow proper cleanup of the identity structure*/

1.     p_identity = &identity;
2.   }
3.   else",Not Useful,1
/*Acquire our credentials handle*/,"-1.     p_identity = NULL;

/*Acquire our credentials handle*/

1.   status = s_pSecFn->AcquireCredentialsHandle(NULL,
2.                                               (TCHAR *) TEXT(SP_NAME_DIGEST),
3.                                               SECPKG_CRED_OUTBOUND, NULL,
4.                                               p_identity, NULL, NULL,
5.                                               &credentials, &expiry);
6.   if(status != SEC_E_OK) {
7.     Curl_sspi_free_identity(p_identity);
8.     free(spn);
9.     free(output_token);
10.     return CURLE_LOGIN_DENIED;",Not Useful,0
/*Free our handles*/,"-1.   Curl_bufref_set(out, output_token, resp_buf.cbBuffer, curl_free);

/*Free our handles*/

1.   s_pSecFn->DeleteSecurityContext(&context);
2.   s_pSecFn->FreeCredentialsHandle(&credentials);",Not Useful,1
/*Free the identity structure*/,"-2.   s_pSecFn->DeleteSecurityContext(&context);
-1.   s_pSecFn->FreeCredentialsHandle(&credentials);

/*Free the identity structure*/

1.   Curl_sspi_free_identity(p_identity);",Not Useful,0
/*Free the SPN*/,"-1.   Curl_sspi_free_identity(p_identity);

/*Free the SPN*/

1.   free(spn);
2.   return result;
3. }
4. /*
5.  * Curl_override_sspi_http_realm()
6.  *
7.  * This is used to populate the domain in a SSPI identity structure
8.  * The realm is extracted from the challenge message and used as the
9.  * domain if it is not already explicitly set.
10.  *",Not Useful,1
"/*If domain is blank or unset, check challenge message for realm*/","-10.  *
-9.  * chlg     [in]     - The challenge message.
-8.  * identity [in/out] - The identity structure.
-7.  *
-6.  * Returns CURLE_OK on success.
-5.  */
-4. CURLcode Curl_override_sspi_http_realm(const char *chlg,
-3.                                        SEC_WINNT_AUTH_IDENTITY *identity)
-2. {
-1.   xcharp_u domain, dup_domain;

/*If domain is blank or unset, check challenge message for realm*/

1.   if(!identity->Domain || !identity->DomainLength) {
2.     for(;;) {
3.       char value[DIGEST_MAX_VALUE_LENGTH];
4.       char content[DIGEST_MAX_CONTENT_LENGTH];",Not Useful,1
/*Pass all additional spaces here*/,"-4.   if(!identity->Domain || !identity->DomainLength) {
-3.     for(;;) {
-2.       char value[DIGEST_MAX_VALUE_LENGTH];
-1.       char content[DIGEST_MAX_CONTENT_LENGTH];

/*Pass all additional spaces here*/

1.       while(*chlg && ISSPACE(*chlg))
2.         chlg++;",Not Useful,1
/*Pass all additional spaces here*/,"-4.   if(!identity->Domain || !identity->DomainLength) {
-3.     for(;;) {
-2.       char value[DIGEST_MAX_VALUE_LENGTH];
-1.       char content[DIGEST_MAX_CONTENT_LENGTH];

/*Pass all additional spaces here*/

1.       while(*chlg && ISSPACE(*chlg))
2.         chlg++;",Not Useful,0
"/*We had an input token before so if there's another one now that means we
     provided bad credentials in the previous request or it's stale.*/","-10.  *
-9.  * chlg    [in]     - The challenge message.
-8.  * digest  [in/out] - The digest data struct being used and modified.
-7.  *
-6.  * Returns CURLE_OK on success.
-5.  */
-4. CURLcode Curl_auth_decode_digest_http_message(const char *chlg,
-3.                                               struct digestdata *digest)
-2. {
-1.   size_t chlglen = strlen(chlg);

/*We had an input token before so if there's another one now that means we
     provided bad credentials in the previous request or it's stale.*/

1.   if(digest->input_token) {
2.     bool stale = false;
3.     const char *p = chlg;",Not Useful,0
/*Check for the 'stale' directive*/,"-3.   if(digest->input_token) {
-2.     bool stale = false;
-1.     const char *p = chlg;

/*Check for the 'stale' directive*/

1.     for(;;) {
2.       char value[DIGEST_MAX_VALUE_LENGTH];
3.       char content[DIGEST_MAX_CONTENT_LENGTH];
4.       while(*p && ISSPACE(*p))
5.         p++;
6.       if(!Curl_auth_digest_get_pair(p, value, content, &p))
7.         break;
8.       if(strcasecompare(value, ""stale"") &&
9.          strcasecompare(content, ""true"")) {
10.         stale = true;",Not Useful,1
/*Query the security package for DigestSSP*/,"-4.   if(!Curl_bufref_len(chlg)) {
-3.     infof(data, ""DIGEST-MD5 handshake failure (empty challenge message)"");
-2.     return CURLE_BAD_CONTENT_ENCODING;
-1.   }

/*Query the security package for DigestSSP*/

1.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_DIGEST),
2.                                               &SecurityPackage);
3.   if(status != SEC_E_OK) {
4.     failf(data, ""SSPI: couldn't get auth info"");
5.     return CURLE_AUTH_ERROR;
6.   }
7.   token_max = SecurityPackage->cbMaxToken;",Not Useful,1
"/*If the user/passwd that was used to make the identity for http_context
     has changed then delete that context.*/","-4.   output_token = malloc(token_max);
-3.   if(!output_token) {
-2.     return CURLE_OUT_OF_MEMORY;
-1.   }

/*If the user/passwd that was used to make the identity for http_context
     has changed then delete that context.*/

1.   if((userp && !digest->user) || (!userp && digest->user) ||
2.      (passwdp && !digest->passwd) || (!passwdp && digest->passwd) ||
3.      (userp && digest->user && strcmp(userp, digest->user)) ||
4.      (passwdp && digest->passwd && strcmp(passwdp, digest->passwd))) {
5.     if(digest->http_context) {
6.       s_pSecFn->DeleteSecurityContext(digest->http_context);
7.       Curl_safefree(digest->http_context);
8.     }
9.     Curl_safefree(digest->user);
10.     Curl_safefree(digest->passwd);",Not Useful,1
/*free the copy of user/passwd used to make the previous identity*/,"-1.     TCHAR *spn;

/*free the copy of user/passwd used to make the previous identity*/

1.     Curl_safefree(digest->user);
2.     Curl_safefree(digest->passwd);
3.     if(userp && *userp) {",Not Useful,0
/*Allow proper cleanup of the identity structure*/,"-6.     result = Curl_create_sspi_identity(userp, passwdp, &identity);
-5.     if(result) {
-4.       free(spn);
-3.       free(output_token);
-2.       return result;
-1.     }

/*Allow proper cleanup of the identity structure*/

1.     p_identity = &identity;
2.   }
3.   else",Not Useful,1
/*Acquire our credentials handle*/,"-1.     p_identity = NULL;

/*Acquire our credentials handle*/

1.   status = s_pSecFn->AcquireCredentialsHandle(NULL,
2.                                               (TCHAR *) TEXT(SP_NAME_DIGEST),
3.                                               SECPKG_CRED_OUTBOUND, NULL,
4.                                               p_identity, NULL, NULL,
5.                                               &credentials, &expiry);
6.   if(status != SEC_E_OK) {
7.     Curl_sspi_free_identity(p_identity);
8.     free(spn);
9.     free(output_token);
10.     return CURLE_LOGIN_DENIED;",Not Useful,1
/*Copy the generated response*/,"-10.     }
-9.     output_token_len = resp_buf.cbBuffer;
-8.     s_pSecFn->FreeCredentialsHandle(&credentials);
-7.     Curl_sspi_free_identity(p_identity);
-6.   }
-5.   resp = malloc(output_token_len + 1);
-4.   if(!resp) {
-3.     free(output_token);
-2.     return CURLE_OUT_OF_MEMORY;
-1.   }

/*Copy the generated response*/

1.   memcpy(resp, output_token, output_token_len);
2.   resp[output_token_len] = 0;",Not Useful,1
/*Free the input token*/,"-10.  *
-9.  * This is used to clean up the digest specific data.
-8.  *
-7.  * Parameters:
-6.  *
-5.  * digest    [in/out] - The digest data struct being cleaned up.
-4.  *
-3.  */
-2. void Curl_auth_digest_cleanup(struct digestdata *digest)
-1. {

/*Free the input token*/

1.   Curl_safefree(digest->input_token);",Not Useful,0
/*Delete security context*/,"-1.   digest->input_token_len = 0;

/*Delete security context*/

1.   if(digest->http_context) {
2.     s_pSecFn->DeleteSecurityContext(digest->http_context);
3.     Curl_safefree(digest->http_context);
4.   }",Not Useful,1
/*Free the copy of user/passwd used to make the identity for http_context*/,"-4.   if(digest->http_context) {
-3.     s_pSecFn->DeleteSecurityContext(digest->http_context);
-2.     Curl_safefree(digest->http_context);
-1.   }

/*Free the copy of user/passwd used to make the identity for http_context*/

1.   Curl_safefree(digest->user);
2.   Curl_safefree(digest->passwd);
3. }",Not Useful,1
/*move finfo pointers to b_data*/,"-10. static CURLcode ftp_pl_insert_finfo(struct Curl_easy *data,
-9.                                     struct fileinfo *infop)
-8. {
-7.   curl_fnmatch_callback compare;
-6.   struct WildcardData *wc = &data->wildcard;
-5.   struct ftp_wc *ftpwc = wc->protdata;
-4.   struct Curl_llist *llist = &wc->filelist;
-3.   struct ftp_parselist_data *parser = ftpwc->parser;
-2.   bool add = TRUE;
-1.   struct curl_fileinfo *finfo = &infop->info;

/*move finfo pointers to b_data*/

1.   char *str = finfo->b_data;
2.   finfo->filename       = str + parser->offsets.filename;
3.   finfo->strings.group  = parser->offsets.group ?
4.                           str + parser->offsets.group : NULL;
5.   finfo->strings.perm   = parser->offsets.perm ?
6.                           str + parser->offsets.perm : NULL;
7.   finfo->strings.target = parser->offsets.symlink_target ?
8.                           str + parser->offsets.symlink_target : NULL;
9.   finfo->strings.time   = str + parser->offsets.time;
10.   finfo->strings.user   = parser->offsets.user ?",Not Useful,0
/*get correct fnmatch callback*/,"-10.   finfo->filename       = str + parser->offsets.filename;
-9.   finfo->strings.group  = parser->offsets.group ?
-8.                           str + parser->offsets.group : NULL;
-7.   finfo->strings.perm   = parser->offsets.perm ?
-6.                           str + parser->offsets.perm : NULL;
-5.   finfo->strings.target = parser->offsets.symlink_target ?
-4.                           str + parser->offsets.symlink_target : NULL;
-3.   finfo->strings.time   = str + parser->offsets.time;
-2.   finfo->strings.user   = parser->offsets.user ?
-1.                           str + parser->offsets.user : NULL;

/*get correct fnmatch callback*/

1.   compare = data->set.fnmatch;
2.   if(!compare)
3.     compare = Curl_fnmatch;",Not Useful,1
/*filter pattern-corresponding filenames*/,"-3.   compare = data->set.fnmatch;
-2.   if(!compare)
-1.     compare = Curl_fnmatch;

/*filter pattern-corresponding filenames*/

1.   Curl_set_in_callback(data, true);
2.   if(compare(data->set.fnmatch_data, wc->pattern,
3.              finfo->filename) == 0) {",Not Useful,1
/*error in previous call*/,"-10. {
-9.   size_t bufflen = size*nmemb;
-8.   struct Curl_easy *data = (struct Curl_easy *)connptr;
-7.   struct ftp_wc *ftpwc = data->wildcard.protdata;
-6.   struct ftp_parselist_data *parser = ftpwc->parser;
-5.   struct fileinfo *infop;
-4.   struct curl_fileinfo *finfo;
-3.   unsigned long i = 0;
-2.   CURLcode result;
-1.   size_t retsize = bufflen;

/*error in previous call*/

111",Not Useful,1
/*tmp file data is not allocated yet*/,"-1.     char c = buffer[i];

/*tmp file data is not allocated yet*/

1.       parser->file_data = Curl_fileinfo_alloc();
2.       if(!parser->file_data) {
3.         parser->error = CURLE_OUT_OF_MEMORY;
4.         goto fail;
5.       }
6.       parser->file_data->info.b_data = malloc(FTP_BUFFER_ALLOCSIZE);
7.       if(!parser->file_data->info.b_data) {
8.         parser->error = CURLE_OUT_OF_MEMORY;
9.         goto fail;
10.       }",Not Useful,1
/*correct file type*/,"-10.               finfo->size = 0;
-9.             }
-8.             else {
-7.               char *endptr;
-6.               if(curlx_strtoofft(finfo->b_data +
-5.                                  parser->item_offset,
-4.                                  &endptr, 10, &finfo->size)) {
-3.                 parser->error = CURLE_FTP_BAD_FILE_LIST;
-2.                 goto fail;
-1.               }

/*correct file type*/

1.               parser->file_data->info.filetype = CURLFILETYPE_FILE;
2.             }
3.             parser->file_data->info.flags |= CURLFINFOFLAG_KNOWN_SIZE;
4.             parser->item_length = 0;
5.             parser->state.NT.main = PL_WINNT_FILENAME;
6.             parser->state.NT.sub.filename = PL_WINNT_FILENAME_PRESPACE;
7.           }
8.           break;
9.         }
10.         break;",Not Useful,1
/*CURL_DISABLE_FTP*/,"-10.  * 2) Unix version 2
-9.  * drwxr-xr-x 1 user01 ftp  512 Jan 29 1997  prog
-8.  * 3) Unix version 3
-7.  * drwxr-xr-x 1      1   1  512 Jan 29 23:32 prog
-6.  * 4) Unix symlink
-5.  * lrwxr-xr-x 1 user01 ftp  512 Jan 29 23:32 prog -> prog2000
-4.  * 5) DOS style
-3.  * 01-29-97 11:32PM <DIR> prog
-2.  */
-1. #include ""curl_setup.h""
#ifndef CURL_DISABLE_FTP

/*CURL_DISABLE_FTP*/

1. #include <curl/curl.h>
2. #include ""urldata.h""
3. #include ""fileinfo.h""
4. #include ""llist.h""
5. #include ""strtoofft.h""
6. #include ""ftp.h""
7. #include ""ftplistparser.h""
8. #include ""curl_fnmatch.h""
9. #include ""curl_memory.h""
10. #include ""multiif.h""",Not Useful,1
/*Query the security package for NTLM*/,"-10.  * This is used to evaluate if NTLM is supported.
-9.  *
-8.  * Parameters: None
-7.  *
-6.  * Returns TRUE if NTLM is supported by Windows SSPI.
-5.  */
-4. bool Curl_auth_is_ntlm_supported(void)
-3. {
-2.   PSecPkgInfo SecurityPackage;
-1.   SECURITY_STATUS status;

/*Query the security package for NTLM*/

1.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_NTLM),
2.                                               &SecurityPackage);",Not Useful,0
/*Query the security package for NTLM*/,"-10.  * This is used to evaluate if NTLM is supported.
-9.  *
-8.  * Parameters: None
-7.  *
-6.  * Returns TRUE if NTLM is supported by Windows SSPI.
-5.  */
-4. bool Curl_auth_is_ntlm_supported(void)
-3. {
-2.   PSecPkgInfo SecurityPackage;
-1.   SECURITY_STATUS status;

/*Query the security package for NTLM*/

1.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_NTLM),
2.                                               &SecurityPackage);",Not Useful,1
/*Populate our identity structure*/,"-5.   ntlm->output_token = malloc(ntlm->token_max);
-4.   if(!ntlm->output_token)
-3.     return CURLE_OUT_OF_MEMORY;
-2.   if(userp && *userp) {
-1.     CURLcode result;

/*Populate our identity structure*/

1.     result = Curl_create_sspi_identity(userp, passwdp, &ntlm->identity);
2.     if(result)
3.       return result;",Not Useful,0
/*Allow proper cleanup of the identity structure*/,"-3.     result = Curl_create_sspi_identity(userp, passwdp, &ntlm->identity);
-2.     if(result)
-1.       return result;

/*Allow proper cleanup of the identity structure*/

1.     ntlm->p_identity = &ntlm->identity;
2.   }
3.   else",Not Useful,1
/*Acquire our credentials handle*/,"-3.   ntlm->credentials = calloc(1, sizeof(CredHandle));
-2.   if(!ntlm->credentials)
-1.     return CURLE_OUT_OF_MEMORY;

/*Acquire our credentials handle*/

1.   status = s_pSecFn->AcquireCredentialsHandle(NULL,
2.                                               (TCHAR *) TEXT(SP_NAME_NTLM),
3.                                               SECPKG_CRED_OUTBOUND, NULL,
4.                                               ntlm->p_identity, NULL, NULL,
5.                                               ntlm->credentials, &expiry);
6.   if(status != SEC_E_OK)
7.     return CURLE_LOGIN_DENIED;",Not Useful,1
/*Free our credentials handle*/,"-5.   if(ntlm->context) {
-4.     s_pSecFn->DeleteSecurityContext(ntlm->context);
-3.     free(ntlm->context);
-2.     ntlm->context = NULL;
-1.   }

/*Free our credentials handle*/

1.   if(ntlm->credentials) {
2.     s_pSecFn->FreeCredentialsHandle(ntlm->credentials);
3.     free(ntlm->credentials);
4.     ntlm->credentials = NULL;
5.   }",Not Useful,1
/*Free our identity*/,"-5.   if(ntlm->credentials) {
-4.     s_pSecFn->FreeCredentialsHandle(ntlm->credentials);
-3.     free(ntlm->credentials);
-2.     ntlm->credentials = NULL;
-1.   }

/*Free our identity*/

1.   Curl_sspi_free_identity(ntlm->p_identity);
2.   ntlm->p_identity = NULL;",Not Useful,1
/*Free the input and output tokens*/,"-2.   Curl_sspi_free_identity(ntlm->p_identity);
-1.   ntlm->p_identity = NULL;

/*Free the input and output tokens*/

1.   Curl_safefree(ntlm->input_token);
2.   Curl_safefree(ntlm->output_token);",Not Useful,1
/*we have got more than the expected total!*/,"-9.   bar->calls++;
-8.   if((total > 0) && (point != bar->prev)) {
-7.     char line[MAX_BARLENGTH + 1];
-6.     char format[40];
-5.     double frac;
-4.     double percent;
-3.     int barwidth;
-2.     int num;
-1.     if(point > total)

/*we have got more than the expected total!*/

1.       total = point;
2.     frac = (double)point / (double)total;
3.     percent = frac * 100.0;
4.     barwidth = bar->width - 7;
5.     num = (int) (((double)barwidth) * frac);
6.     if(num > MAX_BARLENGTH)
7.       num = MAX_BARLENGTH;
8.     memset(line, '#', num);
9.     line[num] = '\0';
10.     msnprintf(format, sizeof(format), ""\r%%-%ds %%5.1f%%%%"", barwidth);",Not Useful,0
/*TIOCGSIZE*/,"-10.   if(colp) {
-9.     char *endptr;
-8.     long num = strtol(colp, &endptr, 10);
-7.     if((endptr != colp) && (endptr == colp + strlen(colp)) && (num > 20) &&
-6.        (num < 10000))
-5.       bar->width = (int)num;
-4.     curl_free(colp);
-3.   }
-2.   if(!bar->width) {
-1.     int cols = 0;
#ifdef TIOCGSIZE

/*TIOCGSIZE*/

1.     struct ttysize ts;
2.     if(!ioctl(STDIN_FILENO, TIOCGSIZE, &ts))
3.       cols = ts.ts_cols;
4. #elif defined(TIOCGWINSZ)
5.     struct winsize ts;
6.     if(!ioctl(STDIN_FILENO, TIOCGWINSZ, &ts))
7.       cols = ts.ws_col;
8. #elif defined(WIN32)
9.     {
10.       HANDLE  stderr_hnd = GetStdHandle(STD_ERROR_HANDLE);",Not Useful,1
/*download*/,"-10.       Curl_safefree(node->infile);
-9.       Curl_safefree(node);
-8.       node = next;
-7.     }
-6.     config->url_list = NULL;
-5.   }
-4. }
-3. bool output_expected(const char *url, const char *uploadfile)
-2. {
-1.   if(!uploadfile)

/*download*/

111",Not Useful,1
"/*"", url) || checkprefix(""https://"", url))*/","-10.       Curl_safefree(node);
-9.       node = next;
-8.     }
-7.     config->url_list = NULL;
-6.   }
-5. }
-4. bool output_expected(const char *url, const char *uploadfile)
-3. {
-2.   if(!uploadfile)

/*"", url) || checkprefix(""https://"", url))*/

111",Not Useful,1
/*HTTP(S) upload*/,"-10.       node = next;
-9.     }
-8.     config->url_list = NULL;
-7.   }
-6. }
-5. bool output_expected(const char *url, const char *uploadfile)
-4. {
-3.   if(!uploadfile)

/*HTTP(S) upload*/

111",Not Useful,1
"/*"");*/","-3. char *add_file_name_to_url(char *url, const char *filename)
-2. {

/*"");*/

111",Not Useful,1
/*Curl's timer has elapsed.*/,"-3.     checkFdSet(m, &sockets.read, &readSet, CURL_CSELECT_IN, ""read"");
-2.     checkFdSet(m, &sockets.write, &writeSet, CURL_CSELECT_OUT, ""write"");
-1.     if(timeout.tv_sec != -1 && getMicroSecondTimeout(&timeout) == 0) {

/*Curl's timer has elapsed.*/

1.       notifyCurl(m, CURL_SOCKET_TIMEOUT, 0, ""timeout"");
2.     }
3.     abort_on_test_timeout();
4.   }
5.   if(!success) {
6.     fprintf(stderr, ""Error uploading file.\n"");
7.     res = TEST_ERR_MAJOR_BAD;
8.   }
9. test_cleanup:",Not Useful,0
/*close the local file*/,"-4.   curl_multi_remove_handle(m, curl);
-3.   curl_easy_cleanup(curl);
-2.   curl_multi_cleanup(m);
-1.   curl_global_cleanup();

/*close the local file*/

1.   fclose(hd_src);",Not Useful,0
/*free local memory*/,"-1.   fclose(hd_src);

/*free local memory*/

1.   free(sockets.read.sockets);
2.   free(sockets.write.sockets);
3.   return res;
4. }",Not Useful,0
/*32 bytes/256 bits*/,"-10.                   const char *passwdp,
-9.                   const unsigned char *request,
-8.                   const unsigned char *uripath,
-7.                   struct digestdata *digest,
-6.                   char **outptr, size_t *outlen,
-5.                   void (*convert_to_ascii)(unsigned char *, unsigned char *),
-4.                   CURLcode (*hash)(unsigned char *, const unsigned char *,
-3.                                    const size_t))
-2. {
-1.   CURLcode result;

/*32 bytes/256 bits*/

1.   unsigned char request_digest[65];",Not Useful,1
/*64 digits and 1 zero byte*/,"-1.   unsigned char request_digest[65];

/*64 digits and 1 zero byte*/

111",Not Useful,1
/*64 digits and 1 zero byte*/,"-1.   unsigned char request_digest[65];

/*64 digits and 1 zero byte*/

111",Not Useful,1
/*nonce and cnonce are OUTSIDE the hash*/,"-10.   */
-9.   hashthis = aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
-8.   if(!hashthis)
-7.     return CURLE_OUT_OF_MEMORY;
-6.   hash(hashbuf, (unsigned char *) hashthis, strlen(hashthis));
-5.   free(hashthis);
-4.   convert_to_ascii(hashbuf, ha1);
-3.   if(digest->algo == CURLDIGESTALGO_MD5SESS ||
-2.      digest->algo == CURLDIGESTALGO_SHA256SESS ||
-1.      digest->algo == CURLDIGESTALGO_SHA512_256SESS) {

/*nonce and cnonce are OUTSIDE the hash*/

1.     tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
2.     if(!tmp)
3.       return CURLE_OUT_OF_MEMORY;
4.     hash(hashbuf, (unsigned char *) tmp, strlen(tmp));
5.     free(tmp);
6.     convert_to_ascii(hashbuf, ha1);
7.   }
8.   /*
9.     If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:
10.       A2 = Method "":"" digest-uri-value",Not Useful,1
/*Append the opaque*/,"-1.   if(digest->opaque) {

/*Append the opaque*/

1.     tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
2.     free(response);
3.     if(!tmp)
4.       return CURLE_OUT_OF_MEMORY;
5.     response = tmp;
6.   }
7.   if(digest->algorithm) {",Not Useful,0
/*Append the algorithm*/,"-7.     tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
-6.     free(response);
-5.     if(!tmp)
-4.       return CURLE_OUT_OF_MEMORY;
-3.     response = tmp;
-2.   }
-1.   if(digest->algorithm) {

/*Append the algorithm*/

1.     tmp = aprintf(""%s, algorithm=%s"", response, digest->algorithm);
2.     free(response);
3.     if(!tmp)
4.       return CURLE_OUT_OF_MEMORY;
5.     response = tmp;
6.   }
7.   if(digest->userhash) {",Not Useful,1
/*Append the userhash*/,"-7.     tmp = aprintf(""%s, algorithm=%s"", response, digest->algorithm);
-6.     free(response);
-5.     if(!tmp)
-4.       return CURLE_OUT_OF_MEMORY;
-3.     response = tmp;
-2.   }
-1.   if(digest->userhash) {

/*Append the userhash*/

1.     tmp = aprintf(""%s, userhash=true"", response);
2.     free(response);
3.     if(!tmp)
4.       return CURLE_OUT_OF_MEMORY;
5.     response = tmp;
6.   }",Not Useful,0
"/*default means normal, not stale*/","-10. void Curl_auth_digest_cleanup(struct digestdata *digest)
-9. {
-8.   Curl_safefree(digest->nonce);
-7.   Curl_safefree(digest->cnonce);
-6.   Curl_safefree(digest->realm);
-5.   Curl_safefree(digest->opaque);
-4.   Curl_safefree(digest->qop);
-3.   Curl_safefree(digest->algorithm);
-2.   digest->nc = 0;

/*default means normal, not stale*/

1.   digest->userhash = FALSE;
2. }",Not Useful,1
/*!USE_WINDOWS_SSPI*/,"-2.   digest->userhash = FALSE;
-1. }

/*!USE_WINDOWS_SSPI*/

111",Not Useful,0
/*CURL_DISABLE_CRYPTO_AUTH*/,"-10.  * furnished to do so, under the terms of the COPYING file.
-9.  *
-8.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-7.  * KIND, either express or implied.
-6.  *
-5.  * RFC2831 DIGEST-MD5 authentication
-4.  * RFC7616 DIGEST-SHA256, DIGEST-SHA512-256 authentication
-3.  *
-2.  ***************************************************************************/
-1. #include ""curl_setup.h""
#if !defined(CURL_DISABLE_CRYPTO_AUTH)

/*CURL_DISABLE_CRYPTO_AUTH*/

1. #include <curl/curl.h>
2. #include ""vauth/vauth.h""
3. #include ""vauth/digest.h""
4. #include ""urldata.h""
5. #include ""curl_base64.h""
6. #include ""curl_hmac.h""
7. #include ""curl_md5.h""
8. #include ""curl_sha256.h""
9. #include ""vtls/vtls.h""
10. #include ""warnless.h""",Not Useful,1
"/*It is referenced to the home directory, so strip the
         leading '/'*/","-10.       memcpy(real_path, working_path, 1 + working_path_len);
-9.   }
-8.   else if(data->conn->handler->protocol & CURLPROTO_SFTP) {
-7.     if((working_path_len > 1) && (working_path[1] == '~')) {
-6.       size_t homelen = strlen(homedir);
-5.       real_path = malloc(homelen + working_path_len + 1);
-4.       if(!real_path) {
-3.         free(working_path);
-2.         return CURLE_OUT_OF_MEMORY;
-1.       }

/*It is referenced to the home directory, so strip the
         leading '/'*/

1.       memcpy(real_path, homedir, homelen);
2.       real_path[homelen] = '/';
3.       real_path[homelen + 1] = '\0';
4.       if(working_path_len > 3) {
5.         memcpy(real_path + homelen + 1, working_path + 3,
6.                1 + working_path_len -3);
7.       }
8.     }
9.     else {
10.       real_path = malloc(working_path_len + 1);",Not Useful,1
/*Send the LOGOUT command*/,"-2. static CURLcode imap_perform_logout(struct Curl_easy *data)
-1. {

/*Send the LOGOUT command*/

1.   CURLcode result = imap_sendf(data, ""LOGOUT"");
2.   if(!result)
3.     state(data, IMAP_LOGOUT);
4.   return result;
5. }",Not Useful,1
/*no use for this yet*/,"-5. static CURLcode imap_state_servergreet_resp(struct Curl_easy *data,
-4.                                             int imapcode,
-3.                                             imapstate instate)
-2. {
-1.   struct connectdata *conn = data->conn;

/*no use for this yet*/

1.   if(imapcode == IMAP_RESP_PREAUTH) {",Not Useful,1
/*PREAUTH*/,"-5.   PROTOPT_URLOPTIONS
-4. };
-3. #endif
-2. #define IMAP_RESP_OK       1
-1. #define IMAP_RESP_NOT_OK   2
#define IMAP_RESP_PREAUTH  3

/*PREAUTH*/

111",Not Useful,1
/*For CAPABILITY responses*/,"-10.     struct imap_conn *imapc = &conn->proto.imapc;
-9.     imapc->preauth = TRUE;
-8.     infof(data, ""PREAUTH connection, already authenticated"");
-7.   }
-6.   else if(imapcode != IMAP_RESP_OK) {
-5.     failf(data, ""Got unexpected imap-server response"");
-4.     return CURLE_WEIRD_SERVER_REPLY;
-3.   }
-2.   return imap_perform_capability(data, conn);
-1. }

/*For CAPABILITY responses*/

1. static CURLcode imap_state_capability_resp(struct Curl_easy *data,
2.                                            int imapcode,
3.                                            imapstate instate)
4. {
5.   CURLcode result = CURLE_OK;
6.   struct connectdata *conn = data->conn;
7.   struct imap_conn *imapc = &conn->proto.imapc;
8.   const char *line = data->state.buffer;",Not Useful,1
/*no use for this yet*/,"-5. static CURLcode imap_state_servergreet_resp(struct Curl_easy *data,
-4.                                             int imapcode,
-3.                                             imapstate instate)
-2. {
-1.   struct connectdata *conn = data->conn;

/*no use for this yet*/

1.   if(imapcode == IMAP_RESP_PREAUTH) {",Not Useful,1
/*Loop through the data line*/,"-2.   if(imapcode == '*') {
-1.     line += 2;

/*Loop through the data line*/

1.     for(;;) {
2.       size_t wordlen;
3.       while(*line &&
4.             (*line == ' ' || *line == '\t' ||
5.               *line == '\r' || *line == '\n')) {
6.         line++;
7.       }
8.       if(!*line)
9.         break;",Not Useful,0
/*For STARTTLS responses*/,"-10.       result = imap_perform_authentication(data, conn);
-9.     else {
-8.       failf(data, ""STARTTLS not available."");
-7.       result = CURLE_USE_SSL_FAILED;
-6.     }
-5.   }
-4.   else
-3.     result = imap_perform_authentication(data, conn);
-2.   return result;
-1. }

/*For STARTTLS responses*/

1. static CURLcode imap_state_starttls_resp(struct Curl_easy *data,
2.                                          int imapcode,
3.                                          imapstate instate)
4. {
5.   CURLcode result = CURLE_OK;
6.   struct connectdata *conn = data->conn;",Not Useful,0
/*no use for this yet*/,"-5. static CURLcode imap_state_servergreet_resp(struct Curl_easy *data,
-4.                                             int imapcode,
-3.                                             imapstate instate)
-2. {
-1.   struct connectdata *conn = data->conn;

/*no use for this yet*/

1.   if(imapcode == IMAP_RESP_PREAUTH) {",Not Useful,1
/*no use for this yet*/,"-5. static CURLcode imap_state_servergreet_resp(struct Curl_easy *data,
-4.                                             int imapcode,
-3.                                             imapstate instate)
-2. {
-1.   struct connectdata *conn = data->conn;

/*no use for this yet*/

1.   if(imapcode == IMAP_RESP_PREAUTH) {",Not Useful,0
/*Perform clear text authentication*/,"-5.   result = Curl_sasl_start(&imapc->sasl, data, imapc->ir_supported, &progress);
-4.   if(!result) {
-3.     if(progress == SASL_INPROGRESS)
-2.       state(data, IMAP_AUTHENTICATE);
-1.     else if(!imapc->login_disabled && (imapc->preftype & IMAP_TYPE_CLEARTEXT))

/*Perform clear text authentication*/

1.       result = imap_perform_login(data, conn);
2.     else {",Not Useful,1
/*For LOGIN responses*/,"-10.       else {
-9.         failf(data, ""Authentication cancelled"");
-8.         result = CURLE_LOGIN_DENIED;
-7.       }
-6.       break;
-5.     default:
-4.       break;
-3.     }
-2.   return result;
-1. }

/*For LOGIN responses*/

1. static CURLcode imap_state_login_resp(struct Curl_easy *data,
2.                                       int imapcode,
3.                                       imapstate instate)
4. {
5.   CURLcode result = CURLE_OK;",Not Useful,1
/*no use for this yet*/,"-5. static CURLcode imap_state_servergreet_resp(struct Curl_easy *data,
-4.                                             int imapcode,
-3.                                             imapstate instate)
-2. {
-1.   struct connectdata *conn = data->conn;

/*no use for this yet*/

1.   if(imapcode == IMAP_RESP_PREAUTH) {",Not Useful,1
/*For LIST and SEARCH responses*/,"-3.     state(data, IMAP_STOP);
-2.   return result;
-1. }

/*For LIST and SEARCH responses*/

1. static CURLcode imap_state_listsearch_resp(struct Curl_easy *data,
2.                                            int imapcode,
3.                                            imapstate instate)
4. {
5.   CURLcode result = CURLE_OK;
6.   char *line = data->state.buffer;
7.   size_t len = strlen(line);",Not Useful,1
/*No use for this yet*/,"-7. static CURLcode imap_state_listsearch_resp(struct Curl_easy *data,
-6.                                            int imapcode,
-5.                                            imapstate instate)
-4. {
-3.   CURLcode result = CURLE_OK;
-2.   char *line = data->state.buffer;
-1.   size_t len = strlen(line);

/*No use for this yet*/

1.   if(imapcode == '*') {",Not Useful,1
/*For SELECT responses*/,"-3.     state(data, IMAP_STOP);
-2.   return result;
-1. }

/*For SELECT responses*/

1. static CURLcode imap_state_select_resp(struct Curl_easy *data, int imapcode,
2.                                        imapstate instate)
3. {
4.   CURLcode result = CURLE_OK;
5.   struct connectdata *conn = data->conn;
6.   struct IMAP *imap = data->req.p.imap;
7.   struct imap_conn *imapc = &conn->proto.imapc;
8.   const char *line = data->state.buffer;",Not Useful,1
/*no use for this yet*/,"-5. static CURLcode imap_state_servergreet_resp(struct Curl_easy *data,
-4.                                             int imapcode,
-3.                                             imapstate instate)
-2. {
-1.   struct connectdata *conn = data->conn;

/*no use for this yet*/

1.   if(imapcode == IMAP_RESP_PREAUTH) {",Not Useful,1
/*Note the currently opened mailbox on this connection*/,"-6.     if(imap->uidvalidity && imapc->mailbox_uidvalidity &&
-5.        !strcasecompare(imap->uidvalidity, imapc->mailbox_uidvalidity)) {
-4.       failf(data, ""Mailbox UIDVALIDITY has changed"");
-3.       result = CURLE_REMOTE_FILE_NOT_FOUND;
-2.     }
-1.     else {

/*Note the currently opened mailbox on this connection*/

1.       imapc->mailbox = strdup(imap->mailbox);
2.       if(imap->custom)
3.         result = imap_perform_list(data);
4.       else if(imap->query)
5.         result = imap_perform_search(data);
6.       else
7.         result = imap_perform_fetch(data);
8.     }
9.   }
10.   else {",Not Useful,1
/*For the (first line of the) FETCH responses*/,"-10.       else
-9.         result = imap_perform_fetch(data);
-8.     }
-7.   }
-6.   else {
-5.     failf(data, ""Select failed"");
-4.     result = CURLE_LOGIN_DENIED;
-3.   }
-2.   return result;
-1. }

/*For the (first line of the) FETCH responses*/

1. static CURLcode imap_state_fetch_resp(struct Curl_easy *data,
2.                                       struct connectdata *conn, int imapcode,
3.                                       imapstate instate)
4. {
5.   CURLcode result = CURLE_OK;
6.   struct imap_conn *imapc = &conn->proto.imapc;
7.   struct pingpong *pp = &imapc->pp;
8.   const char *ptr = data->state.buffer;
9.   bool parsed = FALSE;
10.   curl_off_t size = 0;",Not Useful,1
/*no use for this yet*/,"-5. static CURLcode imap_state_servergreet_resp(struct Curl_easy *data,
-4.                                             int imapcode,
-3.                                             imapstate instate)
-2. {
-1.   struct connectdata *conn = data->conn;

/*no use for this yet*/

1.   if(imapcode == IMAP_RESP_PREAUTH) {",Not Useful,1
/*The conversion from curl_off_t to size_t is always fine here*/,"-2.       size_t chunk = pp->cache_size;
-1.       if(chunk > (size_t)size)

/*The conversion from curl_off_t to size_t is always fine here*/

1.         chunk = (size_t)size;
2.       if(!chunk) {",Not Useful,1
/*Have we used the entire cache or just part of it?*/,"-9.         state(data, IMAP_STOP);
-8.         return CURLE_OK;
-7.       }
-6.       result = Curl_client_write(data, CLIENTWRITE_BODY, pp->cache, chunk);
-5.       if(result)
-4.         return result;
-3.       data->req.bytecount += chunk;
-2.       infof(data, ""Written %zu bytes, %"" CURL_FORMAT_CURL_OFF_TU
-1.             "" bytes are left for transfer"", chunk, size - chunk);

/*Have we used the entire cache or just part of it?*/

1.       if(pp->cache_size > chunk) {",Not Useful,1
/*Only part of it so shrink the cache to fit the trailing data*/,"-1.       if(pp->cache_size > chunk) {

/*Only part of it so shrink the cache to fit the trailing data*/

1.         memmove(pp->cache, pp->cache + chunk, pp->cache_size - chunk);
2.         pp->cache_size -= chunk;
3.       }
4.       else {",Not Useful,0
/*Free the cache*/,"-4.         memmove(pp->cache, pp->cache + chunk, pp->cache_size - chunk);
-3.         pp->cache_size -= chunk;
-2.       }
-1.       else {

/*Free the cache*/

1.         Curl_safefree(pp->cache);",Not Useful,1
/*Reset the cache size*/,"-1.         Curl_safefree(pp->cache);

/*Reset the cache size*/

1.         pp->cache_size = 0;
2.       }
3.     }
4.     if(data->req.bytecount == size)",Not Useful,1
/*For final FETCH responses performed after the download*/,"-3.   state(data, IMAP_STOP);
-2.   return result;
-1. }

/*For final FETCH responses performed after the download*/

1. static CURLcode imap_state_fetch_final_resp(struct Curl_easy *data,
2.                                             int imapcode,
3.                                             imapstate instate)
4. {
5.   CURLcode result = CURLE_OK;",Not Useful,1
/*No use for this yet*/,"-7. static CURLcode imap_state_listsearch_resp(struct Curl_easy *data,
-6.                                            int imapcode,
-5.                                            imapstate instate)
-4. {
-3.   CURLcode result = CURLE_OK;
-2.   char *line = data->state.buffer;
-1.   size_t len = strlen(line);

/*No use for this yet*/

1.   if(imapcode == '*') {",Not Useful,1
/*For APPEND responses*/,"-3.     state(data, IMAP_STOP);
-2.   return result;
-1. }

/*For APPEND responses*/

1. static CURLcode imap_state_append_resp(struct Curl_easy *data, int imapcode,
2.                                        imapstate instate)
3. {
4.   CURLcode result = CURLE_OK;",Not Useful,0
/*No use for this yet*/,"-7. static CURLcode imap_state_listsearch_resp(struct Curl_easy *data,
-6.                                            int imapcode,
-5.                                            imapstate instate)
-4. {
-3.   CURLcode result = CURLE_OK;
-2.   char *line = data->state.buffer;
-1.   size_t len = strlen(line);

/*No use for this yet*/

1.   if(imapcode == '*') {",Not Useful,0
/*For final APPEND responses performed after the upload*/,"-4.     state(data, IMAP_STOP);
-3.   }
-2.   return result;
-1. }

/*For final APPEND responses performed after the upload*/

1. static CURLcode imap_state_append_final_resp(struct Curl_easy *data,
2.                                              int imapcode,
3.                                              imapstate instate)
4. {
5.   CURLcode result = CURLE_OK;",Not Useful,1
/*No use for this yet*/,"-7. static CURLcode imap_state_listsearch_resp(struct Curl_easy *data,
-6.                                            int imapcode,
-5.                                            imapstate instate)
-4. {
-3.   CURLcode result = CURLE_OK;
-2.   char *line = data->state.buffer;
-1.   size_t len = strlen(line);

/*No use for this yet*/

1.   if(imapcode == '*') {",Not Useful,1
/*Flush any data that needs to be sent*/,"-2.   if(imapc->state == IMAP_UPGRADETLS)
-1.     return imap_perform_upgrade_tls(data, conn);

/*Flush any data that needs to be sent*/

1.   if(pp->sendleft)
2.     return Curl_pp_flushsend(data, pp);
3.   do {",Not Useful,1
"/*Allocate and initialize the struct IMAP for the current Curl_easy if
   required*/","-10. static CURLcode imap_block_statemach(struct Curl_easy *data,
-9.                                      struct connectdata *conn,
-8.                                      bool disconnecting)
-7. {
-6.   CURLcode result = CURLE_OK;
-5.   struct imap_conn *imapc = &conn->proto.imapc;
-4.   while(imapc->state != IMAP_STOP && !result)
-3.     result = Curl_pp_statemach(data, &imapc->pp, TRUE, disconnecting);
-2.   return result;
-1. }

/*Allocate and initialize the struct IMAP for the current Curl_easy if
   required*/

1. static CURLcode imap_init(struct Curl_easy *data)
2. {
3.   CURLcode result = CURLE_OK;
4.   struct IMAP *imap;
5.   imap = data->req.p.imap = calloc(sizeof(struct IMAP), 1);
6.   if(!imap)
7.     result = CURLE_OUT_OF_MEMORY;
8.   return result;
9. }",Not Useful,1
/*default to not done yet*/,"-10.  *
-9.  * The variable 'done' points to will be TRUE if the protocol-layer connect
-8.  * phase is done when this function returns, or FALSE if not.
-7.  */
-6. static CURLcode imap_connect(struct Curl_easy *data, bool *done)
-5. {
-4.   CURLcode result = CURLE_OK;
-3.   struct connectdata *conn = data->conn;
-2.   struct imap_conn *imapc = &conn->proto.imapc;
-1.   struct pingpong *pp = &imapc->pp;

/*default to not done yet*/

111",Not Useful,1
/*Parse the URL options*/,"-2.   Curl_pp_setup(pp);
-1.   Curl_pp_init(data, pp);

/*Parse the URL options*/

1.   result = imap_parse_url_options(conn);
2.   if(result)
3.     return result;",Not Useful,1
/*Clear the transfer mode for the next request*/,"-9.   Curl_safefree(imap->mailbox);
-8.   Curl_safefree(imap->uidvalidity);
-7.   Curl_safefree(imap->uid);
-6.   Curl_safefree(imap->mindex);
-5.   Curl_safefree(imap->section);
-4.   Curl_safefree(imap->partial);
-3.   Curl_safefree(imap->query);
-2.   Curl_safefree(imap->custom);
-1.   Curl_safefree(imap->custom_params);

/*Clear the transfer mode for the next request*/

1.   imap->transfer = PPTRANSFER_BODY;
2.   return result;
3. }",Not Useful,1
/*This is IMAP and no proxy*/,"-3. static CURLcode imap_perform(struct Curl_easy *data, bool *connected,
-2.                              bool *dophase_done)
-1. {

/*This is IMAP and no proxy*/

1.   CURLcode result = CURLE_OK;
2.   struct connectdata *conn = data->conn;
3.   struct IMAP *imap = data->req.p.imap;
4.   struct imap_conn *imapc = &conn->proto.imapc;
5.   bool selected = FALSE;
6.   DEBUGF(infof(data, ""DO phase starts""));
7.   if(data->set.opt_no_body) {",Not Useful,1
/*Requested no body means no transfer*/,"-7.   CURLcode result = CURLE_OK;
-6.   struct connectdata *conn = data->conn;
-5.   struct IMAP *imap = data->req.p.imap;
-4.   struct imap_conn *imapc = &conn->proto.imapc;
-3.   bool selected = FALSE;
-2.   DEBUGF(infof(data, ""DO phase starts""));
-1.   if(data->set.opt_no_body) {

/*Requested no body means no transfer*/

1.     imap->transfer = PPTRANSFER_INFO;
2.   }",Not Useful,1
"/*Determine if the requested mailbox (with the same UIDVALIDITY if set)
     has already been selected on this connection*/","-3.     imap->transfer = PPTRANSFER_INFO;
-2.   }

/*Determine if the requested mailbox (with the same UIDVALIDITY if set)
     has already been selected on this connection*/

1.   if(imap->mailbox && imapc->mailbox &&
2.      strcasecompare(imap->mailbox, imapc->mailbox) &&
3.      (!imap->uidvalidity || !imapc->mailbox_uidvalidity ||
4.       strcasecompare(imap->uidvalidity, imapc->mailbox_uidvalidity)))
5.     selected = TRUE;",Not Useful,1
/*LIST*/,"-4.       case IMAP_CAPABILITY:
-3.         if(!imap_matchresp(line, len, ""CAPABILITY""))
-2.           return FALSE;
-1.         break;
      case IMAP_LIST:

/*LIST*/

1.         if((!imap->custom && !imap_matchresp(line, len, ""LIST"")) ||
2.           (imap->custom && !imap_matchresp(line, len, imap->custom) &&
3.            (!strcasecompare(imap->custom, ""STORE"") ||
4.             !imap_matchresp(line, len, ""FETCH"")) &&
5.            !strcasecompare(imap->custom, ""SELECT"") &&
6.            !strcasecompare(imap->custom, ""EXAMINE"") &&
7.            !strcasecompare(imap->custom, ""SEARCH"") &&
8.            !strcasecompare(imap->custom, ""EXPUNGE"") &&
9.            !strcasecompare(imap->custom, ""LSUB"") &&
10.            !strcasecompare(imap->custom, ""UID"") &&",Not Useful,1
/*Parse the URL path*/,"-10.  *
-9.  * This function is registered as 'curl_do' function. It decodes the path
-8.  * parts etc as a wrapper to the actual DO function (imap_perform).
-7.  *
-6.  * The input argument is already checked for validity.
-5.  */
-4. static CURLcode imap_do(struct Curl_easy *data, bool *done)
-3. {
-2.   CURLcode result = CURLE_OK;

/*Parse the URL path*/

1.   result = imap_parse_url_path(data);
2.   if(result)
3.     return result;",Not Useful,1
/*Parse the custom request*/,"-3.   result = imap_parse_url_path(data);
-2.   if(result)
-1.     return result;

/*Parse the custom request*/

1.   result = imap_parse_custom_request(data);
2.   if(result)
3.     return result;
4.   result = imap_regular_transfer(data, done);
5.   return result;
6. }
7. /***********************************************************************
8.  *
9.  * imap_disconnect()
10.  *",Not Useful,1
"/***********************************************************************
 *
 * imap_disconnect()
 *
 * Disconnect from an IMAP server. Cleanup protocol-specific per-connection
 * resources. BLOCKING.*/","-6.   result = imap_parse_custom_request(data);
-5.   if(result)
-4.     return result;
-3.   result = imap_regular_transfer(data, done);
-2.   return result;
-1. }
/***********************************************************************
 *
 * imap_disconnect()
 *
 * Disconnect from an IMAP server. Cleanup protocol-specific per-connection
 * resources. BLOCKING.

/***********************************************************************
 *
 * imap_disconnect()
 *
 * Disconnect from an IMAP server. Cleanup protocol-specific per-connection
 * resources. BLOCKING.*/

1.  */
2. static CURLcode imap_disconnect(struct Curl_easy *data,
3.                                 struct connectdata *conn, bool dead_connection)
4. {
5.   struct imap_conn *imapc = &conn->proto.imapc;
6.   (void)data;",Not Useful,0
/*Cleanup the SASL module*/,"-2.   Curl_pp_disconnect(&imapc->pp);
-1.   Curl_dyn_free(&imapc->dyn);

/*Cleanup the SASL module*/

1.   Curl_sasl_cleanup(conn, imapc->sasl.authused);",Not Useful,1
/*Make sure size is unknown at this point*/,"-10.  * The input argument is already checked for validity.
-9.  *
-8.  * Performs all commands done before a regular transfer between a local and a
-7.  * remote host.
-6.  */
-5. static CURLcode imap_regular_transfer(struct Curl_easy *data,
-4.                                       bool *dophase_done)
-3. {
-2.   CURLcode result = CURLE_OK;
-1.   bool connected = FALSE;

/*Make sure size is unknown at this point*/

1.   data->req.size = -1;",Not Useful,0
/*Carry out the perform*/,"-4.   Curl_pgrsSetUploadCounter(data, 0);
-3.   Curl_pgrsSetDownloadCounter(data, 0);
-2.   Curl_pgrsSetUploadSize(data, -1);
-1.   Curl_pgrsSetDownloadSize(data, -1);

/*Carry out the perform*/

1.   result = imap_perform(data, &connected, dophase_done);",Not Useful,1
/*Initialise the IMAP layer*/,"-7.   if(!result && *dophase_done)
-6.     result = imap_dophase_done(data, connected);
-5.   return result;
-4. }
-3. static CURLcode imap_setup_connection(struct Curl_easy *data,
-2.                                       struct connectdata *conn)
-1. {

/*Initialise the IMAP layer*/

1.   CURLcode result = imap_init(data);
2.   if(result)
3.     return result;",Not Useful,0
/*Clear the TLS upgraded flag*/,"-3.   CURLcode result = imap_init(data);
-2.   if(result)
-1.     return result;

/*Clear the TLS upgraded flag*/

1.   conn->bits.tls_upgraded = FALSE;
2.   return CURLE_OK;
3. }
4. /***********************************************************************
5.  *
6.  * imap_sendf()
7.  *
8.  * Sends the formatted string as an IMAP command to the server.
9.  *
10.  * Designed to never block.",Not Useful,1
"/***********************************************************************
 *
 * imap_sendf()
 *
 * Sends the formatted string as an IMAP command to the server.
 *
 * Designed to never block.*/","-3.   conn->bits.tls_upgraded = FALSE;
-2.   return CURLE_OK;
-1. }
/***********************************************************************
 *
 * imap_sendf()
 *
 * Sends the formatted string as an IMAP command to the server.
 *
 * Designed to never block.

/***********************************************************************
 *
 * imap_sendf()
 *
 * Sends the formatted string as an IMAP command to the server.
 *
 * Designed to never block.*/

1.  */
2. static CURLcode imap_sendf(struct Curl_easy *data, const char *fmt, ...)
3. {
4.   CURLcode result = CURLE_OK;
5.   struct imap_conn *imapc = &data->conn->proto.imapc;
6.   DEBUGASSERT(fmt);",Not Useful,0
/*!checksrc! disable PARENBRACE 1*/,"-10.  * imap_atom()
-9.  *
-8.  * Checks the input string for characters that need escaping and returns an
-7.  * atom ready for sending to the server.
-6.  *
-5.  * The returned string needs to be freed.
-4.  *
-3.  */
-2. static char *imap_atom(const char *str, bool escape_only)
-1. {

/*!checksrc! disable PARENBRACE 1*/

1.   const char atom_specials[] = ""(){ %*]"";
2.   const char *p1;
3.   char *p2;
4.   size_t backsp_count = 0;
5.   size_t quote_count = 0;
6.   bool others_exists = FALSE;
7.   size_t newlen = 0;
8.   char *newstr = NULL;
9.   if(!str)
10.     return NULL;",Not Useful,1
"/*Look for ""atom-specials"", counting the backslash and quote characters as
     these will need escaping*/","-10.   const char atom_specials[] = ""(){ %*]"";
-9.   const char *p1;
-8.   char *p2;
-7.   size_t backsp_count = 0;
-6.   size_t quote_count = 0;
-5.   bool others_exists = FALSE;
-4.   size_t newlen = 0;
-3.   char *newstr = NULL;
-2.   if(!str)
-1.     return NULL;

/*Look for ""atom-specials"", counting the backslash and quote characters as
     these will need escaping*/

1.   p1 = str;
2.   while(*p1) {
3.     if(*p1 == '\\')
4.       backsp_count++;
5.     else if(*p1 == '""')
6.       quote_count++;
7.     else if(!escape_only) {
8.       const char *p3 = atom_specials;
9.       while(*p3 && !others_exists) {
10.         if(*p1 == *p3)",Not Useful,1
/*Terminate the string*/,"-10.   p1 = str;
-9.   while(*p1) {
-8.     if(*p1 == '\\' || *p1 == '""') {
-7.       *p2 = '\\';
-6.       p2++;
-5.     }
-4.    *p2 = *p1;
-3.     p1++;
-2.     p2++;
-1.   }

/*Terminate the string*/

1.   newstr[newlen] = '\0';
2.   return newstr;
3. }",Not Useful,1
"/***********************************************************************
 *
 * imap_parse_url_options()
 *
 * Parse the URL login options.*/","-5.       return true;
-4.     default:
-3.       return false;
-2.   }
-1. }
/***********************************************************************
 *
 * imap_parse_url_options()
 *
 * Parse the URL login options.

/***********************************************************************
 *
 * imap_parse_url_options()
 *
 * Parse the URL login options.*/

1.  */
2. static CURLcode imap_parse_url_options(struct connectdata *conn)
3. {
4.   CURLcode result = CURLE_OK;
5.   struct imap_conn *imapc = &conn->proto.imapc;
6.   const char *ptr = conn->options;
7.   while(!result && ptr && *ptr) {
8.     const char *key = ptr;
9.     const char *value;
10.     while(*ptr && *ptr != '=')",Not Useful,1
"/***********************************************************************
 *
 * imap_parse_url_path()
 *
 * Parse the URL path into separate path components.
 **/","
/***************************************************************************
 *                                  _   _ ____  _



/***********************************************************************
 *
 * imap_parse_url_path()
 *
 * Parse the URL path into separate path components.
 **/

1.  *  Project                     ___| | | |  _ \| |
2.  *                             / __| | | | |_) | |
3.  *                            | (__| |_| |  _ <| |___
4.  *                             \___|\___/|_| \_\_____|
5.  *
6.  * Copyright (C) 1998 - 2022, Daniel Stenberg, <daniel@haxx.se>, et al.
7.  *
8.  * This software is licensed as described in the file COPYING, which
9.  * you should have received as part of this distribution. The terms",Not Useful,1
/*The imap struct is already initialised in imap_connect()*/,"-2. static CURLcode imap_parse_url_path(struct Curl_easy *data)
-1. {

/*The imap struct is already initialised in imap_connect()*/

1.   CURLcode result = CURLE_OK;
2.   struct IMAP *imap = data->req.p.imap;",Not Useful,1
"/*There can be any number of parameters in the form "";NAME=VALUE""*/","-10.     const char *end = ptr;
-9.     if(end > begin && end[-1] == '/')
-8.       end--;
-7.     result = Curl_urldecode(begin, end - begin, &imap->mailbox, NULL,
-6.                             REJECT_CTRL);
-5.     if(result)
-4.       return result;
-3.   }
-2.   else
-1.     imap->mailbox = NULL;

/*There can be any number of parameters in the form "";NAME=VALUE""*/

1.   while(*ptr == ';') {
2.     char *name;
3.     char *value;
4.     size_t valuelen;",Not Useful,0
/*Decode the name parameter*/,"-5.     begin = ++ptr;
-4.     while(*ptr && *ptr != '=')
-3.       ptr++;
-2.     if(!*ptr)
-1.       return CURLE_URL_MALFORMAT;

/*Decode the name parameter*/

1.     result = Curl_urldecode(begin, ptr - begin, &name, NULL,
2.                             REJECT_CTRL);
3.     if(result)
4.       return result;",Not Useful,1
/*Decode the value parameter*/,"-3.     begin = ++ptr;
-2.     while(imap_is_bchar(*ptr))
-1.       ptr++;

/*Decode the value parameter*/

1.     result = Curl_urldecode(begin, ptr - begin, &value, &valuelen,
2.                             REJECT_CTRL);
3.     if(result) {
4.       free(name);
5.       return result;
6.     }
7.     DEBUGF(infof(data, ""IMAP URL parameter '%s' = '%s'"", name, value));",Not Useful,1
"/*Get the query parameter, URL decoded*/","-1.   if(imap->mailbox && !imap->uid && !imap->mindex) {

/*Get the query parameter, URL decoded*/

1.     (void)curl_url_get(data->state.uh, CURLUPART_QUERY, &imap->query,
2.                        CURLU_URLDECODE);
3.   }",Not Useful,1
"/***********************************************************************
 *
 * imap_parse_custom_request()
 *
 * Parse the custom request.*/","-4.   if(*ptr)
-3.     return CURLE_URL_MALFORMAT;
-2.   return CURLE_OK;
-1. }
/***********************************************************************
 *
 * imap_parse_custom_request()
 *
 * Parse the custom request.

/***********************************************************************
 *
 * imap_parse_custom_request()
 *
 * Parse the custom request.*/

1.  */
2. static CURLcode imap_parse_custom_request(struct Curl_easy *data)
3. {
4.   CURLcode result = CURLE_OK;
5.   struct IMAP *imap = data->req.p.imap;
6.   const char *custom = data->set.str[STRING_CUSTOMREQUEST];
7.   if(custom) {",Not Useful,1
/*URL decode the custom request*/,"-10.  * imap_parse_custom_request()
-9.  *
-8.  * Parse the custom request.
-7.  */
-6. static CURLcode imap_parse_custom_request(struct Curl_easy *data)
-5. {
-4.   CURLcode result = CURLE_OK;
-3.   struct IMAP *imap = data->req.p.imap;
-2.   const char *custom = data->set.str[STRING_CUSTOMREQUEST];
-1.   if(custom) {

/*URL decode the custom request*/

1.     result = Curl_urldecode(custom, 0, &imap->custom, NULL, REJECT_CTRL);",Not Useful,1
/*CURL_DISABLE_IMAP*/,"-10.  * RFC4616 PLAIN authentication
-9.  * RFC4752 The Kerberos V5 (""GSSAPI"") SASL Mechanism
-8.  * RFC4959 IMAP Extension for SASL Initial Client Response
-7.  * RFC5092 IMAP URL Scheme
-6.  * RFC6749 OAuth 2.0 Authorization Framework
-5.  * RFC8314 Use of TLS for Email Submission and Access
-4.  * Draft   LOGIN SASL Mechanism <draft-murchison-sasl-login-00.txt>
-3.  *
-2.  ***************************************************************************/
-1. #include ""curl_setup.h""
#ifndef CURL_DISABLE_IMAP

/*CURL_DISABLE_IMAP*/

1. #ifdef HAVE_NETINET_IN_H
2. #include <netinet/in.h>
3. #endif
4. #ifdef HAVE_ARPA_INET_H
5. #include <arpa/inet.h>
6. #endif
7. #ifdef HAVE_UTSNAME_H
8. #include <sys/utsname.h>
9. #endif
10. #ifdef HAVE_NETDB_H",Not Useful,1
/*normalize pattern and hostname by stripping off trailing dots*/,"-10.  *
-9.  * Return TRUE on a match. FALSE if not.
-8.  */
-7. static bool hostmatch(const char *hostname,
-6.                       size_t hostlen,
-5.                       const char *pattern,
-4.                       size_t patternlen)
-3. {
-2.   const char *pattern_label_end, *wildcard, *hostname_label_end;
-1.   size_t prefixlen, suffixlen;

/*normalize pattern and hostname by stripping off trailing dots*/

1.   DEBUGASSERT(patternlen);
2.   if(hostname[hostlen-1]=='.')
3.     hostlen--;
4.   if(pattern[patternlen-1]=='.')
5.     patternlen--;
6.   wildcard = memchr(pattern, '*', patternlen);
7.   if(!wildcard)
8.     return pmatch(hostname, hostlen, pattern, patternlen);",Not Useful,1
/*flush the stream to send off what we got earlier*/,"-4.   if(per->config->headerfile && heads->stream) {
-3.     size_t rc = fwrite(ptr, size, nmemb, heads->stream);
-2.     if(rc != cb)
-1.       return rc;

/*flush the stream to send off what we got earlier*/

1.     (void)fflush(heads->stream);
2.   }",Not Useful,1
"/*look for the 'filename=' parameter
       (encoded filenames (*=) are not supported)*/","-10.    * This callback sets the filename where output shall be written when
-9.    * curl options --remote-name (-O) and --remote-header-name (-J) have
-8.    * been simultaneously given and additionally server returns an HTTP
-7.    * Content-Disposition header specifying a filename property.
-6.    */
-5.   curl_easy_getinfo(per->curl, CURLINFO_PROTOCOL, &protocol);
-4.   if(hdrcbdata->honor_cd_filename &&
-3.      (cb > 20) && checkprefix(""Content-disposition:"", str) &&
-2.      (protocol & (CURLPROTO_HTTPS|CURLPROTO_HTTP))) {
-1.     const char *p = str + 20;

/*look for the 'filename=' parameter
       (encoded filenames (*=) are not supported)*/

1.     for(;;) {
2.       char *filename;
3.       size_t len;
4.       while(*p && (p < end) && !ISALPHA(*p))
5.         p++;
6.       if(p > end - 9)
7.         break;
8.       if(memcmp(p, ""filename="", 9)) {",Not Useful,1
/*done now!*/,"-8.           free(filename);
-7.           return failure;
-6.         }
-5.         outs->is_cd_filename = TRUE;
-4.         outs->s_isreg = TRUE;
-3.         outs->fopened = FALSE;
-2.         outs->filename = filename;
-1.         outs->alloc_filename = TRUE;

/*done now!*/

1.         if(!tool_create_output_file(outs, per->config))
2.           return failure;
3.       }
4.       break;
5.     }
6.     if(!outs->stream && !tool_create_output_file(outs, per->config))
7.       return failure;
8.   }
9.   if(hdrcbdata->config->writeout) {
10.     char *value = memchr(ptr, ':', cb);",Not Useful,1
/*MSDOS || WIN32*/,"-10.     memmove(copy, p, strlen(p) + 1);
-9. #if defined(MSDOS) || defined(WIN32)
-8.   {
-7.     char *sanitized;
-6.     SANITIZEcode sc = sanitize_file_name(&sanitized, copy, 0);
-5.     Curl_safefree(copy);
-4.     if(sc)
-3.       return NULL;
-2.     copy = sanitized;
-1.   }

/*MSDOS || WIN32*/

111",Not Useful,1
/*suitably large*/,"-4. #ifdef DEBUGBUILD
-3.   {
-2.     char *tdir = curlx_getenv(""CURL_TESTDIR"");
-1.     if(tdir) {

/*suitably large*/

1.       msnprintf(buffer, sizeof(buffer), ""%s/%s"", tdir, copy);
2.       Curl_safefree(copy);",Not Useful,1
/*Generate our UTF8 based SPN*/,"-10.   char *utf8_spn = NULL;
-9.   TCHAR *tchar_spn = NULL;
-8.   TCHAR *dupe_tchar_spn = NULL;
-7.   (void) realm;

/*Generate our UTF8 based SPN*/

1.   utf8_spn = aprintf(""%s/%s"", service, host);
2.   if(!utf8_spn)
3.     return NULL;",Not Useful,0
/*USE_WINDOWS_SSPI*/,"-10.  * service@realm      (Not used by Windows SSPI)
-9.  *
-8.  * Parameters:
-7.  *
-6.  * service  [in] - The service type such as http, smtp, pop or imap.
-5.  * host     [in] - The host name.
-4.  * realm    [in] - The realm.
-3.  *
-2.  * Returns a pointer to the newly allocated SPN.
-1.  */
#if !defined(USE_WINDOWS_SSPI)

/*USE_WINDOWS_SSPI*/

1. char *Curl_auth_build_spn(const char *service, const char *host,
2.                           const char *realm)
3. {
4.   char *spn = NULL;",Not Useful,1
/*stand-alone but not a boolean*/,"-1.   enum {

/*stand-alone but not a boolean*/

111",Not Useful,0
"/*epsv' made like this to make --no-epsv and --epsv to work
             although --disable-epsv is the documented option*/","-10.   {""*a"", ""random-file"",              ARG_FILENAME},
-9.   {""*b"", ""egd-file"",                 ARG_STRING},
-8.   {""*B"", ""oauth2-bearer"",            ARG_STRING},
-7.   {""*c"", ""connect-timeout"",          ARG_STRING},
-6.   {""*C"", ""doh-url""        ,          ARG_STRING},
-5.   {""*d"", ""ciphers"",                  ARG_STRING},
-4.   {""*D"", ""dns-interface"",            ARG_STRING},
-3.   {""*e"", ""disable-epsv"",             ARG_BOOL},
-2.   {""*f"", ""disallow-username-in-url"", ARG_BOOL},
-1.   {""*E"", ""epsv"",                     ARG_BOOL},

/*epsv' made like this to make --no-epsv and --epsv to work
             although --disable-epsv is the documented option*/

1.   {""*F"", ""dns-servers"",              ARG_STRING},
2.   {""*g"", ""trace"",                    ARG_FILENAME},
3.   {""*G"", ""npn"",                      ARG_BOOL},
4.   {""*h"", ""trace-ascii"",              ARG_FILENAME},
5.   {""*H"", ""alpn"",                     ARG_BOOL},
6.   {""*i"", ""limit-rate"",               ARG_STRING},
7.   {""*j"", ""compressed"",               ARG_BOOL},
8.   {""*J"", ""tr-encoding"",              ARG_BOOL},
9.   {""*k"", ""digest"",                   ARG_BOOL},
10.   {""*l"", ""negotiate"",                ARG_BOOL},",Not Useful,1
/*krb4' is the previous name*/,"-10.   {""*r"", ""create-dirs"",              ARG_BOOL},
-9.   {""*R"", ""create-file-mode"",         ARG_STRING},
-8.   {""*s"", ""max-redirs"",               ARG_STRING},
-7.   {""*t"", ""proxy-ntlm"",               ARG_BOOL},
-6.   {""*u"", ""crlf"",                     ARG_BOOL},
-5.   {""*v"", ""stderr"",                   ARG_FILENAME},
-4.   {""*V"", ""aws-sigv4"",                ARG_STRING},
-3.   {""*w"", ""interface"",                ARG_STRING},
-2.   {""*x"", ""krb"",                      ARG_STRING},
-1.   {""*x"", ""krb4"",                     ARG_STRING},

/*krb4' is the previous name*/

1.   {""*X"", ""haproxy-protocol"",         ARG_BOOL},
2.   {""*y"", ""max-filesize"",             ARG_STRING},
3.   {""*z"", ""disable-eprt"",             ARG_BOOL},
4.   {""*Z"", ""eprt"",                     ARG_BOOL},",Not Useful,1
"/*eprt' made like this to make --no-eprt and --eprt to work
             although --disable-eprt is the documented option*/","-4.   {""*X"", ""haproxy-protocol"",         ARG_BOOL},
-3.   {""*y"", ""max-filesize"",             ARG_STRING},
-2.   {""*z"", ""disable-eprt"",             ARG_BOOL},
-1.   {""*Z"", ""eprt"",                     ARG_BOOL},

/*eprt' made like this to make --no-eprt and --eprt to work
             although --disable-eprt is the documented option*/

1.   {""*~"", ""xattr"",                    ARG_BOOL},
2.   {""$a"", ""ftp-ssl"",                  ARG_BOOL},",Not Useful,0
/*sessionid' listed as --no-sessionid in the help*/,"-1.   {""$w"", ""sessionid"",                ARG_BOOL},

/*sessionid' listed as --no-sessionid in the help*/

1.   {""$x"", ""ftp-ssl-control"",          ARG_BOOL},
2.   {""$y"", ""ftp-ssl-ccc"",              ARG_BOOL},
3.   {""$j"", ""ftp-ssl-ccc-mode"",         ARG_STRING},
4.   {""$z"", ""libcurl"",                  ARG_STRING},
5.   {""$#"", ""raw"",                      ARG_BOOL},
6.   {""$0"", ""post301"",                  ARG_BOOL},
7.   {""$1"", ""keepalive"",                ARG_BOOL},",Not Useful,0
/*keepalive' listed as --no-keepalive in the help*/,"-7.   {""$x"", ""ftp-ssl-control"",          ARG_BOOL},
-6.   {""$y"", ""ftp-ssl-ccc"",              ARG_BOOL},
-5.   {""$j"", ""ftp-ssl-ccc-mode"",         ARG_STRING},
-4.   {""$z"", ""libcurl"",                  ARG_STRING},
-3.   {""$#"", ""raw"",                      ARG_BOOL},
-2.   {""$0"", ""post301"",                  ARG_BOOL},
-1.   {""$1"", ""keepalive"",                ARG_BOOL},

/*keepalive' listed as --no-keepalive in the help*/

1.   {""$2"", ""socks5-hostname"",          ARG_STRING},
2.   {""$3"", ""keepalive-time"",           ARG_STRING},
3.   {""$4"", ""post302"",                  ARG_BOOL},
4.   {""$5"", ""noproxy"",                  ARG_STRING},
5.   {""$7"", ""socks5-gssapi-nec"",        ARG_BOOL},
6.   {""$8"", ""proxy1.0"",                 ARG_STRING},
7.   {""$9"", ""tftp-blksize"",             ARG_STRING},
8.   {""$A"", ""mail-from"",                ARG_STRING},
9.   {""$B"", ""mail-rcpt"",                ARG_STRING},
10.   {""$C"", ""ftp-pret"",                 ARG_BOOL},",Not Useful,1
/*Eo*/,"-10.   {""Ef"", ""engine"",                   ARG_STRING},
-9.   {""Eg"", ""capath"",                   ARG_FILENAME},
-8.   {""Eh"", ""pubkey"",                   ARG_STRING},
-7.   {""Ei"", ""hostpubmd5"",               ARG_STRING},
-6.   {""EF"", ""hostpubsha256"",            ARG_STRING},
-5.   {""Ej"", ""crlfile"",                  ARG_FILENAME},
-4.   {""Ek"", ""tlsuser"",                  ARG_STRING},
-3.   {""El"", ""tlspassword"",              ARG_STRING},
-2.   {""Em"", ""tlsauthtype"",              ARG_STRING},
-1.   {""En"", ""ssl-allow-beast"",          ARG_BOOL},
  {""Eo"", ""ssl-auto-client-cert"",     ARG_BOOL},

/*Eo*/

1.   {""EO"", ""proxy-ssl-auto-client-cert"", ARG_BOOL},
2.   {""Ep"", ""pinnedpubkey"",             ARG_STRING},
3.   {""EP"", ""proxy-pinnedpubkey"",       ARG_STRING},
4.   {""Eq"", ""cert-status"",              ARG_BOOL},
5.   {""EQ"", ""doh-cert-status"",          ARG_BOOL},
6.   {""Er"", ""false-start"",              ARG_BOOL},
7.   {""Es"", ""ssl-no-revoke"",            ARG_BOOL},
8.   {""ES"", ""ssl-revoke-best-effort"",   ARG_BOOL},
9.   {""Et"", ""tcp-fastopen"",             ARG_BOOL},
10.   {""Eu"", ""proxy-tlsuser"",            ARG_STRING},",Not Useful,1
/*buffer' listed as --no-buffer in the help*/,"-10.   {""K"",  ""config"",                   ARG_FILENAME},
-9.   {""l"",  ""list-only"",                ARG_BOOL},
-8.   {""L"",  ""location"",                 ARG_BOOL},
-7.   {""Lt"", ""location-trusted"",         ARG_BOOL},
-6.   {""m"",  ""max-time"",                 ARG_STRING},
-5.   {""M"",  ""manual"",                   ARG_BOOL},
-4.   {""n"",  ""netrc"",                    ARG_BOOL},
-3.   {""no"", ""netrc-optional"",           ARG_BOOL},
-2.   {""ne"", ""netrc-file"",               ARG_FILENAME},
-1.   {""N"",  ""buffer"",                   ARG_BOOL},

/*buffer' listed as --no-buffer in the help*/

1.   {""o"",  ""output"",                   ARG_FILENAME},
2.   {""O"",  ""remote-name"",              ARG_NONE},
3.   {""Oa"", ""remote-name-all"",          ARG_BOOL},
4.   {""Ob"", ""output-dir"",               ARG_STRING},
5.   {""Oc"", ""clobber"",                  ARG_BOOL},
6.   {""p"",  ""proxytunnel"",              ARG_BOOL},
7.   {""P"",  ""ftp-port"",                 ARG_STRING},
8.   {""q"",  ""disable"",                  ARG_BOOL},
9.   {""Q"",  ""quote"",                    ARG_STRING},
10.   {""r"",  ""range"",                    ARG_STRING},",Not Useful,1
"/*next less trivial: cert_parameter starts 'pkcs11:' and thus
   * looks like a RFC7512 PKCS#11 URI which can be used as-is.
   * Also if cert_parameter contains no colon nor backslash, this
   * means no passphrase was given and no characters escaped*/","-2.   if(param_length == 0)
-1.     return;

/*next less trivial: cert_parameter starts 'pkcs11:' and thus
   * looks like a RFC7512 PKCS#11 URI which can be used as-is.
   * Also if cert_parameter contains no colon nor backslash, this
   * means no passphrase was given and no characters escaped*/

1.   if(curl_strnequal(cert_parameter, ""pkcs11:"", 7) ||
2.      !strpbrk(cert_parameter, "":\\"")) {
3.     *certname = strdup(cert_parameter);
4.     return;
5.   }",Not Useful,0
"/*Get a size parameter for '--limit-rate' or '--max-filesize'.
 * We support a 'G', 'M' or 'K' suffix too.*/","-10.   char *certname, *passphrase;
-9.   parse_cert_parameter(nextarg, &certname, &passphrase);
-8.   Curl_safefree(*file);
-7.   *file = certname;
-6.   if(passphrase) {
-5.     Curl_safefree(*password);
-4.     *password = passphrase;
-3.   }
-2.   cleanarg(nextarg);
-1. }
/* Get a size parameter for '--limit-rate' or '--max-filesize'.
 * We support a 'G', 'M' or 'K' suffix too.

/*Get a size parameter for '--limit-rate' or '--max-filesize'.
 * We support a 'G', 'M' or 'K' suffix too.*/

1.   */
2. static ParameterError GetSizeParameter(struct GlobalConfig *global,
3.                                        const char *arg,
4.                                        const char *which,
5.                                        curl_off_t *value_out)
6. {
7.   char *unit;
8.   curl_off_t value;
9.   if(curlx_strtoofft(arg, &unit, 0, &value)) {
10.     warnf(global, ""invalid number specified for %s\n"", which);",Not Useful,1
/*unsupported*/,"-10. {
-9.   char *unit;
-8.   curl_off_t value;
-7.   if(curlx_strtoofft(arg, &unit, 0, &value)) {
-6.     warnf(global, ""invalid number specified for %s\n"", which);
-5.     return PARAM_BAD_USE;
-4.   }
-3.   if(!*unit)
-2.     unit = (char *)""b"";
-1.   else if(strlen(unit) > 1)

/*unsupported*/

1.   switch(*unit) {
2.   case 'G':
3.   case 'g':
4.     if(value > (CURL_OFF_T_MAX / (1024*1024*1024)))
5.       return PARAM_NUMBER_TOO_LARGE;
6.     value *= 1024*1024*1024;
7.     break;
8.   case 'M':
9.   case 'm':
10.     if(value > (CURL_OFF_T_MAX / (1024*1024)))",Not Useful,0
/*f or -long-flag*/,"-8.     break;
-7.   default:
-6.     warnf(global, ""unsupported %s unit. Use G, M, K or B!\n"", which);
-5.     return PARAM_BAD_USE;
-4.   }
-3.   *value_out = value;
-2.   return PARAM_OK;
-1. }

/*f or -long-flag*/

111",Not Useful,0
/*subletters can only occur on long options*/,"-4.                             struct GlobalConfig *global,
-3.                             struct OperationConfig *config)
-2. {
-1.   char letter;

/*subletters can only occur on long options*/

1.   int rc;
2.   const char *parse = NULL;
3.   unsigned int j;
4.   time_t now;
5.   int hit = -1;
6.   bool longopt = FALSE;",Not Useful,0
/*we can loop here if we have multiple single-letters*/,"-4.     hit = -1;
-3.     parse = flag;
-2.   }
-1.   do {

/*we can loop here if we have multiple single-letters*/

1.     if(!longopt) {
2.       letter = (char)*parse;
3.       subletter = '\0';
4.     }
5.     else {
6.       letter = parse[0];
7.       subletter = parse[1];
8.     }
9.     if(hit < 0) {
10.       for(j = 0; j < sizeof(aliases)/sizeof(aliases[0]); j++) {",Not Useful,1
/*don't loop anymore after this*/,"-2.       if(!longopt && parse[1]) {

/*don't loop anymore after this*/

1.       }
2.       else if(!nextarg)
3.         return PARAM_REQUIRES_PARAMETER;
4.       else",Not Useful,1
/*mark it as used*/,"-4.       }
-3.       else if(!nextarg)
-2.         return PARAM_REQUIRES_PARAMETER;
-1.       else

/*mark it as used*/

1.       if((aliases[hit].desc == ARG_FILENAME) &&
2.          (nextarg[0] == '-') && nextarg[1]) {",Not Useful,1
/*--dns-ipv4-addr*/,"-1.       switch(subletter) {

/*--dns-ipv4-addr*/

111",Not Useful,1
/*--dns-ipv6-addr*/,"-2.         GetStr(&config->dns_ipv4_addr, nextarg);
-1.         break;

/*--dns-ipv6-addr*/

111",Not Useful,1
/*random-file*/,"-3.   {""*@"", ""url"",                      ARG_STRING},
-2.   {""*4"", ""dns-ipv4-addr"",            ARG_STRING},
-1.   {""*6"", ""dns-ipv6-addr"",            ARG_STRING},
  {""*a"", ""random-file"",              ARG_FILENAME},

/*random-file*/

1.   {""*b"", ""egd-file"",                 ARG_STRING},
2.   {""*B"", ""oauth2-bearer"",            ARG_STRING},
3.   {""*c"", ""connect-timeout"",          ARG_STRING},
4.   {""*C"", ""doh-url""        ,          ARG_STRING},
5.   {""*d"", ""ciphers"",                  ARG_STRING},
6.   {""*D"", ""dns-interface"",            ARG_STRING},
7.   {""*e"", ""disable-epsv"",             ARG_BOOL},
8.   {""*f"", ""disallow-username-in-url"", ARG_BOOL},
9.   {""*E"", ""epsv"",                     ARG_BOOL},
10.          /* 'epsv' made like this to make --no-epsv and --epsv to work",Not Useful,1
/*egd-file*/,"-4.   {""*@"", ""url"",                      ARG_STRING},
-3.   {""*4"", ""dns-ipv4-addr"",            ARG_STRING},
-2.   {""*6"", ""dns-ipv6-addr"",            ARG_STRING},
-1.   {""*a"", ""random-file"",              ARG_FILENAME},
  {""*b"", ""egd-file"",                 ARG_STRING},

/*egd-file*/

1.   {""*B"", ""oauth2-bearer"",            ARG_STRING},
2.   {""*c"", ""connect-timeout"",          ARG_STRING},
3.   {""*C"", ""doh-url""        ,          ARG_STRING},
4.   {""*d"", ""ciphers"",                  ARG_STRING},
5.   {""*D"", ""dns-interface"",            ARG_STRING},
6.   {""*e"", ""disable-epsv"",             ARG_BOOL},
7.   {""*f"", ""disallow-username-in-url"", ARG_BOOL},
8.   {""*E"", ""epsv"",                     ARG_BOOL},",Not Useful,1
/*connect-timeout*/,"-6.   {""*@"", ""url"",                      ARG_STRING},
-5.   {""*4"", ""dns-ipv4-addr"",            ARG_STRING},
-4.   {""*6"", ""dns-ipv6-addr"",            ARG_STRING},
-3.   {""*a"", ""random-file"",              ARG_FILENAME},
-2.   {""*b"", ""egd-file"",                 ARG_STRING},
-1.   {""*B"", ""oauth2-bearer"",            ARG_STRING},
  {""*c"", ""connect-timeout"",          ARG_STRING},

/*connect-timeout*/

1.   {""*C"", ""doh-url""        ,          ARG_STRING},
2.   {""*d"", ""ciphers"",                  ARG_STRING},
3.   {""*D"", ""dns-interface"",            ARG_STRING},
4.   {""*e"", ""disable-epsv"",             ARG_BOOL},
5.   {""*f"", ""disallow-username-in-url"", ARG_BOOL},
6.   {""*E"", ""epsv"",                     ARG_BOOL},",Not Useful,1
/*doh-url*/,"-7.   {""*@"", ""url"",                      ARG_STRING},
-6.   {""*4"", ""dns-ipv4-addr"",            ARG_STRING},
-5.   {""*6"", ""dns-ipv6-addr"",            ARG_STRING},
-4.   {""*a"", ""random-file"",              ARG_FILENAME},
-3.   {""*b"", ""egd-file"",                 ARG_STRING},
-2.   {""*B"", ""oauth2-bearer"",            ARG_STRING},
-1.   {""*c"", ""connect-timeout"",          ARG_STRING},
  {""*C"", ""doh-url""        ,          ARG_STRING},

/*doh-url*/

1.   {""*d"", ""ciphers"",                  ARG_STRING},
2.   {""*D"", ""dns-interface"",            ARG_STRING},
3.   {""*e"", ""disable-epsv"",             ARG_BOOL},
4.   {""*f"", ""disallow-username-in-url"", ARG_BOOL},
5.   {""*E"", ""epsv"",                     ARG_BOOL},",Not Useful,1
/*--dns-interface*/,"-2.         GetStr(&config->cipher_list, nextarg);
-1.         break;

/*--dns-interface*/

111",Not Useful,1
/*interface name*/,"-1.           return PARAM_LIBCURL_DOESNT_SUPPORT;

/*interface name*/

1.         GetStr(&config->dns_interface, nextarg);
2.         break;",Not Useful,1
/*--disable-epsv*/,"-10.   {""*b"", ""egd-file"",                 ARG_STRING},
-9.   {""*B"", ""oauth2-bearer"",            ARG_STRING},
-8.   {""*c"", ""connect-timeout"",          ARG_STRING},
-7.   {""*C"", ""doh-url""        ,          ARG_STRING},
-6.   {""*d"", ""ciphers"",                  ARG_STRING},
-5.   {""*D"", ""dns-interface"",            ARG_STRING},
-4.   {""*e"", ""disable-epsv"",             ARG_BOOL},
-3.   {""*f"", ""disallow-username-in-url"", ARG_BOOL},
-2.   {""*E"", ""epsv"",                     ARG_BOOL},

/*--disable-epsv*/

1.   {""*F"", ""dns-servers"",              ARG_STRING},
2.   {""*g"", ""trace"",                    ARG_FILENAME},
3.   {""*G"", ""npn"",                      ARG_BOOL},
4.   {""*h"", ""trace-ascii"",              ARG_FILENAME},
5.   {""*H"", ""alpn"",                     ARG_BOOL},
6.   {""*i"", ""limit-rate"",               ARG_STRING},
7.   {""*j"", ""compressed"",               ARG_BOOL},
8.   {""*J"", ""tr-encoding"",              ARG_BOOL},
9.   {""*k"", ""digest"",                   ARG_BOOL},
10.   {""*l"", ""negotiate"",                ARG_BOOL},",Not Useful,1
/*--disallow-username-in-url*/,"-2.         config->disable_epsv = toggle;
-1.         break;

/*--disallow-username-in-url*/

1.         config->disallow_username_in_url = toggle;
2.         break;",Not Useful,0
/*--epsv*/,"-10.   {""*a"", ""random-file"",              ARG_FILENAME},
-9.   {""*b"", ""egd-file"",                 ARG_STRING},
-8.   {""*B"", ""oauth2-bearer"",            ARG_STRING},
-7.   {""*c"", ""connect-timeout"",          ARG_STRING},
-6.   {""*C"", ""doh-url""        ,          ARG_STRING},
-5.   {""*d"", ""ciphers"",                  ARG_STRING},
-4.   {""*D"", ""dns-interface"",            ARG_STRING},
-3.   {""*e"", ""disable-epsv"",             ARG_BOOL},
-2.   {""*f"", ""disallow-username-in-url"", ARG_BOOL},
-1.   {""*E"", ""epsv"",                     ARG_BOOL},
         /* 'epsv' made like this to make --no-epsv and --epsv to work

/*--epsv*/

1.              although --disable-epsv is the documented option */
2.   {""*F"", ""dns-servers"",              ARG_STRING},
3.   {""*g"", ""trace"",                    ARG_FILENAME},
4.   {""*G"", ""npn"",                      ARG_BOOL},
5.   {""*h"", ""trace-ascii"",              ARG_FILENAME},
6.   {""*H"", ""alpn"",                     ARG_BOOL},
7.   {""*i"", ""limit-rate"",               ARG_STRING},
8.   {""*j"", ""compressed"",               ARG_BOOL},
9.   {""*J"", ""tr-encoding"",              ARG_BOOL},
10.   {""*k"", ""digest"",                   ARG_BOOL},",Not Useful,0
/*--dns-servers*/,"-2.         config->disable_epsv = (!toggle)?TRUE:FALSE;
-1.         break;

/*--dns-servers*/

111",Not Useful,1
/*--trace*/,"-2.         GetStr(&config->dns_servers, nextarg);
-1.         break;

/*--trace*/

1.         GetStr(&global->trace_dump, nextarg);
2.         if(global->tracetype && (global->tracetype != TRACE_BIN))
3.           warnf(global, ""--trace overrides an earlier trace/verbose option\n"");
4.         global->tracetype = TRACE_BIN;
5.         break;",Not Useful,0
/*--npn*/,"-5.         GetStr(&global->trace_dump, nextarg);
-4.         if(global->tracetype && (global->tracetype != TRACE_BIN))
-3.           warnf(global, ""--trace overrides an earlier trace/verbose option\n"");
-2.         global->tracetype = TRACE_BIN;
-1.         break;

/*--npn*/

1.         config->nonpn = (!toggle)?TRUE:FALSE;
2.         break;",Not Useful,0
/*--trace-ascii*/,"-2.         config->nonpn = (!toggle)?TRUE:FALSE;
-1.         break;

/*--trace-ascii*/

1.         GetStr(&global->trace_dump, nextarg);
2.         if(global->tracetype && (global->tracetype != TRACE_ASCII))
3.           warnf(global,
4.                 ""--trace-ascii overrides an earlier trace/verbose option\n"");
5.         global->tracetype = TRACE_ASCII;
6.         break;",Not Useful,0
/*--alpn*/,"-6.         GetStr(&global->trace_dump, nextarg);
-5.         if(global->tracetype && (global->tracetype != TRACE_ASCII))
-4.           warnf(global,
-3.                 ""--trace-ascii overrides an earlier trace/verbose option\n"");
-2.         global->tracetype = TRACE_ASCII;
-1.         break;

/*--alpn*/

1.         config->noalpn = (!toggle)?TRUE:FALSE;
2.         break;",Not Useful,1
/*--limit-rate*/,"-10.   char *certname, *passphrase;
-9.   parse_cert_parameter(nextarg, &certname, &passphrase);
-8.   Curl_safefree(*file);
-7.   *file = certname;
-6.   if(passphrase) {
-5.     Curl_safefree(*password);
-4.     *password = passphrase;
-3.   }
-2.   cleanarg(nextarg);
-1. }
/* Get a size parameter for '--limit-rate' or '--max-filesize'.

/*--limit-rate*/

1.  * We support a 'G', 'M' or 'K' suffix too.
2.   */
3. static ParameterError GetSizeParameter(struct GlobalConfig *global,
4.                                        const char *arg,
5.                                        const char *which,
6.                                        curl_off_t *value_out)
7. {
8.   char *unit;
9.   curl_off_t value;
10.   if(curlx_strtoofft(arg, &unit, 0, &value)) {",Not Useful,1
/*--compressed*/,"-9.       {
-8.         curl_off_t value;
-7.         ParameterError pe = GetSizeParameter(global, nextarg, ""rate"", &value);
-6.         if(pe != PARAM_OK)
-5.            return pe;
-4.         config->recvpersecond = value;
-3.         config->sendpersecond = value;
-2.       }
-1.       break;

/*--compressed*/

1.         if(toggle &&
2.            !(curlinfo->features & (CURL_VERSION_LIBZ |
3.                                    CURL_VERSION_BROTLI | CURL_VERSION_ZSTD)))
4.           return PARAM_LIBCURL_DOESNT_SUPPORT;
5.         config->encoding = toggle;
6.         break;",Not Useful,0
/*--tr-encoding*/,"-6.         if(toggle &&
-5.            !(curlinfo->features & (CURL_VERSION_LIBZ |
-4.                                    CURL_VERSION_BROTLI | CURL_VERSION_ZSTD)))
-3.           return PARAM_LIBCURL_DOESNT_SUPPORT;
-2.         config->encoding = toggle;
-1.         break;

/*--tr-encoding*/

1.         config->tr_encoding = toggle;
2.         break;",Not Useful,1
/*--negotiate*/,"-5.         if(toggle)
-4.           config->authtype |= CURLAUTH_DIGEST;
-3.         else
-2.           config->authtype &= ~CURLAUTH_DIGEST;
-1.         break;

/*--negotiate*/

1.         if(toggle) {
2.           if(curlinfo->features & CURL_VERSION_SPNEGO)
3.             config->authtype |= CURLAUTH_NEGOTIATE;
4.           else
5.             return PARAM_LIBCURL_DOESNT_SUPPORT;
6.         }
7.         else
8.           config->authtype &= ~CURLAUTH_NEGOTIATE;
9.         break;",Not Useful,1
/*--ntlm*/,"-9.         if(toggle) {
-8.           if(curlinfo->features & CURL_VERSION_SPNEGO)
-7.             config->authtype |= CURLAUTH_NEGOTIATE;
-6.           else
-5.             return PARAM_LIBCURL_DOESNT_SUPPORT;
-4.         }
-3.         else
-2.           config->authtype &= ~CURLAUTH_NEGOTIATE;
-1.         break;

/*--ntlm*/

1.         if(toggle) {
2.           if(curlinfo->features & CURL_VERSION_NTLM)
3.             config->authtype |= CURLAUTH_NTLM;
4.           else
5.             return PARAM_LIBCURL_DOESNT_SUPPORT;
6.         }
7.         else
8.           config->authtype &= ~CURLAUTH_NTLM;
9.         break;",Not Useful,0
/*--ntlm-wb*/,"-9.         if(toggle) {
-8.           if(curlinfo->features & CURL_VERSION_NTLM)
-7.             config->authtype |= CURLAUTH_NTLM;
-6.           else
-5.             return PARAM_LIBCURL_DOESNT_SUPPORT;
-4.         }
-3.         else
-2.           config->authtype &= ~CURLAUTH_NTLM;
-1.         break;

/*--ntlm-wb*/

1.         if(toggle) {
2.           if(curlinfo->features & CURL_VERSION_NTLM_WB)
3.             config->authtype |= CURLAUTH_NTLM_WB;
4.           else
5.             return PARAM_LIBCURL_DOESNT_SUPPORT;
6.         }
7.         else
8.           config->authtype &= ~CURLAUTH_NTLM_WB;
9.         break;",Not Useful,1
"/*--anyauth, let libcurl pick it*/","-5.         if(toggle)
-4.           config->authtype |= CURLAUTH_BASIC;
-3.         else
-2.           config->authtype &= ~CURLAUTH_BASIC;
-1.         break;

/*--anyauth, let libcurl pick it*/

1.         if(toggle)
2.           config->authtype = CURLAUTH_ANY;",Not Useful,1
/*--no-anyauth simply doesn't touch it*/,"-2.         if(toggle)
-1.           config->authtype = CURLAUTH_ANY;

/*--no-anyauth simply doesn't touch it*/

1.         break;
2. #ifdef USE_WATT32",Not Useful,0
/*--wdebug*/,"-2.         break;
-1. #ifdef USE_WATT32

/*--wdebug*/

1.         dbug_init();
2.         break;
3. #endif",Not Useful,1
/*--ftp-create-dirs*/,"-3.         dbug_init();
-2.         break;
-1. #endif

/*--ftp-create-dirs*/

1.         config->ftp_create_dirs = toggle;
2.         break;",Not Useful,0
/*--create-dirs*/,"-2.         config->ftp_create_dirs = toggle;
-1.         break;

/*--create-dirs*/

1.         config->create_dirs = toggle;
2.         break;",Not Useful,1
/*--max-redirs*/,"-4.         err = oct2nummax(&config->create_file_mode, nextarg, 0777);
-3.         if(err)
-2.           return err;
-1.         break;

/*--max-redirs*/

111",Not Useful,0
/*--proxy-ntlm*/,"-6.         err = str2num(&config->maxredirs, nextarg);
-5.         if(err)
-4.           return err;
-3.         if(config->maxredirs < -1)
-2.           return PARAM_BAD_NUMERIC;
-1.         break;

/*--proxy-ntlm*/

1.         if(curlinfo->features & CURL_VERSION_NTLM)
2.           config->proxyntlm = toggle;
3.         else
4.           return PARAM_LIBCURL_DOESNT_SUPPORT;
5.         break;",Not Useful,1
/*--crlf*/,"-5.         if(curlinfo->features & CURL_VERSION_NTLM)
-4.           config->proxyntlm = toggle;
-3.         else
-2.           return PARAM_LIBCURL_DOESNT_SUPPORT;
-1.         break;

/*--crlf*/

111",Not Useful,1
/*LF -> CRLF conversion?*/,"-6.         if(curlinfo->features & CURL_VERSION_NTLM)
-5.           config->proxyntlm = toggle;
-4.         else
-3.           return PARAM_LIBCURL_DOESNT_SUPPORT;
-2.         break;

/*LF -> CRLF conversion?*/

1.         config->crlf = toggle;
2.         break;",Not Useful,1
/*--stderr*/,"-3.         config->authtype |= CURLAUTH_AWS_SIGV4;
-2.         GetStr(&config->aws_sigv4, nextarg);
-1.         break;

/*--stderr*/

1.         if(strcmp(nextarg, ""-"")) {
2.           FILE *newfile = fopen(nextarg, FOPEN_WRITETEXT);
3.           if(!newfile)
4.             warnf(global, ""Failed to open %s!\n"", nextarg);
5.           else {
6.             if(global->errors_fopened)
7.               fclose(global->errors);
8.             global->errors = newfile;
9.             global->errors_fopened = TRUE;
10.           }",Not Useful,1
/*--interface*/,"-10.           else {
-9.             if(global->errors_fopened)
-8.               fclose(global->errors);
-7.             global->errors = newfile;
-6.             global->errors_fopened = TRUE;
-5.           }
-4.         }
-3.         else
-2.           global->errors = stdout;
-1.         break;

/*--interface*/

111",Not Useful,0
/*interface*/,"-10.      mention. */
-9.   {""*@"", ""url"",                      ARG_STRING},
-8.   {""*4"", ""dns-ipv4-addr"",            ARG_STRING},
-7.   {""*6"", ""dns-ipv6-addr"",            ARG_STRING},
-6.   {""*a"", ""random-file"",              ARG_FILENAME},
-5.   {""*b"", ""egd-file"",                 ARG_STRING},
-4.   {""*B"", ""oauth2-bearer"",            ARG_STRING},
-3.   {""*c"", ""connect-timeout"",          ARG_STRING},
-2.   {""*C"", ""doh-url""        ,          ARG_STRING},
-1.   {""*d"", ""ciphers"",                  ARG_STRING},
  {""*D"", ""dns-interface"",            ARG_STRING},

/*interface*/

1.   {""*e"", ""disable-epsv"",             ARG_BOOL},
2.   {""*f"", ""disallow-username-in-url"", ARG_BOOL},
3.   {""*E"", ""epsv"",                     ARG_BOOL},",Not Useful,1
/*--krb*/,"-2.         GetStr(&config->iface, nextarg);
-1.         break;

/*--krb*/

111",Not Useful,1
/*--haproxy-protocol*/,"-5.         if(curlinfo->features & CURL_VERSION_SPNEGO)
-4.           GetStr(&config->krblevel, nextarg);
-3.         else
-2.           return PARAM_LIBCURL_DOESNT_SUPPORT;
-1.         break;

/*--haproxy-protocol*/

1.         config->haproxy_protocol = toggle;
2.         break;",Not Useful,0
/*--max-filesize*/,"-10.   char *certname, *passphrase;
-9.   parse_cert_parameter(nextarg, &certname, &passphrase);
-8.   Curl_safefree(*file);
-7.   *file = certname;
-6.   if(passphrase) {
-5.     Curl_safefree(*password);
-4.     *password = passphrase;
-3.   }
-2.   cleanarg(nextarg);
-1. }
/* Get a size parameter for '--limit-rate' or '--max-filesize'.

/*--max-filesize*/

1.  * We support a 'G', 'M' or 'K' suffix too.
2.   */
3. static ParameterError GetSizeParameter(struct GlobalConfig *global,
4.                                        const char *arg,
5.                                        const char *which,
6.                                        curl_off_t *value_out)
7. {
8.   char *unit;
9.   curl_off_t value;
10.   if(curlx_strtoofft(arg, &unit, 0, &value)) {",Not Useful,1
/*--disable-eprt*/,"-5.   {""*X"", ""haproxy-protocol"",         ARG_BOOL},
-4.   {""*y"", ""max-filesize"",             ARG_STRING},
-3.   {""*z"", ""disable-eprt"",             ARG_BOOL},
-2.   {""*Z"", ""eprt"",                     ARG_BOOL},

/*--disable-eprt*/

1.   {""*~"", ""xattr"",                    ARG_BOOL},
2.   {""$a"", ""ftp-ssl"",                  ARG_BOOL},",Not Useful,1
/*--eprt*/,"-4.   {""*X"", ""haproxy-protocol"",         ARG_BOOL},
-3.   {""*y"", ""max-filesize"",             ARG_STRING},
-2.   {""*z"", ""disable-eprt"",             ARG_BOOL},
-1.   {""*Z"", ""eprt"",                     ARG_BOOL},
         /* 'eprt' made like this to make --no-eprt and --eprt to work

/*--eprt*/

1.              although --disable-eprt is the documented option */
2.   {""*~"", ""xattr"",                    ARG_BOOL},
3.   {""$a"", ""ftp-ssl"",                  ARG_BOOL},",Not Useful,1
/*--xattr*/,"-2.         config->disable_eprt = (!toggle)?TRUE:FALSE;
-1.         break;

/*--xattr*/

1.         config->xattr = toggle;
2.         break;",Not Useful,1
/*the URL!*/,"-2.         config->xattr = toggle;
-1.         break;

/*the URL!*/

1.       {
2.         struct getout *url;
3.         if(!config->url_get)
4.           config->url_get = config->url_list;
5.         if(config->url_get) {",Not Useful,1
/*fill in the URL*/,"-3.           config->url_get = url = new_getout(config);
-2.         if(!url)
-1.           return PARAM_NO_MEM;

/*fill in the URL*/

1.         GetStr(&url->url, nextarg);
2.         url->flags |= GETOUT_URL;
3.       }
4.       }
5.       break;",Not Useful,1
"/*--socks5-hostname specifies a socks5 proxy and enables name
                   resolving with the proxy*/","-3.         GetStr(&config->proxy, nextarg);
-2.         config->proxyver = CURLPROXY_SOCKS4A;
-1.         break;

/*--socks5-hostname specifies a socks5 proxy and enables name
                   resolving with the proxy*/

1.         GetStr(&config->proxy, nextarg);
2.         config->proxyver = CURLPROXY_SOCKS5_HOSTNAME;
3.         break;",Not Useful,1
/*--tcp-nodelay option*/,"-3.         GetStr(&config->proxy, nextarg);
-2.         config->proxyver = CURLPROXY_SOCKS5_HOSTNAME;
-1.         break;

/*--tcp-nodelay option*/

1.         config->tcp_nodelay = toggle;
2.         break;",Not Useful,1
/*--proxy-digest*/,"-2.         config->tcp_nodelay = toggle;
-1.         break;

/*--proxy-digest*/

1.         config->proxydigest = toggle;
2.         break;",Not Useful,1
/*--proxy-basic*/,"-2.         config->proxydigest = toggle;
-1.         break;

/*--proxy-basic*/

1.         config->proxybasic = toggle;
2.         break;",Not Useful,1
/*--retry-connrefused*/,"-4.         err = str2unum(&config->req_retry, nextarg);
-3.         if(err)
-2.           return err;
-1.         break;

/*--retry-connrefused*/

1.         config->retry_connrefused = toggle;
2.         break;",Not Useful,1
/*--retry-delay*/,"-2.         config->retry_connrefused = toggle;
-1.         break;

/*--retry-delay*/

1.         err = str2unummax(&config->retry_delay, nextarg, LONG_MAX/1000);
2.         if(err)
3.           return err;
4.         break;",Not Useful,1
/*--retry-max-time*/,"-4.         err = str2unummax(&config->retry_delay, nextarg, LONG_MAX/1000);
-3.         if(err)
-2.           return err;
-1.         break;

/*--retry-max-time*/

1.         err = str2unummax(&config->retry_maxtime, nextarg, LONG_MAX/1000);
2.         if(err)
3.           return err;
4.         break;",Not Useful,1
/*--proxy-negotiate*/,"-2.         config->retry_all_errors = toggle;
-1.         break;

/*--proxy-negotiate*/

1.         if(curlinfo->features & CURL_VERSION_SPNEGO)
2.           config->proxynegotiate = toggle;
3.         else
4.           return PARAM_LIBCURL_DOESNT_SUPPORT;
5.         break;",Not Useful,0
/*--ftp-account*/,"-4.         config->mime_options &= ~CURLMIMEOPT_FORMESCAPE;
-3.         if(toggle)
-2.           config->mime_options |= CURLMIMEOPT_FORMESCAPE;
-1.         break;

/*--ftp-account*/

1.         GetStr(&config->ftp_account, nextarg);
2.         break;",Not Useful,0
/*--proxy-anyauth*/,"-2.         GetStr(&config->ftp_account, nextarg);
-1.         break;

/*--proxy-anyauth*/

1.         config->proxyanyauth = toggle;
2.         break;",Not Useful,1
/*--trace-time*/,"-2.         config->proxyanyauth = toggle;
-1.         break;

/*--trace-time*/

1.         global->tracetime = toggle;
2.         break;",Not Useful,1
/*--ignore-content-length*/,"-2.         global->tracetime = toggle;
-1.         break;

/*--ignore-content-length*/

1.         config->ignorecl = toggle;
2.         break;",Not Useful,1
/*--local-port*/,"-2.         config->ftp_filemethod = ftpfilemethod(config, nextarg);
-1.         break;

/*--local-port*/

111",Not Useful,1
/*--ftp-alternative-to-user*/,"-10.         else {
-9.           err = str2unum(&config->localportrange, lrange);
-8.           if(err || (config->localportrange > 65535))
-7.             return PARAM_BAD_USE;
-6.           config->localportrange -= (config->localport-1);
-5.           if(config->localportrange < 1)
-4.             return PARAM_BAD_USE;
-3.         }
-2.         break;
-1.       }

/*--ftp-alternative-to-user*/

1.         GetStr(&config->ftp_alternative_to_user, nextarg);
2.         break;",Not Useful,0
/*--ftp-ssl-control*/,"-2.         config->disable_sessionid = (!toggle)?TRUE:FALSE;
-1.         break;

/*--ftp-ssl-control*/

1.         if(toggle && !(curlinfo->features & CURL_VERSION_SSL))
2.           return PARAM_LIBCURL_DOESNT_SUPPORT;
3.         config->ftp_ssl_control = toggle;
4.         break;",Not Useful,0
/*--ftp-ssl-ccc*/,"-4.         if(toggle && !(curlinfo->features & CURL_VERSION_SSL))
-3.           return PARAM_LIBCURL_DOESNT_SUPPORT;
-2.         config->ftp_ssl_control = toggle;
-1.         break;

/*--ftp-ssl-ccc*/

1.         config->ftp_ssl_ccc = toggle;
2.         if(!config->ftp_ssl_ccc_mode)
3.           config->ftp_ssl_ccc_mode = CURLFTPSSL_CCC_PASSIVE;
4.         break;",Not Useful,1
/*--ftp-ssl-ccc-mode*/,"-4.         config->ftp_ssl_ccc = toggle;
-3.         if(!config->ftp_ssl_ccc_mode)
-2.           config->ftp_ssl_ccc_mode = CURLFTPSSL_CCC_PASSIVE;
-1.         break;

/*--ftp-ssl-ccc-mode*/

1.         config->ftp_ssl_ccc = TRUE;
2.         config->ftp_ssl_ccc_mode = ftpcccmethod(config, nextarg);
3.         break;",Not Useful,0
/*--raw*/,"-8. #ifdef CURL_DISABLE_LIBCURL_OPTION
-7.         warnf(global,
-6.               ""--libcurl option was disabled at build-time!\n"");
-5.         return PARAM_OPTION_UNKNOWN;
-4. #else
-3.         GetStr(&global->libcurl, nextarg);
-2.         break;
-1. #endif

/*--raw*/

1.         config->raw = toggle;
2.         break;",Not Useful,1
/*--post301*/,"-2.         config->raw = toggle;
-1.         break;

/*--post301*/

1.         config->post301 = toggle;
2.         break;",Not Useful,0
/*--no-keepalive*/,"-7.   {""$x"", ""ftp-ssl-control"",          ARG_BOOL},
-6.   {""$y"", ""ftp-ssl-ccc"",              ARG_BOOL},
-5.   {""$j"", ""ftp-ssl-ccc-mode"",         ARG_STRING},
-4.   {""$z"", ""libcurl"",                  ARG_STRING},
-3.   {""$#"", ""raw"",                      ARG_BOOL},
-2.   {""$0"", ""post301"",                  ARG_BOOL},
-1.   {""$1"", ""keepalive"",                ARG_BOOL},

/*--no-keepalive*/

1.   {""$2"", ""socks5-hostname"",          ARG_STRING},
2.   {""$3"", ""keepalive-time"",           ARG_STRING},
3.   {""$4"", ""post302"",                  ARG_BOOL},
4.   {""$5"", ""noproxy"",                  ARG_STRING},
5.   {""$7"", ""socks5-gssapi-nec"",        ARG_BOOL},
6.   {""$8"", ""proxy1.0"",                 ARG_STRING},
7.   {""$9"", ""tftp-blksize"",             ARG_STRING},
8.   {""$A"", ""mail-from"",                ARG_STRING},
9.   {""$B"", ""mail-rcpt"",                ARG_STRING},
10.   {""$C"", ""ftp-pret"",                 ARG_BOOL},",Not Useful,1
/*--keepalive-time*/,"-2.         config->nokeepalive = (!toggle)?TRUE:FALSE;
-1.         break;

/*--keepalive-time*/

1.         err = str2unum(&config->alivetime, nextarg);
2.         if(err)
3.           return err;
4.         break;",Not Useful,1
/*--post302*/,"-4.         err = str2unum(&config->alivetime, nextarg);
-3.         if(err)
-2.           return err;
-1.         break;

/*--post302*/

1.         config->post302 = toggle;
2.         break;",Not Useful,1
/*--post303*/,"-2.         config->post302 = toggle;
-1.         break;

/*--post303*/

1.         config->post303 = toggle;
2.         break;",Not Useful,1
/*--noproxy*/,"-2.         config->post303 = toggle;
-1.         break;

/*--noproxy*/

111",Not Useful,1
/*--socks5-gssapi-nec*/,"-2.         GetStr(&config->noproxy, nextarg);
-1.         break;

/*--socks5-gssapi-nec*/

1.         config->socks5_gssapi_nec = toggle;
2.         break;",Not Useful,1
/*--proxy1.0*/,"-2.         config->socks5_gssapi_nec = toggle;
-1.         break;

/*--proxy1.0*/

111",Not Useful,0
/*http 1.0 proxy*/,"-3.         config->socks5_gssapi_nec = toggle;
-2.         break;

/*http 1.0 proxy*/

1.         GetStr(&config->proxy, nextarg);
2.         config->proxyver = CURLPROXY_HTTP_1_0;
3.         break;",Not Useful,1
/*--tftp-blksize*/,"-3.         GetStr(&config->proxy, nextarg);
-2.         config->proxyver = CURLPROXY_HTTP_1_0;
-1.         break;

/*--tftp-blksize*/

1.         err = str2unum(&config->tftp_blksize, nextarg);
2.         if(err)
3.           return err;
4.         break;",Not Useful,1
/*--mail-from*/,"-4.         err = str2unum(&config->tftp_blksize, nextarg);
-3.         if(err)
-2.           return err;
-1.         break;

/*--mail-from*/

1.         GetStr(&config->mail_from, nextarg);
2.         break;",Not Useful,0
/*--mail-rcpt*/,"-2.         GetStr(&config->mail_from, nextarg);
-1.         break;

/*--mail-rcpt*/

111",Not Useful,0
/*--ftp-pret*/,"-4.         err = add2list(&config->mail_rcpt, nextarg);
-3.         if(err)
-2.           return err;
-1.         break;

/*--ftp-pret*/

1.         config->ftp_pret = toggle;
2.         break;",Not Useful,1
/*--proto*/,"-2.         config->ftp_pret = toggle;
-1.         break;

/*--proto*/

1.         config->proto_present = TRUE;
2.         if(proto2num(config, &config->proto, nextarg))
3.           return PARAM_BAD_USE;
4.         break;",Not Useful,1
/*--proto-redir*/,"-4.         config->proto_present = TRUE;
-3.         if(proto2num(config, &config->proto, nextarg))
-2.           return PARAM_BAD_USE;
-1.         break;

/*--proto-redir*/

1.         config->proto_redir_present = TRUE;
2.         if(proto2num(config, &config->proto_redir, nextarg))
3.           return PARAM_BAD_USE;
4.         break;",Not Useful,1
/*--resolve*/,"-4.         config->proto_redir_present = TRUE;
-3.         if(proto2num(config, &config->proto_redir, nextarg))
-2.           return PARAM_BAD_USE;
-1.         break;

/*--resolve*/

1.         err = add2list(&config->resolve, nextarg);
2.         if(err)
3.           return err;
4.         break;",Not Useful,1
/*--mail-auth*/,"-2.         config->gssapi_delegation = delegation(config, nextarg);
-1.         break;

/*--mail-auth*/

1.         GetStr(&config->mail_auth, nextarg);
2.         break;",Not Useful,1
/*--sasl-authzid*/,"-2.         errorf(global, ""--metalink is disabled\n"");
-1.         return PARAM_BAD_USE;

/*--sasl-authzid*/

1.         GetStr(&config->sasl_authzid, nextarg);
2.         break;",Not Useful,1
/*--sasl-ir*/,"-2.         GetStr(&config->sasl_authzid, nextarg);
-1.         break;

/*--sasl-ir*/

1.         config->sasl_ir = toggle;
2.         break;",Not Useful,1
/*--test-event*/,"-2.         config->sasl_ir = toggle;
-1.         break;

/*--test-event*/

1. #ifdef CURLDEBUG
2.         global->test_event_based = toggle;
3. #else
4.         warnf(global, ""--test-event is ignored unless a debug build!\n"");
5. #endif
6.         break;",Not Useful,1
/*--unix-socket*/,"-6. #ifdef CURLDEBUG
-5.         global->test_event_based = toggle;
-4. #else
-3.         warnf(global, ""--test-event is ignored unless a debug build!\n"");
-2. #endif
-1.         break;

/*--unix-socket*/

1.         config->abstract_unix_socket = FALSE;
2.         GetStr(&config->unix_socket_path, nextarg);
3.         break;",Not Useful,1
/*--path-as-is*/,"-3.         config->abstract_unix_socket = FALSE;
-2.         GetStr(&config->unix_socket_path, nextarg);
-1.         break;

/*--path-as-is*/

1.         config->path_as_is = toggle;
2.         break;",Not Useful,1
/*--proxy-service-name*/,"-2.         config->path_as_is = toggle;
-1.         break;

/*--proxy-service-name*/

1.         GetStr(&config->proxy_service_name, nextarg);
2.         break;",Not Useful,1
/*--service-name*/,"-2.         GetStr(&config->proxy_service_name, nextarg);
-1.         break;

/*--service-name*/

1.         GetStr(&config->service_name, nextarg);
2.         break;",Not Useful,1
/*--proto-default*/,"-2.         GetStr(&config->service_name, nextarg);
-1.         break;

/*--proto-default*/

1.         GetStr(&config->proto_default, nextarg);
2.         err = check_protocol(config->proto_default);
3.         if(err)
4.           return err;
5.         break;",Not Useful,0
/*--expect100-timeout*/,"-5.         GetStr(&config->proto_default, nextarg);
-4.         err = check_protocol(config->proto_default);
-3.         if(err)
-2.           return err;
-1.         break;

/*--expect100-timeout*/

1.         err = str2udouble(&config->expect100timeout, nextarg, LONG_MAX/1000);
2.         if(err)
3.           return err;
4.         break;",Not Useful,0
/*--tftp-no-options*/,"-4.         err = str2udouble(&config->expect100timeout, nextarg, LONG_MAX/1000);
-3.         if(err)
-2.           return err;
-1.         break;

/*--tftp-no-options*/

1.         config->tftp_no_options = toggle;
2.         break;",Not Useful,1
/*--connect-to*/,"-2.         config->tftp_no_options = toggle;
-1.         break;

/*--connect-to*/

1.         err = add2list(&config->connect_to, nextarg);
2.         if(err)
3.           return err;
4.         break;",Not Useful,1
/*--abstract-unix-socket*/,"-4.         err = add2list(&config->connect_to, nextarg);
-3.         if(err)
-2.           return err;
-1.         break;

/*--abstract-unix-socket*/

1.         config->abstract_unix_socket = TRUE;
2.         GetStr(&config->unix_socket_path, nextarg);
3.         break;",Not Useful,1
/*--tls-max*/,"-3.         config->abstract_unix_socket = TRUE;
-2.         GetStr(&config->unix_socket_path, nextarg);
-1.         break;

/*--tls-max*/

1.         err = str2tls_max(&config->ssl_version_max, nextarg);
2.         if(err)
3.           return err;
4.         break;",Not Useful,1
/*--suppress-connect-headers*/,"-4.         err = str2tls_max(&config->ssl_version_max, nextarg);
-3.         if(err)
-2.           return err;
-1.         break;

/*--suppress-connect-headers*/

1.         config->suppress_connect_headers = toggle;
2.         break;",Not Useful,1
/*--compressed-ssh*/,"-2.         config->suppress_connect_headers = toggle;
-1.         break;

/*--compressed-ssh*/

1.         config->ssh_compression = toggle;
2.         break;",Not Useful,1
/*--happy-eyeballs-timeout-ms*/,"-2.         config->ssh_compression = toggle;
-1.         break;

/*--happy-eyeballs-timeout-ms*/

1.         err = str2unum(&config->happy_eyeballs_timeout_ms, nextarg);
2.         if(err)
3.           return err;",Not Useful,1
/*--progress-meter*/,"-5.         break;
-4.       }
-3.       break;
-2.     case '#':
-1.       switch(subletter) {

/*--progress-meter*/

1.         global->noprogress = !toggle;
2.         break;",Not Useful,1
/*--http2-prior-knowledge*/,"-2.         config->httpversion = CURL_HTTP_VERSION_2_0;
-1.         break;

/*--http2-prior-knowledge*/

111",Not Useful,0
/*This specifies the User-Agent name*/,"-3.       config->ftp_append = toggle;
-2.       break;
-1.     case 'A':

/*This specifies the User-Agent name*/

1.       GetStr(&config->useragent, nextarg);
2.       break;
3.     case 'b':
4.       switch(subletter) {",Not Useful,1
/*--alt-svc*/,"-4.       GetStr(&config->useragent, nextarg);
-3.       break;
-2.     case 'b':
-1.       switch(subletter) {

/*--alt-svc*/

1.         if(curlinfo->features & CURL_VERSION_ALTSVC)
2.           GetStr(&config->altsvc, nextarg);
3.         else
4.           return PARAM_LIBCURL_DOESNT_SUPPORT;
5.         break;",Not Useful,1
/*We have a cookie file to read from!*/,"-5.           err = add2list(&config->cookies, nextarg);
-4.           if(err)
-3.             return err;
-2.           break;
-1.         }

/*We have a cookie file to read from!*/

1.         err = add2list(&config->cookiefiles, nextarg);
2.         if(err)
3.           return err;
4.       }
5.       break;
6.     case 'B':",Not Useful,1
/*use ASCII/text when transferring*/,"-6.         err = add2list(&config->cookiefiles, nextarg);
-5.         if(err)
-4.           return err;
-3.       }
-2.       break;
-1.     case 'B':

/*use ASCII/text when transferring*/

1.       config->use_ascii = toggle;
2.       break;
3.     case 'c':",Not Useful,1
/*postfield data*/,"-10.           return err;
-9.         config->resume_from_current = FALSE;
-8.       }
-7.       else {
-6.         config->resume_from_current = TRUE;
-5.         config->resume_from = 0;
-4.       }
-3.       config->use_resume = TRUE;
-2.       break;
-1.     case 'd':

/*postfield data*/

1.     {
2.       char *postdata = NULL;
3.       FILE *file;
4.       size_t size = 0;
5.       bool raw_mode = (subletter == 'r');",Not Useful,0
/*--data-urlencode*/,"-5.     {
-4.       char *postdata = NULL;
-3.       FILE *file;
-2.       size_t size = 0;
-1.       bool raw_mode = (subletter == 'r');

/*--data-urlencode*/

111",Not Useful,0
/*pass the @*/,"-10.             curl_free(enc);
-9.             postdata = n;
-8.           }
-7.           else
-6.             return PARAM_NO_MEM;
-5.         }
-4.       }
-3.       else if('@' == *nextarg && !raw_mode) {

/*pass the @*/

1.         if(!strcmp(""-"", nextarg)) {
2.           file = stdin;",Not Useful,0
/*forced data-binary*/,"-2.         if(!strcmp(""-"", nextarg)) {
-1.           file = stdin;

/*forced data-binary*/

1.             set_binmode(stdin);
2.         }
3.         else {
4.           file = fopen(nextarg, ""rb"");
5.           if(!file)
6.             warnf(global, ""Couldn't read data from file \""%s\"", this makes ""
7.                   ""an empty POST.\n"", nextarg);
8.         }",Not Useful,0
"/*Automatic referer requested, this may be combined with a
           set initial one*/","-6.       GetStr(&config->headerfile, nextarg);
-5.       break;
-4.     case 'e':
-3.     {
-2.       char *ptr = strstr(nextarg, "";auto"");
-1.       if(ptr) {

/*Automatic referer requested, this may be combined with a
           set initial one*/

1.         config->autoreferer = TRUE;",Not Useful,1
/*cert file type*/,"-2.         GetStr(&config->cacert, nextarg);
-1.         break;

/*cert file type*/

1.         GetStr(&config->cert_type, nextarg);
2.         break;",Not Useful,0
/*CRL file*/,"-2.         GetStr(&config->hostpubsha256, nextarg);
-1.         break;

/*CRL file*/

1.         GetStr(&config->crlfile, nextarg);
2.         break;",Not Useful,1
/*TLS username*/,"-2.         GetStr(&config->crlfile, nextarg);
-1.         break;

/*TLS username*/

1.         if(!(curlinfo->features & CURL_VERSION_TLSAUTH_SRP)) {
2.           cleanarg(nextarg);
3.           return PARAM_LIBCURL_DOESNT_SUPPORT;
4.         }
5.         GetStr(&config->tls_username, nextarg);
6.         cleanarg(nextarg);
7.         break;",Not Useful,1
/*TLS password*/,"-7.         if(!(curlinfo->features & CURL_VERSION_TLSAUTH_SRP)) {
-6.           cleanarg(nextarg);
-5.           return PARAM_LIBCURL_DOESNT_SUPPORT;
-4.         }
-3.         GetStr(&config->tls_username, nextarg);
-2.         cleanarg(nextarg);
-1.         break;

/*TLS password*/

1.         if(!(curlinfo->features & CURL_VERSION_TLSAUTH_SRP)) {
2.           cleanarg(nextarg);
3.           return PARAM_LIBCURL_DOESNT_SUPPORT;
4.         }
5.         GetStr(&config->tls_password, nextarg);
6.         cleanarg(nextarg);
7.         break;",Not Useful,1
"/*no empty SSL fragments, --ssl-allow-beast*/","-4.         }
-3.         else
-2.           return PARAM_LIBCURL_DOESNT_SUPPORT;
-1.         break;

/*no empty SSL fragments, --ssl-allow-beast*/

1.         if(curlinfo->features & CURL_VERSION_SSL)
2.           config->ssl_allow_beast = toggle;
3.         break;",Not Useful,1
/*--cert-status*/,"-2.         GetStr(&config->proxy_pinnedpubkey, nextarg);
-1.         break;

/*--cert-status*/

1.         config->verifystatus = TRUE;
2.         break;",Not Useful,1
/*--false-start*/,"-2.         config->doh_verifystatus = TRUE;
-1.         break;

/*--false-start*/

1.         config->falsestart = TRUE;
2.         break;",Not Useful,1
/*--ssl-no-revoke*/,"-2.         config->falsestart = TRUE;
-1.         break;

/*--ssl-no-revoke*/

1.         if(curlinfo->features & CURL_VERSION_SSL)
2.           config->ssl_no_revoke = TRUE;
3.         break;",Not Useful,1
/*--tcp-fastopen*/,"-3.         if(curlinfo->features & CURL_VERSION_SSL)
-2.           config->ssl_revoke_best_effort = TRUE;
-1.         break;

/*--tcp-fastopen*/

1.         config->tcp_fastopen = TRUE;
2.         break;",Not Useful,1
/*TLS username for proxy*/,"-2.         config->tcp_fastopen = TRUE;
-1.         break;

/*TLS username for proxy*/

1.         if(!(curlinfo->features & CURL_VERSION_TLSAUTH_SRP)) {
2.           cleanarg(nextarg);
3.           return PARAM_LIBCURL_DOESNT_SUPPORT;
4.         }
5.         GetStr(&config->proxy_tls_username, nextarg);
6.         cleanarg(nextarg);
7.         break;",Not Useful,1
/*TLS password for proxy*/,"-7.         if(!(curlinfo->features & CURL_VERSION_TLSAUTH_SRP)) {
-6.           cleanarg(nextarg);
-5.           return PARAM_LIBCURL_DOESNT_SUPPORT;
-4.         }
-3.         GetStr(&config->proxy_tls_username, nextarg);
-2.         cleanarg(nextarg);
-1.         break;

/*TLS password for proxy*/

1.         if(!(curlinfo->features & CURL_VERSION_TLSAUTH_SRP)) {
2.           cleanarg(nextarg);
3.           return PARAM_LIBCURL_DOESNT_SUPPORT;
4.         }
5.         GetStr(&config->proxy_tls_password, nextarg);
6.         cleanarg(nextarg);
7.         break;",Not Useful,1
/*cert file type for proxy*/,"-3.         GetFileAndPassword(nextarg, &config->proxy_cert,
-2.                            &config->proxy_key_passwd);
-1.         break;

/*cert file type for proxy*/

1.         GetStr(&config->proxy_cert_type, nextarg);
2.         break;",Not Useful,0
/*CRL file for proxy*/,"-2.         GetStr(&config->proxy_cipher_list, nextarg);
-1.         break;

/*CRL file for proxy*/

1.         GetStr(&config->proxy_crlfile, nextarg);
2.         break;",Not Useful,1
/*--login-options*/,"-3.         if(curlinfo->features & CURL_VERSION_SSL)
-2.           config->proxy_ssl_allow_beast = toggle;
-1.         break;

/*--login-options*/

1.         GetStr(&config->login_options, nextarg);
2.         break;",Not Useful,0
/*--socks5-basic*/,"-3.         config->proxy_ssl_version = CURL_SSLVERSION_TLSv1;
-2.         break;
-1.       case 'A':

/*--socks5-basic*/

1.         if(toggle)
2.           config->socks5_auth |= CURLAUTH_BASIC;
3.         else
4.           config->socks5_auth &= ~CURLAUTH_BASIC;
5.         break;
6.       case 'B':",Not Useful,1
/*--socks5-gssapi*/,"-2.         GetStr(&config->noproxy, nextarg);
-1.         break;

/*--socks5-gssapi*/

1.         config->socks5_gssapi_nec = toggle;
2.         break;",Not Useful,1
/*unknown flag*/,"-10.         break;
-9.       case 'C':
-8.         GetStr(&config->etag_save_file, nextarg);
-7.         break;
-6.       case 'D':
-5.         GetStr(&config->etag_compare_file, nextarg);
-4.         break;
-3.       case 'E':
-2.         GetStr(&config->ssl_ec_curves, nextarg);
-1.         break;

/*unknown flag*/

1.         return PARAM_OPTION_UNKNOWN;
2.       }
3.       break;
4.     case 'f':
5.       switch(subletter) {",Not Useful,1
/*--fail-early*/,"-5.         return PARAM_OPTION_UNKNOWN;
-4.       }
-3.       break;
-2.     case 'f':
-1.       switch(subletter) {

/*--fail-early*/

1.         global->fail_early = toggle;
2.         break;",Not Useful,0
/*--styled-output*/,"-2.         global->fail_early = toggle;
-1.         break;

/*--styled-output*/

1.         global->styled_output = toggle;
2.         break;",Not Useful,0
/*--fail (hard on errors)*/,"-2.         config->rm_partial = toggle;
-1.         break;

/*--fail (hard on errors)*/

1.         config->failonerror = toggle;
2.         break;
3.       }
4.       if(config->failonerror && config->failwithbody) {
5.         errorf(config->global, ""You must select either --fail or ""
6.                ""--fail-with-body, not both.\n"");
7.         return PARAM_BAD_USE;
8.       }
9.       break;
10.     case 'F':",Not Useful,1
/*g disables URLglobbing*/,"-4.         return PARAM_BAD_USE;
-3.       if(SetHTTPrequest(config, HTTPREQ_MIMEPOST, &config->httpreq))
-2.         return PARAM_BAD_USE;
-1.       break;

/*g disables URLglobbing*/

1.       config->globoff = toggle;
2.       break;",Not Useful,1
/*HTTP GET*/,"-2.       config->globoff = toggle;
-1.       break;

/*HTTP GET*/

111",Not Useful,1
/*--request-target*/,"-3.       config->globoff = toggle;
-2.       break;

/*--request-target*/

1.         GetStr(&config->request_target, nextarg);
2.       }
3.       else
4.         config->use_httpget = TRUE;
5.       break;",Not Useful,0
/*Allow strtok() here since this isn't used threaded*/,"-9.         char *string;
-8.         size_t len;
-7.         bool use_stdin = !strcmp(&nextarg[1], ""-"");
-6.         FILE *file = use_stdin?stdin:fopen(&nextarg[1], FOPEN_READTEXT);
-5.         if(!file)
-4.           warnf(global, ""Failed to open %s!\n"", &nextarg[1]);
-3.         else {
-2.           err = file2memory(&string, &len, file);
-1.           if(!err && string) {

/*Allow strtok() here since this isn't used threaded*/

111",Not Useful,0
/*!checksrc! disable BANNEDFUNC 2*/,"-10.         char *string;
-9.         size_t len;
-8.         bool use_stdin = !strcmp(&nextarg[1], ""-"");
-7.         FILE *file = use_stdin?stdin:fopen(&nextarg[1], FOPEN_READTEXT);
-6.         if(!file)
-5.           warnf(global, ""Failed to open %s!\n"", &nextarg[1]);
-4.         else {
-3.           err = file2memory(&string, &len, file);
-2.           if(!err && string) {

/*!checksrc! disable BANNEDFUNC 2*/

1.             char *h = strtok(string, ""\r\n"");
2.             while(h) {",Not Useful,1
/*--proxy-header*/,"-2.             char *h = strtok(string, ""\r\n"");
-1.             while(h) {

/*--proxy-header*/

1.                 err = add2list(&config->proxyheaders, h);
2.               else
3.                 err = add2list(&config->headers, h);
4.               if(err)
5.                 break;
6.               h = strtok(NULL, ""\r\n"");
7.             }
8.             free(string);
9.           }
10.           if(!use_stdin)",Not Useful,0
/*--proxy-header*/,"-2.             char *h = strtok(string, ""\r\n"");
-1.             while(h) {

/*--proxy-header*/

1.                 err = add2list(&config->proxyheaders, h);
2.               else
3.                 err = add2list(&config->headers, h);
4.               if(err)
5.                 break;
6.               h = strtok(NULL, ""\r\n"");
7.             }
8.             free(string);
9.           }
10.           if(!use_stdin)",Not Useful,1
/*parse config file*/,"-4.         config->doh_insecure_ok = toggle;
-3.       else
-2.         config->insecure_ok = toggle;
-1.       break;

/*parse config file*/

1.       if(parseconfig(nextarg, global)) {
2.         errorf(global, ""cannot read config from '%s'\n"", nextarg);
3.         return PARAM_READ_ERROR;
4.       }
5.       break;
6.     case 'l':",Not Useful,1
/*--no-manual shows no manual...*/,"-5.       err = str2udouble(&config->timeout, nextarg, LONG_MAX/1000);
-4.       if(err)
-3.         return err;
-2.       break;

/*--no-manual shows no manual...*/

1. #ifdef USE_MANUAL
2.         return PARAM_MANUAL_REQUESTED;
3. #else
4.         warnf(global,
5.               ""built-in manual was disabled at build-time!\n"");
6.         return PARAM_OPTION_UNKNOWN;
7. #endif
8.       }
9.       break;
10.     case 'n':",Not Useful,1
/*netrc-file*/,"-10.   {""k"",  ""insecure"",                 ARG_BOOL},
-9.   {""kd"", ""doh-insecure"",             ARG_BOOL},
-8.   {""K"",  ""config"",                   ARG_FILENAME},
-7.   {""l"",  ""list-only"",                ARG_BOOL},
-6.   {""L"",  ""location"",                 ARG_BOOL},
-5.   {""Lt"", ""location-trusted"",         ARG_BOOL},
-4.   {""m"",  ""max-time"",                 ARG_STRING},
-3.   {""M"",  ""manual"",                   ARG_BOOL},
-2.   {""n"",  ""netrc"",                    ARG_BOOL},
-1.   {""no"", ""netrc-optional"",           ARG_BOOL},
  {""ne"", ""netrc-file"",               ARG_FILENAME},

/*netrc-file*/

1.   {""N"",  ""buffer"",                   ARG_BOOL},",Not Useful,1
/*FALLTHROUGH*/,"-3.         config->file_clobber_mode = toggle ? CLOBBER_ALWAYS : CLOBBER_NEVER;
-2.         break;
-1.       }

/*FALLTHROUGH*/

111",Not Useful,0
/*fill in the outfile*/,"-3.         config->url_out = url = new_getout(config);
-2.       if(!url)
-1.         return PARAM_NO_MEM;

/*fill in the outfile*/

1.       if('o' == letter) {
2.         if(!*nextarg) {
3.           warnf(global, ""output file name has no length\n"");
4.           return PARAM_BAD_USE;
5.         }
6.         GetStr(&url->outfile, nextarg);",Not Useful,1
/*leave it*/,"-2.       }
-1.       else {

/*leave it*/

1.         if(toggle)",Not Useful,1
/*use remote file's time*/,"-10.                   ""\'start\'-\'stop\'. The server's response to this ""
-9.                   ""request is uncertain.\n"");
-8.             break;
-7.           }
-6.           tmp_range++;
-5.         }
-4.         GetStr(&config->range, nextarg);
-3.       }
-2.       break;
-1.     case 'R':

/*use remote file's time*/

1.       config->remote_time = toggle;
2.       break;
3.     case 's':",Not Useful,1
/*toggle off*/,"-8.       if(toggle)
-7.         global->mute = global->noprogress = TRUE;
-6.       else
-5.         global->mute = global->noprogress = FALSE;
-4.       if(global->showerror < 0)

/*toggle off*/

1.       break;
2.     case 'S':",Not Useful,0
/*show errors*/,"-3.       config->remote_time = toggle;
-2.       break;
-1.     case 's':

/*show errors*/

1.       if(toggle)
2.         global->mute = global->noprogress = TRUE;
3.       else
4.         global->mute = global->noprogress = FALSE;
5.       if(global->showerror < 0)",Not Useful,1
/*Telnet options*/,"-2.       break;
-1.     case 't':

/*Telnet options*/

1.       err = add2list(&config->telnet_options, nextarg);
2.       if(err)
3.         return err;
4.       break;
5.     case 'T':",Not Useful,1
/*mark -T used*/,"-3.         config->url_ul = url = new_getout(config);
-2.       if(!url)
-1.         return PARAM_NO_MEM;

/*mark -T used*/

1.       if(!*nextarg)
2.         url->flags |= GETOUT_NOUPLOAD;
3.       else {",Not Useful,0
/*verbose is disabled here*/,"-10.         Curl_safefree(global->trace_dump);
-9.         global->trace_dump = strdup(""%"");
-8.         if(!global->trace_dump)
-7.           return PARAM_NO_MEM;
-6.         if(global->tracetype && (global->tracetype != TRACE_PLAIN))
-5.           warnf(global,
-4.                 ""-v, --verbose overrides an earlier trace/verbose option\n"");
-3.         global->tracetype = TRACE_PLAIN;
-2.       }
-1.       else

/*verbose is disabled here*/

1.         global->tracetype = TRACE_NONE;
2.       break;
3.     case 'V':",Not Useful,0
/*pass the @*/,"-10.             curl_free(enc);
-9.             postdata = n;
-8.           }
-7.           else
-6.             return PARAM_NO_MEM;
-5.         }
-4.       }
-3.       else if('@' == *nextarg && !raw_mode) {

/*pass the @*/

1.         if(!strcmp(""-"", nextarg)) {
2.           file = stdin;",Not Useful,1
/*--preproxy*/,"-10.         if(err)
-9.           return err;
-8.         if(!config->writeout)
-7.           warnf(global, ""Failed to read %s"", fname);
-6.       }
-5.       else
-4.         GetStr(&config->writeout, nextarg);
-3.       break;
-2.     case 'x':
-1.       switch(subletter) {

/*--preproxy*/

1.         GetStr(&config->preproxy, nextarg);
2.         break;
3.       default:",Not Useful,1
/*--proxy*/,"-6.         err = str2num(&config->maxredirs, nextarg);
-5.         if(err)
-4.           return err;
-3.         if(config->maxredirs < -1)
-2.           return PARAM_BAD_NUMERIC;
-1.         break;

/*--proxy*/

1.         if(curlinfo->features & CURL_VERSION_NTLM)
2.           config->proxyntlm = toggle;
3.         else
4.           return PARAM_LIBCURL_DOESNT_SUPPORT;
5.         break;",Not Useful,1
/*set custom request*/,"-6.         GetStr(&config->proxy, nextarg);
-5.         config->proxyver = CURLPROXY_HTTP;
-4.         break;
-3.       }
-2.       break;
-1.     case 'X':

/*set custom request*/

1.       GetStr(&config->customrequest, nextarg);
2.       break;
3.     case 'y':",Not Useful,1
/*low speed time*/,"-3.       GetStr(&config->customrequest, nextarg);
-2.       break;
-1.     case 'y':

/*low speed time*/

1.       err = str2unum(&config->low_speed_time, nextarg);
2.       if(err)
3.         return err;
4.       if(!config->low_speed_limit)
5.         config->low_speed_limit = 1;
6.       break;
7.     case 'Y':",Not Useful,0
/*low speed limit*/,"-7.       err = str2unum(&config->low_speed_time, nextarg);
-6.       if(err)
-5.         return err;
-4.       if(!config->low_speed_limit)
-3.         config->low_speed_limit = 1;
-2.       break;
-1.     case 'Y':

/*low speed limit*/

1.       err = str2unum(&config->low_speed_limit, nextarg);
2.       if(err)
3.         return err;
4.       if(!config->low_speed_time)
5.         config->low_speed_time = 30;
6.       break;
7.     case 'Z':
8.       switch(subletter) {",Not Useful,1
/*--parallel*/,"-8.       err = str2unum(&config->low_speed_limit, nextarg);
-7.       if(err)
-6.         return err;
-5.       if(!config->low_speed_time)
-4.         config->low_speed_time = 30;
-3.       break;
-2.     case 'Z':
-1.       switch(subletter) {

/*--parallel*/

1.         global->parallel = toggle;
2.         break;",Not Useful,1
/*--parallel-max*/,"-2.         global->parallel = toggle;
-1.         break;

/*--parallel-max*/

1.         err = str2unum(&global->parallel_max, nextarg);
2.         if(err)
3.           return err;
4.         if((global->parallel_max > MAX_PARALLEL) ||
5.            (global->parallel_max < 1))
6.           global->parallel_max = PARALLEL_DEFAULT;
7.         break;",Not Useful,1
/*--parallel-connect*/,"-7.         err = str2unum(&global->parallel_max, nextarg);
-6.         if(err)
-5.           return err;
-4.         if((global->parallel_max > MAX_PARALLEL) ||
-3.            (global->parallel_max < 1))
-2.           global->parallel_max = PARALLEL_DEFAULT;
-1.         break;

/*--parallel-connect*/

1.         global->parallel_connect = toggle;
2.         break;
3.       }
4.       break;",Not Useful,1
/*FALLTHROUGH*/,"-3.         config->file_clobber_mode = toggle ? CLOBBER_ALWAYS : CLOBBER_NEVER;
-2.         break;
-1.       }

/*FALLTHROUGH*/

111",Not Useful,0
/*now let's see if it is a file name to get the time from instead!*/,"-7.         config->timecond = CURL_TIMECOND_LASTMOD;
-6.         nextarg++;
-5.         break;
-4.       }
-3.       now = time(NULL);
-2.       config->condtime = (curl_off_t)curl_getdate(nextarg, &now);
-1.       if(-1 == config->condtime) {

/*now let's see if it is a file name to get the time from instead!*/

1.         curl_off_t filetime = getfiletime(nextarg, global);
2.         if(filetime >= 0) {",Not Useful,1
/*unknown flag*/,"-10.         break;
-9.       case 'C':
-8.         GetStr(&config->etag_save_file, nextarg);
-7.         break;
-6.       case 'D':
-5.         GetStr(&config->etag_compare_file, nextarg);
-4.         break;
-3.       case 'E':
-2.         GetStr(&config->ssl_ec_curves, nextarg);
-1.         break;

/*unknown flag*/

1.         return PARAM_OPTION_UNKNOWN;
2.       }
3.       break;
4.     case 'f':
5.       switch(subletter) {",Not Useful,1
"/*Reset result as PARAM_NEXT_OPERATION is only used here and not
             returned from this function*/","-10.            following (URL) argument to start with -. */
-9.         stillflags = FALSE;
-8.       else {
-7.         char *nextarg = (i < (argc - 1))
-6.           ? curlx_convert_tchar_to_UTF8(argv[i + 1])
-5.           : NULL;
-4.         result = getparameter(orig_opt, nextarg, &passarg, global, config);
-3.         curlx_unicodefree(nextarg);
-2.         config = global->last;
-1.         if(result == PARAM_NEXT_OPERATION) {

/*Reset result as PARAM_NEXT_OPERATION is only used here and not
             returned from this function*/

1.           result = PARAM_OK;
2.           if(config->url_list && config->url_list->url) {",Not Useful,1
/*Set the global config pointer*/,"-1.               config_init(config->next);

/*Set the global config pointer*/

1.               config->next->global = global;",Not Useful,1
/*Update the last config pointer*/,"-1.               config->next->global = global;

/*Update the last config pointer*/

1.               global->last = config->next;",Not Useful,0
/*Move onto the new config*/,"-1.               global->last = config->next;

/*Move onto the new config*/

1.               config->next->prev = config;
2.               config = config->next;
3.             }
4.             else
5.               result = PARAM_NO_MEM;
6.           }
7.         }
8.         else if(!result && passarg)",Not Useful,0
/*we're supposed to skip this*/,"-8.               config->next->prev = config;
-7.               config = config->next;
-6.             }
-5.             else
-4.               result = PARAM_NO_MEM;
-3.           }
-2.         }
-1.         else if(!result && passarg)

/*we're supposed to skip this*/

1.       }
2.     }
3.     else {
4.       bool used;",Not Useful,1
/*Query the security package for Kerberos*/,"-10.  * This is used to evaluate if GSSAPI (Kerberos V5) is supported.
-9.  *
-8.  * Parameters: None
-7.  *
-6.  * Returns TRUE if Kerberos V5 is supported by Windows SSPI.
-5.  */
-4. bool Curl_auth_is_gssapi_supported(void)
-3. {
-2.   PSecPkgInfo SecurityPackage;
-1.   SECURITY_STATUS status;

/*Query the security package for Kerberos*/

1.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *)
2.                                               TEXT(SP_NAME_KERBEROS),
3.                                               &SecurityPackage);",Not Useful,1
/*Query the security package for Kerberos*/,"-10.  * This is used to evaluate if GSSAPI (Kerberos V5) is supported.
-9.  *
-8.  * Parameters: None
-7.  *
-6.  * Returns TRUE if Kerberos V5 is supported by Windows SSPI.
-5.  */
-4. bool Curl_auth_is_gssapi_supported(void)
-3. {
-2.   PSecPkgInfo SecurityPackage;
-1.   SECURITY_STATUS status;

/*Query the security package for Kerberos*/

1.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *)
2.                                               TEXT(SP_NAME_KERBEROS),
3.                                               &SecurityPackage);",Not Useful,1
/*Do we have credentials to use or are we using single sign-on?*/,"-5.     krb5->output_token = malloc(krb5->token_max);
-4.     if(!krb5->output_token)
-3.       return CURLE_OUT_OF_MEMORY;
-2.   }
-1.   if(!krb5->credentials) {

/*Do we have credentials to use or are we using single sign-on?*/

1.     if(userp && *userp) {",Not Useful,0
/*Allow proper cleanup of the identity structure*/,"-3.       result = Curl_create_sspi_identity(userp, passwdp, &krb5->identity);
-2.       if(result)
-1.         return result;

/*Allow proper cleanup of the identity structure*/

1.       krb5->p_identity = &krb5->identity;
2.     }
3.     else",Not Useful,0
/*Acquire our credentials handle*/,"-3.     krb5->credentials = calloc(1, sizeof(CredHandle));
-2.     if(!krb5->credentials)
-1.       return CURLE_OUT_OF_MEMORY;

/*Acquire our credentials handle*/

1.     status = s_pSecFn->AcquireCredentialsHandle(NULL,
2.                                                 (TCHAR *)
3.                                                 TEXT(SP_NAME_KERBEROS),
4.                                                 SECPKG_CRED_OUTBOUND, NULL,
5.                                                 krb5->p_identity, NULL, NULL,
6.                                                 krb5->credentials, &expiry);
7.     if(status != SEC_E_OK)
8.       return CURLE_LOGIN_DENIED;",Not Useful,0
/*Allocate the trailer*/,"-2.     max_size = 0;
-1.   }

/*Allocate the trailer*/

1.   trailer = malloc(sizes.cbSecurityTrailer);
2.   if(!trailer)
3.     return CURLE_OUT_OF_MEMORY;",Not Useful,1
/*Allocate our message*/,"-3.   trailer = malloc(sizes.cbSecurityTrailer);
-2.   if(!trailer)
-1.     return CURLE_OUT_OF_MEMORY;

/*Allocate our message*/

1.   messagelen = 4;
2.   if(authzid)
3.     messagelen += strlen(authzid);
4.   message = malloc(messagelen);
5.   if(!message) {
6.     free(trailer);
7.     return CURLE_OUT_OF_MEMORY;
8.   }",Not Useful,0
/*Allocate the padding*/,"-2.   if(authzid && *authzid)
-1.     memcpy(message + 4, authzid, messagelen - 4);

/*Allocate the padding*/

1.   padding = malloc(sizes.cbBlockSize);
2.   if(!padding) {
3.     free(message);
4.     free(trailer);
5.     return CURLE_OUT_OF_MEMORY;
6.   }",Not Useful,0
/*Encrypt the data*/,"-10.   wrap_desc.pBuffers     = wrap_buf;
-9.   wrap_buf[0].BufferType = SECBUFFER_TOKEN;
-8.   wrap_buf[0].pvBuffer   = trailer;
-7.   wrap_buf[0].cbBuffer   = sizes.cbSecurityTrailer;
-6.   wrap_buf[1].BufferType = SECBUFFER_DATA;
-5.   wrap_buf[1].pvBuffer   = message;
-4.   wrap_buf[1].cbBuffer   = curlx_uztoul(messagelen);
-3.   wrap_buf[2].BufferType = SECBUFFER_PADDING;
-2.   wrap_buf[2].pvBuffer   = padding;
-1.   wrap_buf[2].cbBuffer   = sizes.cbBlockSize;

/*Encrypt the data*/

1.   status = s_pSecFn->EncryptMessage(krb5->context, KERB_WRAP_NO_ENCRYPT,
2.                                     &wrap_desc, 0);
3.   if(status != SEC_E_OK) {
4.     free(padding);
5.     free(message);
6.     free(trailer);
7.     if(status == SEC_E_INSUFFICIENT_MEMORY)
8.       return CURLE_OUT_OF_MEMORY;
9.     return CURLE_AUTH_ERROR;
10.   }",Not Useful,1
"/** Curl_auth_cleanup_gssapi()
 *
 * This is used to clean up the GSSAPI (Kerberos V5) specific data.
 *
 * Parameters:
 *
 * krb5     [in/out] - The Kerberos 5 data struct being cleaned up.
 **/","Curl_sspi_free_identity(krb5->p_identity);
  krb5->p_identity = NULL;

/** Curl_auth_cleanup_gssapi()
 *
 * This is used to clean up the GSSAPI (Kerberos V5) specific data.
 *
 * Parameters:
 *
 * krb5     [in/out] - The Kerberos 5 data struct being cleaned up.
 **/

1.   krb5->token_max = 0;
2. }",Not Useful,0
/*Free our security context*/,"-10.  *
-9.  * This is used to clean up the GSSAPI (Kerberos V5) specific data.
-8.  *
-7.  * Parameters:
-6.  *
-5.  * krb5     [in/out] - The Kerberos 5 data struct being cleaned up.
-4.  *
-3.  */
-2. void Curl_auth_cleanup_gssapi(struct kerberos5data *krb5)
-1. {

/*Free our security context*/

1.   if(krb5->context) {
2.     s_pSecFn->DeleteSecurityContext(krb5->context);
3.     free(krb5->context);
4.     krb5->context = NULL;
5.   }",Not Useful,0
/*Free our credentials handle*/,"-5.   if(krb5->context) {
-4.     s_pSecFn->DeleteSecurityContext(krb5->context);
-3.     free(krb5->context);
-2.     krb5->context = NULL;
-1.   }

/*Free our credentials handle*/

1.   if(krb5->credentials) {
2.     s_pSecFn->FreeCredentialsHandle(krb5->credentials);
3.     free(krb5->credentials);
4.     krb5->credentials = NULL;
5.   }",Not Useful,0
/*Free our identity*/,"-5.   if(krb5->credentials) {
-4.     s_pSecFn->FreeCredentialsHandle(krb5->credentials);
-3.     free(krb5->credentials);
-2.     krb5->credentials = NULL;
-1.   }

/*Free our identity*/

1.   Curl_sspi_free_identity(krb5->p_identity);
2.   krb5->p_identity = NULL;",Not Useful,0
/*Free the SPN and output token*/,"-2.   Curl_sspi_free_identity(krb5->p_identity);
-1.   krb5->p_identity = NULL;

/*Free the SPN and output token*/

1.   Curl_safefree(krb5->spn);
2.   Curl_safefree(krb5->output_token);",Not Useful,1
/*Import the SPN*/,"-2.     spn_token.value = spn;
-1.     spn_token.length = strlen(spn);

/*Import the SPN*/

1.     major_status = gss_import_name(&minor_status, &spn_token,
2.                                    GSS_C_NT_HOSTBASED_SERVICE,
3.                                    &nego->spn);
4.     if(GSS_ERROR(major_status)) {
5.       Curl_gss_log_error(data, ""gss_import_name() failed: "",
6.                          major_status, minor_status);
7.       free(spn);
8.       return CURLE_AUTH_ERROR;
9.     }
10.     free(spn);",Not Useful,1
/*Query the security package for Negotiate*/,"-10.  * This is used to evaluate if SPNEGO (Negotiate) is supported.
-9.  *
-8.  * Parameters: None
-7.  *
-6.  * Returns TRUE if Negotiate is supported by Windows SSPI.
-5.  */
-4. bool Curl_auth_is_spnego_supported(void)
-3. {
-2.   PSecPkgInfo SecurityPackage;
-1.   SECURITY_STATUS status;

/*Query the security package for Negotiate*/

1.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *)
2.                                               TEXT(SP_NAME_NEGOTIATE),
3.                                               &SecurityPackage);",Not Useful,0
/*Query the security package for Negotiate*/,"-10.  * This is used to evaluate if SPNEGO (Negotiate) is supported.
-9.  *
-8.  * Parameters: None
-7.  *
-6.  * Returns TRUE if Negotiate is supported by Windows SSPI.
-5.  */
-4. bool Curl_auth_is_spnego_supported(void)
-3. {
-2.   PSecPkgInfo SecurityPackage;
-1.   SECURITY_STATUS status;

/*Query the security package for Negotiate*/

1.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *)
2.                                               TEXT(SP_NAME_NEGOTIATE),
3.                                               &SecurityPackage);",Not Useful,1
/*Allocate our credentials handle*/,"-1.       nego->p_identity = NULL;

/*Allocate our credentials handle*/

1.     nego->credentials = calloc(1, sizeof(CredHandle));
2.     if(!nego->credentials)
3.       return CURLE_OUT_OF_MEMORY;",Not Useful,0
/*Acquire our credentials handle*/,"-3.     nego->credentials = calloc(1, sizeof(CredHandle));
-2.     if(!nego->credentials)
-1.       return CURLE_OUT_OF_MEMORY;

/*Acquire our credentials handle*/

1.     nego->status =
2.       s_pSecFn->AcquireCredentialsHandle(NULL,
3.                                          (TCHAR *)TEXT(SP_NAME_NEGOTIATE),
4.                                          SECPKG_CRED_OUTBOUND, NULL,
5.                                          nego->p_identity, NULL, NULL,
6.                                          nego->credentials, &expiry);
7.     if(nego->status != SEC_E_OK)
8.       return CURLE_AUTH_ERROR;",Not Useful,1
/*Allocate our new context handle*/,"-8.     nego->status =
-7.       s_pSecFn->AcquireCredentialsHandle(NULL,
-6.                                          (TCHAR *)TEXT(SP_NAME_NEGOTIATE),
-5.                                          SECPKG_CRED_OUTBOUND, NULL,
-4.                                          nego->p_identity, NULL, NULL,
-3.                                          nego->credentials, &expiry);
-2.     if(nego->status != SEC_E_OK)
-1.       return CURLE_AUTH_ERROR;

/*Allocate our new context handle*/

1.     nego->context = calloc(1, sizeof(CtxtHandle));
2.     if(!nego->context)
3.       return CURLE_OUT_OF_MEMORY;
4.   }
5.   if(chlg64 && *chlg64) {",Not Useful,1
/*The last 3 #include files should be in this order*/,"-7. #include ""mime.h""
-6. #include ""vtls/vtls.h""
-5. #include ""strcase.h""
-4. #include ""sendf.h""
-3. #include ""strdup.h""
-2. #include ""rand.h""
-1. #include ""warnless.h""

/*The last 3 #include files should be in this order*/

1. #include ""curl_printf.h""
2. #include ""curl_memory.h""
3. #include ""memdebug.h""
4. #define HTTPPOST_PTRNAME CURL_HTTPPOST_PTRNAME
5. #define HTTPPOST_FILENAME CURL_HTTPPOST_FILENAME
6. #define HTTPPOST_PTRCONTENTS CURL_HTTPPOST_PTRCONTENTS
7. #define HTTPPOST_READFILE CURL_HTTPPOST_READFILE
8. #define HTTPPOST_PTRBUFFER CURL_HTTPPOST_PTRBUFFER
9. #define HTTPPOST_CALLBACK CURL_HTTPPOST_CALLBACK
10. #define HTTPPOST_BUFFER CURL_HTTPPOST_BUFFER",Not Useful,1
/*end of array state*/,"-1.       if(CURLFORM_END == option) {

/*end of array state*/

1.         array_state = FALSE;
2.         continue;
3.       }
4.     }
5.     else {",Not Useful,1
/*The last 3 #include files should be in this order*/,"-10. #include ""curl_addrinfo.h""
-9. #include ""doh.h""
-8. #include ""sendf.h""
-7. #include ""multiif.h""
-6. #include ""url.h""
-5. #include ""share.h""
-4. #include ""curl_base64.h""
-3. #include ""connect.h""
-2. #include ""strdup.h""
-1. #include ""dynbuf.h""

/*The last 3 #include files should be in this order*/

1. #include ""curl_printf.h""
2. #include ""curl_memory.h""
3. #include ""memdebug.h""
4. #define DNS_CLASS_IN 0x01
5. #ifndef CURL_DISABLE_VERBOSE_STRINGS
6. static const char * const errors[]={
7.   """",
8.   ""Bad label"",
9.   ""Out of range"",
10.   ""Label loop"",",Not Useful,1
/*bytes*/,"-4. {
-3.   const size_t hostlen = strlen(host);
-2.   unsigned char *orig = dnsp;
-1.   const char *hostp = host;
  /* The expected output length is 16 bytes more than the length of

/*bytes*/

1.    * the QNAME-encoding of the host name.
2.    *
3.    * A valid DNS name may not contain a zero-length label, except at
4.    * the end.  For this reason, a name beginning with a dot, or
5.    * containing a sequence of two or more consecutive dots, is invalid
6.    * and cannot be encoded as a QNAME.
7.    *
8.    * If the host name ends with a trailing dot, the corresponding
9.    * QNAME-encoding is one byte longer than the host name. If (as is
10.    * also valid) the hostname is shortened by the omission of the",Not Useful,1
/*next label*/,"-2.     if(dot)
-1.       hostp++;

/*next label*/

111",Not Useful,1
"/** This specific transfer on this connection has been ""drained"".*/","-9.         if(stream->push_headers[i][len] != ':')
-8.           continue;
-7.         return &stream->push_headers[i][len + 1];
-6.       }
-5.     }
-4.   }
-3.   return NULL;
-2. }
-1. /*
 * This specific transfer on this connection has been ""drained"".

/** This specific transfer on this connection has been ""drained"".*/

1.  */
2. static void drained_transfer(struct Curl_easy *data,
3.                              struct http_conn *httpc)
4. {
5.   DEBUGASSERT(httpc->drain_total >= data->state.drain);
6.   httpc->drain_total -= data->state.drain;
7.   data->state.drain = 0;
8. }
9. /*
10.  * Mark this transfer to get ""drained"".",Not Useful,0
/*setup the request struct*/,"-10.                        struct http_conn *httpc)
-9. {
-8.   data->state.drain++;
-7.   httpc->drain_total++;
-6.   DEBUGASSERT(httpc->drain_total >= data->state.drain);
-5. }
-4. static struct Curl_easy *duphandle(struct Curl_easy *data)
-3. {
-2.   struct Curl_easy *second = curl_easy_duphandle(data);
-1.   if(second) {

/*setup the request struct*/

1.     struct HTTP *http = calloc(1, sizeof(struct HTTP));
2.     if(!http) {
3.       (void)Curl_close(&second);
4.     }
5.     else {
6.       second->req.p.http = http;
7.       Curl_dyn_init(&http->header_recvbuf, DYN_H2_HEADERS);
8.       Curl_http2_setup_req(second);
9.       second->state.stream_weight = data->state.stream_weight;
10.     }",Not Useful,1
/*FAIL HARD*/,"-3.     struct Curl_easy *newhandle = duphandle(data);
-2.     if(!newhandle) {
-1.       infof(data, ""failed to duplicate handle"");

/*FAIL HARD*/

1.       goto fail;
2.     }
3.     heads.data = data;
4.     heads.frame = frame;",Not Useful,1
/*ask the application*/,"-4.       goto fail;
-3.     }
-2.     heads.data = data;
-1.     heads.frame = frame;

/*ask the application*/

1.     H2BUGF(infof(data, ""Got PUSH_PROMISE, ask application""));
2.     stream = data->req.p.http;
3.     if(!stream) {
4.       failf(data, ""Internal NULL stream"");
5.       (void)Curl_close(&newhandle);
6.       rv = CURL_PUSH_DENY;
7.       goto fail;
8.     }
9.     rv = set_transfer_url(newhandle, &heads);
10.     if(rv) {",Not Useful,1
/*free the headers again*/,"-10.     if(rv) {
-9.       (void)Curl_close(&newhandle);
-8.       rv = CURL_PUSH_DENY;
-7.       goto fail;
-6.     }
-5.     Curl_set_in_callback(data, true);
-4.     rv = data->multi->push_cb(data, newhandle,
-3.                               stream->push_headers_used, &heads,
-2.                               data->multi->push_userp);
-1.     Curl_set_in_callback(data, false);

/*free the headers again*/

1.     for(i = 0; i<stream->push_headers_used; i++)
2.       free(stream->push_headers[i]);
3.     free(stream->push_headers);
4.     stream->push_headers = NULL;
5.     stream->push_headers_used = 0;
6.     if(rv) {
7.       DEBUGASSERT((rv > CURL_PUSH_OK) && (rv <= CURL_PUSH_ERROROUT));",Not Useful,1
/*should never be a zero stream ID here*/,"-10.                               int32_t stream_id,
-9.                               const uint8_t *mem, size_t len, void *userp)
-8. {
-7.   struct HTTP *stream;
-6.   struct Curl_easy *data_s;
-5.   size_t nread;
-4.   struct connectdata *conn = (struct connectdata *)userp;
-3.   struct http_conn *httpc = &conn->proto.httpc;
-2.   (void)session;
-1.   (void)flags;

/*should never be a zero stream ID here*/

111",Not Useful,0
/*cleared*/,"-10.     if(rv) {
-9.       infof(data_s, ""http/2: failed to clear user_data for stream %d"",
-8.             stream_id);
-7.       DEBUGASSERT(0);
-6.     }
-5.     if(stream_id == httpc->pause_stream_id) {
-4.       H2BUGF(infof(data_s, ""Stopped the pause stream""));
-3.       httpc->pause_stream_id = 0;
-2.     }
-1.     H2BUGF(infof(data_s, ""Removed stream %u hash"", stream_id));

/*cleared*/

1.   }
2.   return 0;
3. }
4. static int on_begin_headers(nghttp2_session *session,
5.                             const nghttp2_frame *frame, void *userp)
6. {
7.   struct HTTP *stream;
8.   struct Curl_easy *data_s = NULL;
9.   (void)userp;
10.   data_s = nghttp2_session_get_stream_user_data(session, frame->hd.stream_id);",Not Useful,1
/*frame->hd.type is either NGHTTP2_HEADERS or NGHTTP2_PUSH_PROMISE*/,"-10.   for(i = 0; i < 3; ++i) {
-9.     char c = value[i];
-8.     if(c < '0' || c > '9') {
-7.       return -1;
-6.     }
-5.     res *= 10;
-4.     res += c - '0';
-3.   }
-2.   return res;
-1. }

/*frame->hd.type is either NGHTTP2_HEADERS or NGHTTP2_PUSH_PROMISE*/

1. static int on_header(nghttp2_session *session, const nghttp2_frame *frame,
2.                      const uint8_t *name, size_t namelen,
3.                      const uint8_t *value, size_t valuelen,
4.                      uint8_t flags,
5.                      void *userp)
6. {
7.   struct HTTP *stream;
8.   struct Curl_easy *data_s;
9.   int32_t stream_id = frame->hd.stream_id;
10.   struct connectdata *conn = (struct connectdata *)userp;",Not Useful,1
/*should never be a zero stream ID here*/,"-10.                               int32_t stream_id,
-9.                               const uint8_t *mem, size_t len, void *userp)
-8. {
-7.   struct HTTP *stream;
-6.   struct Curl_easy *data_s;
-5.   size_t nread;
-4.   struct connectdata *conn = (struct connectdata *)userp;
-3.   struct http_conn *httpc = &conn->proto.httpc;
-2.   (void)session;
-1.   (void)flags;

/*should never be a zero stream ID here*/

111",Not Useful,1
/*if they weren't used and then freed before*/,"-3.   Curl_dyn_free(&http->header_recvbuf);
-2.   Curl_dyn_free(&http->trailer_recvbuf);
-1.   if(http->push_headers) {

/*if they weren't used and then freed before*/

1.     for(; http->push_headers_used > 0; --http->push_headers_used) {
2.       free(http->push_headers[http->push_headers_used - 1]);
3.     }
4.     free(http->push_headers);
5.     http->push_headers = NULL;
6.   }
7.   if(!(data->conn->handler->protocol&PROTO_FAMILY_HTTP) ||",Not Useful,1
/*not HTTP/2 ?*/,"-7.     for(; http->push_headers_used > 0; --http->push_headers_used) {
-6.       free(http->push_headers[http->push_headers_used - 1]);
-5.     }
-4.     free(http->push_headers);
-3.     http->push_headers = NULL;
-2.   }
-1.   if(!(data->conn->handler->protocol&PROTO_FAMILY_HTTP) ||

/*not HTTP/2 ?*/

1.     return;",Not Useful,1
/*RST_STREAM*/,"-5.   if(http->stream_id == httpc->pause_stream_id) {
-4.     H2BUGF(infof(data, ""DONE the pause stream (%x)"", http->stream_id));
-3.     httpc->pause_stream_id = 0;
-2.   }
-1.   if(premature || (!http->closed && http->stream_id)) {

/*RST_STREAM*/

111",Not Useful,1
/** Initialize nghttp2 for a Curl connection*/,"-10.     if(rv) {
-9.       infof(data, ""http/2: failed to clear user_data for stream %d"",
-8.             http->stream_id);
-7.       DEBUGASSERT(0);
-6.     }
-5.     set_transfer(httpc, NULL);
-4.     http->stream_id = 0;
-3.   }
-2. }
-1. /*
 * Initialize nghttp2 for a Curl connection

/** Initialize nghttp2 for a Curl connection*/

1.  */
2. static CURLcode http2_init(struct Curl_easy *data, struct connectdata *conn)
3. {
4.   if(!conn->proto.httpc.h2) {
5.     int rc;
6.     nghttp2_session_callbacks *callbacks;
7.     conn->proto.httpc.inbuf = malloc(H2_BUFSIZE);
8.     if(!conn->proto.httpc.inbuf)
9.       return CURLE_OUT_OF_MEMORY;
10.     rc = nghttp2_session_callbacks_new(&callbacks);",Not Useful,1
/*nghttp2_send_callback*/,"-6. void Curl_http2_ver(char *p, size_t len)
-5. {
-4.   nghttp2_info *h2 = nghttp2_version(0);
-3.   (void)msnprintf(p, len, ""nghttp2/%s"", h2->version_str);
-2. }
-1. /*
 * The implementation of nghttp2_send_callback type. Here we write |data| with

/*nghttp2_send_callback*/

1.  * size |length| to the network and return the number of bytes actually
2.  * written. See the documentation of nghttp2_send_callback for the details.
3.  */
4. static ssize_t send_callback(nghttp2_session *h2,
5.                              const uint8_t *mem, size_t length, int flags,
6.                              void *userp)
7. {
8.   struct connectdata *conn = (struct connectdata *)userp;
9.   struct http_conn *c = &conn->proto.httpc;
10.   struct Curl_easy *data = get_transfer(c);",Not Useful,0
/*nghttp2_on_frame_recv_callback*/,"-1.     nghttp2_session_callbacks_set_send_callback(callbacks, send_callback);

/*nghttp2_on_frame_recv_callback*/

1.     nghttp2_session_callbacks_set_on_frame_recv_callback
2.       (callbacks, on_frame_recv);",Not Useful,1
/*nghttp2_on_data_chunk_recv_callback*/,"-2.     nghttp2_session_callbacks_set_on_frame_recv_callback
-1.       (callbacks, on_frame_recv);

/*nghttp2_on_data_chunk_recv_callback*/

1.     nghttp2_session_callbacks_set_on_data_chunk_recv_callback
2.       (callbacks, on_data_chunk_recv);",Not Useful,1
/*nghttp2_on_stream_close_callback*/,"-2.     nghttp2_session_callbacks_set_on_data_chunk_recv_callback
-1.       (callbacks, on_data_chunk_recv);

/*nghttp2_on_stream_close_callback*/

1.     nghttp2_session_callbacks_set_on_stream_close_callback
2.       (callbacks, on_stream_close);",Not Useful,0
/*nghttp2_on_begin_headers_callback*/,"-2.     nghttp2_session_callbacks_set_on_stream_close_callback
-1.       (callbacks, on_stream_close);

/*nghttp2_on_begin_headers_callback*/

1.     nghttp2_session_callbacks_set_on_begin_headers_callback
2.       (callbacks, on_begin_headers);",Not Useful,1
/*nghttp2_on_header_callback*/,"-2.     nghttp2_session_callbacks_set_on_begin_headers_callback
-1.       (callbacks, on_begin_headers);

/*nghttp2_on_header_callback*/

1.     nghttp2_session_callbacks_set_on_header_callback(callbacks, on_header);
2.     nghttp2_session_callbacks_set_error_callback(callbacks, error_callback);",Not Useful,1
/** Returns nonzero if current HTTP/2 session should be closed.*/,"-10.   result = Curl_dyn_addf(req,
-9.                          ""Connection: Upgrade, HTTP2-Settings\r\n""
-8.                          ""Upgrade: %s\r\n""
-7.                          ""HTTP2-Settings: %s\r\n"",
-6.                          NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, base64);
-5.   free(base64);
-4.   k->upgr101 = UPGR101_REQUESTED;
-3.   return result;
-2. }
-1. /*
 * Returns nonzero if current HTTP/2 session should be closed.

/** Returns nonzero if current HTTP/2 session should be closed.*/

1.  */
2. static int should_close_session(struct http_conn *httpc)
3. {
4.   return httpc->drain_total == 0 && !nghttp2_session_want_read(httpc->h2) &&
5.     !nghttp2_session_want_write(httpc->h2);
6. }
7. /*
8.  * h2_process_pending_input() processes pending input left in
9.  * httpc->inbuf.  Then, call h2_session_send() to send pending data.
10.  * This function returns 0 if it succeeds, or -1 and error code will",Not Useful,0
"/** h2_process_pending_input() processes pending input left in
 * httpc->inbuf.  Then, call h2_session_send() to send pending data.
 * This function returns 0 if it succeeds, or -1 and error code will
 * be assigned to *err.*/","-6. static int should_close_session(struct http_conn *httpc)
-5. {
-4.   return httpc->drain_total == 0 && !nghttp2_session_want_read(httpc->h2) &&
-3.     !nghttp2_session_want_write(httpc->h2);
-2. }
-1. /*
 * h2_process_pending_input() processes pending input left in
 * httpc->inbuf.  Then, call h2_session_send() to send pending data.
 * This function returns 0 if it succeeds, or -1 and error code will
 * be assigned to *err.

/** h2_process_pending_input() processes pending input left in
 * httpc->inbuf.  Then, call h2_session_send() to send pending data.
 * This function returns 0 if it succeeds, or -1 and error code will
 * be assigned to *err.*/

1.  */
2. static int h2_process_pending_input(struct Curl_easy *data,
3.                                     struct http_conn *httpc,
4.                                     CURLcode *err)
5. {
6.   ssize_t nread;
7.   char *inbuf;
8.   ssize_t rv;
9.   nread = httpc->inbuflen - httpc->nread_inbuf;
10.   inbuf = httpc->inbuf + httpc->nread_inbuf;",Not Useful,0
/*don't use this anymore*/,"-4.   stream->closed = FALSE;
-3.   if(stream->error == NGHTTP2_REFUSED_STREAM) {
-2.     H2BUGF(infof(data, ""REFUSED_STREAM (%d), try again on a new connection"",
-1.                  stream->stream_id));

/*don't use this anymore*/

1.     data->state.refused_stream = TRUE;",Not Useful,1
"/*data for this stream is returned now, but this stream caused a pause
         already so we need it called again asap*/","-10.     }
-9.     if(h2_process_pending_input(data, httpc, err))
-8.       return -1;
-7.   }
-6.   if(stream->memlen) {
-5.     ssize_t retlen = stream->memlen;
-4.     H2BUGF(infof(data, ""http2_recv: returns %zd for stream %u"",
-3.                  retlen, stream->stream_id));
-2.     stream->memlen = 0;
-1.     if(httpc->pause_stream_id == stream->stream_id) {

/*data for this stream is returned now, but this stream caused a pause
         already so we need it called again asap*/

1.       H2BUGF(infof(data, ""Data returned for PAUSED stream %u"",
2.                    stream->stream_id));
3.     }
4.     else if(!stream->closed) {
5.       drained_transfer(data, httpc);
6.     }
7.     else",Not Useful,0
"/*unknown, but not zero*/","-10.                nghttp2_session_check_request_allowed(h2), (void *)data));
-9.   switch(data->state.httpreq) {
-8.   case HTTPREQ_POST:
-7.   case HTTPREQ_POST_FORM:
-6.   case HTTPREQ_POST_MIME:
-5.   case HTTPREQ_PUT:
-4.     if(data->state.infilesize != -1)
-3.       stream->upload_left = data->state.infilesize;
-2.     else

/*unknown, but not zero*/

1.     data_prd.read_callback = data_source_read_callback;
2.     data_prd.source.ptr = NULL;
3.     stream_id = nghttp2_submit_request(h2, &pri_spec, nva, nheader,
4.                                        &data_prd, data);
5.     break;
6.   default:
7.     stream_id = nghttp2_submit_request(h2, &pri_spec, nva, nheader,
8.                                        NULL, data);
9.   }
10.   Curl_safefree(nva);",Not Useful,1
/*stream 1 is opened implicitly on upgrade*/,"-10.   int rv;
-9.   struct HTTP *stream = data->req.p.http;
-8.   result = Curl_http2_setup(data, conn);
-7.   if(result)
-6.     return result;
-5.   httpc->recv_underlying = conn->recv[FIRSTSOCKET];
-4.   httpc->send_underlying = conn->send[FIRSTSOCKET];
-3.   conn->recv[FIRSTSOCKET] = http2_recv;
-2.   conn->send[FIRSTSOCKET] = http2_send;
-1.   if(data->req.upgr101 == UPGR101_RECEIVED) {

/*stream 1 is opened implicitly on upgrade*/

1.     stream->stream_id = 1;",Not Useful,1
/*stream ID is unknown at this point*/,"-10.                                               stream->stream_id,
-9.                                               data);
-8.     if(rv) {
-7.       infof(data, ""http/2: failed to set user_data for stream %d"",
-6.             stream->stream_id);
-5.       DEBUGASSERT(0);
-4.     }
-3.   }
-2.   else {
-1.     populate_settings(data, httpc);

/*stream ID is unknown at this point*/

1.     stream->stream_id = -1;
2.     rv = nghttp2_submit_settings(httpc->h2, NGHTTP2_FLAG_NONE,
3.                                  httpc->local_settings,
4.                                  httpc->local_settings_num);
5.     if(rv) {
6.       failf(data, ""nghttp2_submit_settings() failed: %s(%d)"",
7.             nghttp2_strerror(rv), rv);
8.       return CURLE_HTTP2;
9.     }
10.   }",Not Useful,1
/*The last #include file should be:*/,"-10. #include ""progress.h""
-9. #include ""gopher.h""
-8. #include ""select.h""
-7. #include ""strdup.h""
-6. #include ""vtls/vtls.h""
-5. #include ""url.h""
-4. #include ""escape.h""
-3. #include ""warnless.h""
-2. #include ""curl_printf.h""
-1. #include ""curl_memory.h""

/*The last #include file should be:*/

1. #include ""memdebug.h""",Not Useful,0
/** Forward declarations.*/,"-2. #include ""memdebug.h""
-1. /*
 * Forward declarations.

/** Forward declarations.*/

1.  */
2. static CURLcode gopher_do(struct Curl_easy *data, bool *done);
3. #ifdef USE_SSL
4. static CURLcode gopher_connect(struct Curl_easy *data, bool *done);
5. static CURLcode gopher_connecting(struct Curl_easy *data, bool *done);
6. #endif
7. /*
8.  * Gopher protocol handler.
9.  * This is also a nice simple template to build off for simple
10.  * connect-command-download protocols.",Not Useful,0
/*Which may not have written it all!*/,"-3.     if(strlen(sel) < 1)
-2.       break;
-1.     result = Curl_write(data, sockfd, sel, k, &amount);

/*Which may not have written it all!*/

1.       result = Curl_client_write(data, CLIENTWRITE_HEADER, sel, amount);
2.       if(result)
3.         break;
4.       k -= amount;
5.       sel += amount;
6.       if(k < 1)",Not Useful,0
/*but it did write it all*/,"-6.       result = Curl_client_write(data, CLIENTWRITE_HEADER, sel, amount);
-5.       if(result)
-4.         break;
-3.       k -= amount;
-2.       sel += amount;
-1.       if(k < 1)

/*but it did write it all*/

1.     }
2.     else
3.       break;
4.     timeout_ms = Curl_timeleft(data, NULL, FALSE);
5.     if(timeout_ms < 0) {
6.       result = CURLE_OPERATION_TIMEDOUT;
7.       break;
8.     }
9.     if(!timeout_ms)
10.       timeout_ms = TIMEDIFF_T_MAX;",Not Useful,1
/*The last #include file should be:*/,"-10. #include ""urldata.h""
-9. #include <curl/curl.h>
-8. #include ""transfer.h""
-7. #include ""sendf.h""
-6. #include ""escape.h""
-5. #include ""progress.h""
-4. #include ""dict.h""
-3. #include ""curl_printf.h""
-2. #include ""strcase.h""
-1. #include ""curl_memory.h""

/*The last #include file should be:*/

1. #include ""memdebug.h""",Not Useful,1
/** Forward declarations.*/,"-2. #include ""memdebug.h""
-1. /*
 * Forward declarations.

/** Forward declarations.*/

1.  */
2. static CURLcode dict_do(struct Curl_easy *data, bool *done);",Not Useful,0
/*unconditionally*/,"-4.   CURLcode result = CURLE_OK;
-3.   struct connectdata *conn = data->conn;
-2.   curl_socket_t sockfd = conn->sock[FIRSTSOCKET];
-1.   char *path = data->state.up.path;

/*unconditionally*/

1.   if(strncasecompare(path, DICT_MATCH, sizeof(DICT_MATCH)-1) ||
2.      strncasecompare(path, DICT_MATCH2, sizeof(DICT_MATCH2)-1) ||
3.      strncasecompare(path, DICT_MATCH3, sizeof(DICT_MATCH3)-1)) {
4.     word = strchr(path, ':');
5.     if(word) {
6.       word++;
7.       database = strchr(word, ':');
8.       if(database) {
9.         *database++ = (char)0;
10.         strategy = strchr(database, ':');",Not Useful,1
/*database*/,"-7.   return result;
-6. }
-5. static CURLcode dict_do(struct Curl_easy *data, bool *done)
-4. {
-3.   char *word;
-2.   char *eword;
-1.   char *ppath;
  char *database = NULL;

/*database*/

1.   char *strategy = NULL;",Not Useful,1
/*strategy*/,"-8.   return result;
-7. }
-6. static CURLcode dict_do(struct Curl_easy *data, bool *done)
-5. {
-4.   char *word;
-3.   char *eword;
-2.   char *ppath;
-1.   char *database = NULL;
  char *strategy = NULL;

/*strategy*/

111",Not Useful,1
/*word*/,"-10.   ZERO_NULL,                            /* perform_getsock */
-9.   ZERO_NULL,                            /* disconnect */
-8.   ZERO_NULL,                            /* readwrite */
-7.   ZERO_NULL,                            /* connection_check */
-6.   ZERO_NULL,                            /* attach connection */
-5.   PORT_DICT,                            /* defport */
-4.   CURLPROTO_DICT,                       /* protocol */
-3.   CURLPROTO_DICT,                       /* family */
-2.   PROTOPT_NONE | PROTOPT_NOURLQUERY     /* flags */
-1. };
static char *unescape_word(const char *inputbuff)

/*word*/

1. {
2.   char *newp = NULL;
3.   char *dictp;
4.   size_t len;
5.   CURLcode result = Curl_urldecode(inputbuff, 0, &newp, &len,
6.                                    REJECT_NADA);
7.   if(!newp || result)
8.     return NULL;",Not Useful,1
/*database*/,"-7.   return result;
-6. }
-5. static CURLcode dict_do(struct Curl_easy *data, bool *done)
-4. {
-3.   char *word;
-2.   char *eword;
-1.   char *ppath;
  char *database = NULL;

/*database*/

1.   char *strategy = NULL;",Not Useful,1
/*word*/,"-10.   ZERO_NULL,                            /* perform_getsock */
-9.   ZERO_NULL,                            /* disconnect */
-8.   ZERO_NULL,                            /* readwrite */
-7.   ZERO_NULL,                            /* connection_check */
-6.   ZERO_NULL,                            /* attach connection */
-5.   PORT_DICT,                            /* defport */
-4.   CURLPROTO_DICT,                       /* protocol */
-3.   CURLPROTO_DICT,                       /* family */
-2.   PROTOPT_NONE | PROTOPT_NOURLQUERY     /* flags */
-1. };
static char *unescape_word(const char *inputbuff)

/*word*/

1. {
2.   char *newp = NULL;
3.   char *dictp;
4.   size_t len;
5.   CURLcode result = Curl_urldecode(inputbuff, 0, &newp, &len,
6.                                    REJECT_NADA);
7.   if(!newp || result)
8.     return NULL;",Not Useful,1
/*Finalise the digest*/,"-3.   if(Curl_bufref_len(chlg))
-2.     Curl_HMAC_update(ctxt, Curl_bufref_ptr(chlg),
-1.                      curlx_uztoui(Curl_bufref_len(chlg)));

/*Finalise the digest*/

1.   Curl_HMAC_final(ctxt, digest);",Not Useful,1
"/** Curl_auth_is_digest_supported()
*
* This is used to evaluate if DIGEST is supported.
*
* Parameters: None
*
* Returns TRUE if DIGEST is supported by Windows SSPI.*/","-3. #include ""curl_memory.h""
-2. #include ""memdebug.h""
-1. /*
* Curl_auth_is_digest_supported()
*
* This is used to evaluate if DIGEST is supported.
*
* Parameters: None
*
* Returns TRUE if DIGEST is supported by Windows SSPI.

/** Curl_auth_is_digest_supported()
*
* This is used to evaluate if DIGEST is supported.
*
* Parameters: None
*
* Returns TRUE if DIGEST is supported by Windows SSPI.*/

1. */
2. bool Curl_auth_is_digest_supported(void)
3. {
4.   PSecPkgInfo SecurityPackage;
5.   SECURITY_STATUS status;",Not Useful,1
/*Query the security package for Digest*/,"-10. * This is used to evaluate if DIGEST is supported.
-9. *
-8. * Parameters: None
-7. *
-6. * Returns TRUE if DIGEST is supported by Windows SSPI.
-5. */
-4. bool Curl_auth_is_digest_supported(void)
-3. {
-2.   PSecPkgInfo SecurityPackage;
-1.   SECURITY_STATUS status;

/*Query the security package for Digest*/

1.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_DIGEST),
2.                                               &SecurityPackage);",Not Useful,0
/*Release the package buffer as it is not required anymore*/,"-2.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_DIGEST),
-1.                                               &SecurityPackage);

/*Release the package buffer as it is not required anymore*/

1.   if(status == SEC_E_OK) {
2.     s_pSecFn->FreeContextBuffer(SecurityPackage);
3.   }
4.   return (status == SEC_E_OK ? TRUE : FALSE);
5. }
6. /*
7.  * Curl_auth_create_digest_md5_message()
8.  *
9.  * This is used to generate an already encoded DIGEST-MD5 response message
10.  * ready for sending to the recipient.",Not Useful,0
/*Release the package buffer as it is not required anymore*/,"-2.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_DIGEST),
-1.                                               &SecurityPackage);

/*Release the package buffer as it is not required anymore*/

1.   if(status == SEC_E_OK) {
2.     s_pSecFn->FreeContextBuffer(SecurityPackage);
3.   }
4.   return (status == SEC_E_OK ? TRUE : FALSE);
5. }
6. /*
7.  * Curl_auth_create_digest_md5_message()
8.  *
9.  * This is used to generate an already encoded DIGEST-MD5 response message
10.  * ready for sending to the recipient.",Not Useful,1
/*Acquire our credentials handle*/,"-1.     p_identity = NULL;

/*Acquire our credentials handle*/

1.   status = s_pSecFn->AcquireCredentialsHandle(NULL,
2.                                               (TCHAR *) TEXT(SP_NAME_DIGEST),
3.                                               SECPKG_CRED_OUTBOUND, NULL,
4.                                               p_identity, NULL, NULL,
5.                                               &credentials, &expiry);
6.   if(status != SEC_E_OK) {
7.     Curl_sspi_free_identity(p_identity);
8.     free(spn);
9.     free(output_token);
10.     return CURLE_LOGIN_DENIED;",Not Useful,0
"/*Unknown specifier, ignore it!*/","-10.             curlx_unicodefree(domain.tchar_ptr);
-9.             return CURLE_OUT_OF_MEMORY;
-8.           }
-7.           free(identity->Domain);
-6.           identity->Domain = dup_domain.tbyte_ptr;
-5.           identity->DomainLength = curlx_uztoul(_tcslen(dup_domain.tchar_ptr));
-4.           dup_domain.tchar_ptr = NULL;
-3.           curlx_unicodefree(domain.tchar_ptr);
-2.         }
-1.         else {

/*Unknown specifier, ignore it!*/

1.         }
2.       }
3.       else",Not Useful,0
/*We're done here*/,"-3.         }
-2.       }
-1.       else

/*We're done here*/

111",Not Useful,1
/*Allow the list to be comma-separated*/,"-2.       while(*chlg && ISSPACE(*chlg))
-1.         chlg++;

/*Allow the list to be comma-separated*/

1.       if(',' == *chlg)
2.         chlg++;
3.     }
4.   }
5.   return CURLE_OK;
6. }
7. /*
8.  * Curl_auth_decode_digest_http_message()
9.  *
10.  * This is used to decode a HTTP DIGEST challenge message into the separate",Not Useful,1
/*Release the package buffer as it is not required anymore*/,"-2.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_DIGEST),
-1.                                               &SecurityPackage);

/*Release the package buffer as it is not required anymore*/

1.   if(status == SEC_E_OK) {
2.     s_pSecFn->FreeContextBuffer(SecurityPackage);
3.   }
4.   return (status == SEC_E_OK ? TRUE : FALSE);
5. }
6. /*
7.  * Curl_auth_create_digest_md5_message()
8.  *
9.  * This is used to generate an already encoded DIGEST-MD5 response message
10.  * ready for sending to the recipient.",Not Useful,1
/*delete the context so a new one can be made*/,"-10.     chlg_buf[2].cbBuffer   = curlx_uztoul(strlen((const char *) uripath));
-9.     chlg_buf[3].BufferType = SECBUFFER_PKG_PARAMS;
-8.     chlg_buf[3].pvBuffer   = NULL;
-7.     chlg_buf[3].cbBuffer   = 0;
-6.     chlg_buf[4].BufferType = SECBUFFER_PADDING;
-5.     chlg_buf[4].pvBuffer   = output_token;
-4.     chlg_buf[4].cbBuffer   = curlx_uztoul(token_max);
-3.     status = s_pSecFn->MakeSignature(digest->http_context, 0, &chlg_desc, 0);
-2.     if(status == SEC_E_OK)
-1.       output_token_len = chlg_buf[4].cbBuffer;

/*delete the context so a new one can be made*/

1.       infof(data, ""digest_sspi: MakeSignature failed, error 0x%08lx"",
2.             (long)status);
3.       s_pSecFn->DeleteSecurityContext(digest->http_context);
4.       Curl_safefree(digest->http_context);
5.     }
6.   }
7.   if(!digest->http_context) {
8.     CredHandle credentials;
9.     SEC_WINNT_AUTH_IDENTITY identity;
10.     SEC_WINNT_AUTH_IDENTITY *p_identity;",Not Useful,0
/*Acquire our credentials handle*/,"-1.     p_identity = NULL;

/*Acquire our credentials handle*/

1.   status = s_pSecFn->AcquireCredentialsHandle(NULL,
2.                                               (TCHAR *) TEXT(SP_NAME_DIGEST),
3.                                               SECPKG_CRED_OUTBOUND, NULL,
4.                                               p_identity, NULL, NULL,
5.                                               &credentials, &expiry);
6.   if(status != SEC_E_OK) {
7.     Curl_sspi_free_identity(p_identity);
8.     free(spn);
9.     free(output_token);
10.     return CURLE_LOGIN_DENIED;",Not Useful,1
/*Allocate our new context handle*/,"-10.     resp_buf.BufferType = SECBUFFER_TOKEN;
-9.     resp_buf.pvBuffer   = output_token;
-8.     resp_buf.cbBuffer   = curlx_uztoul(token_max);
-7.     spn = curlx_convert_UTF8_to_tchar((char *) uripath);
-6.     if(!spn) {
-5.       s_pSecFn->FreeCredentialsHandle(&credentials);
-4.       Curl_sspi_free_identity(p_identity);
-3.       free(output_token);
-2.       return CURLE_OUT_OF_MEMORY;
-1.     }

/*Allocate our new context handle*/

1.     digest->http_context = calloc(1, sizeof(CtxtHandle));
2.     if(!digest->http_context)
3.       return CURLE_OUT_OF_MEMORY;",Not Useful,0
/*Free the input token*/,"-10.  *
-9.  * This is used to clean up the digest specific data.
-8.  *
-7.  * Parameters:
-6.  *
-5.  * digest    [in/out] - The digest data struct being cleaned up.
-4.  *
-3.  */
-2. void Curl_auth_digest_cleanup(struct digestdata *digest)
-1. {

/*Free the input token*/

1.   Curl_safefree(digest->input_token);",Not Useful,1
/*Delete security context*/,"-1.   digest->input_token_len = 0;

/*Delete security context*/

1.   if(digest->http_context) {
2.     s_pSecFn->DeleteSecurityContext(digest->http_context);
3.     Curl_safefree(digest->http_context);
4.   }",Not Useful,0
/*The last 3 #include files should be in this order*/,"-10. #include ""urldata.h""
-9. #include ""curl_base64.h""
-8. #include ""curl_md5.h""
-7. #include ""vauth/vauth.h""
-6. #include ""vtls/vtls.h""
-5. #include ""curl_hmac.h""
-4. #include ""curl_sasl.h""
-3. #include ""warnless.h""
-2. #include ""strtok.h""
-1. #include ""sendf.h""

/*The last 3 #include files should be in this order*/

1. #include ""curl_printf.h""
2. #include ""curl_memory.h""
3. #include ""memdebug.h""",Not Useful,0
/*Name*/,"-1. static const struct {

/*Name*/

111",Not Useful,1
"/** state()
 *
 * This is the ONLY way to change SASL state!*/","-10.       sasl->prefmech |= SASL_MECH_DIGEST_MD5;
-9.     if(auth & CURLAUTH_NTLM)
-8.       sasl->prefmech |= SASL_MECH_NTLM;
-7.     if(auth & CURLAUTH_BEARER)
-6.       sasl->prefmech |= SASL_MECH_OAUTHBEARER | SASL_MECH_XOAUTH2;
-5.     if(auth & CURLAUTH_GSSAPI)
-4.       sasl->prefmech |= SASL_MECH_GSSAPI;
-3.   }
-2. }
-1. /*
 * state()
 *
 * This is the ONLY way to change SASL state!

/** state()
 *
 * This is the ONLY way to change SASL state!*/

1.  */
2. static void state(struct SASL *sasl, struct Curl_easy *data,
3.                   saslstate newstate)
4. {
5. #if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)",Not Useful,1
/*Create the type-1 message*/,"-4.     break;
-3. #endif
-2. #ifdef USE_NTLM
-1.   case SASL_NTLM:

/*Create the type-1 message*/

1.     result = Curl_auth_create_ntlm_type1_message(data,
2.                                                  conn->user, conn->passwd,
3.                                                  service, hostname,
4.                                                  &conn->ntlm, &resp);
5.     newstate = SASL_NTLM_TYPE2MSG;
6.     break;
7.   case SASL_NTLM_TYPE2MSG:",Not Useful,1
/*Decode the type-2 message*/,"-7.     result = Curl_auth_create_ntlm_type1_message(data,
-6.                                                  conn->user, conn->passwd,
-5.                                                  service, hostname,
-4.                                                  &conn->ntlm, &resp);
-3.     newstate = SASL_NTLM_TYPE2MSG;
-2.     break;
-1.   case SASL_NTLM_TYPE2MSG:

/*Decode the type-2 message*/

1.     result = get_server_message(sasl, data, &serverdata);
2.     if(!result)
3.       result = Curl_auth_decode_ntlm_type2_message(data, &serverdata,
4.                                                    &conn->ntlm);
5.     if(!result)
6.       result = Curl_auth_create_ntlm_type3_message(data, conn->user,
7.                                                    conn->passwd, &conn->ntlm,
8.                                                    &resp);
9.     break;
10. #endif",Not Useful,1
/*Should not happen*/,"-3.     return Curl_sasl_start(sasl, data, sasl->force_ir, progress);
-2.   default:
-1.     failf(data, ""Unsupported SASL authentication mechanism"");

/*Should not happen*/

1.     break;
2.   }
3.   Curl_bufref_free(&serverdata);
4.   switch(result) {
5.   case CURLE_BAD_CONTENT_ENCODING:",Not Useful,1
/*The last 3 #include files should be in this order*/,"-2. #include ""warnless.h""
-1. #include ""curl_range.h""

/*The last 3 #include files should be in this order*/

1. #include ""curl_printf.h""
2. #include ""curl_memory.h""
3. #include ""memdebug.h""
4. #if defined(WIN32) || defined(MSDOS) || defined(__EMX__)
5. #define DOS_FILESYSTEM 1
6. #endif
7. #ifdef OPEN_NEEDS_ARG3
8. #  define open_readonly(p,f) open((p),(f),(0))
9. #else
10. #  define open_readonly(p,f) open((p),(f))",Not Useful,1
/** Forward declarations.*/,"-10. #include ""memdebug.h""
-9. #if defined(WIN32) || defined(MSDOS) || defined(__EMX__)
-8. #define DOS_FILESYSTEM 1
-7. #endif
-6. #ifdef OPEN_NEEDS_ARG3
-5. #  define open_readonly(p,f) open((p),(f),(0))
-4. #else
-3. #  define open_readonly(p,f) open((p),(f))
-2. #endif
-1. /*
 * Forward declarations.

/** Forward declarations.*/

1.  */
2. static CURLcode file_do(struct Curl_easy *data, bool *done);
3. static CURLcode file_done(struct Curl_easy *data,
4.                           CURLcode status, bool premature);
5. static CURLcode file_connect(struct Curl_easy *data, bool *done);
6. static CURLcode file_disconnect(struct Curl_easy *data,
7.                                 struct connectdata *conn,
8.                                 bool dead_connection);
9. static CURLcode file_setup_connection(struct Curl_easy *data,
10.                                       struct connectdata *conn);",Not Useful,1
/*setup_connection*/,"-7. static CURLcode file_do(struct Curl_easy *data, bool *done);
-6. static CURLcode file_done(struct Curl_easy *data,
-5.                           CURLcode status, bool premature);
-4. static CURLcode file_connect(struct Curl_easy *data, bool *done);
-3. static CURLcode file_disconnect(struct Curl_easy *data,
-2.                                 struct connectdata *conn,
-1.                                 bool dead_connection);
static CURLcode file_setup_connection(struct Curl_easy *data,

/*setup_connection*/

1.                                       struct connectdata *conn);",Not Useful,1
/*do_it*/,"-3. const struct Curl_handler Curl_handler_file = {

/*do_it*/

111",Not Useful,1
/*done*/,"
static CURLcode file_do(struct Curl_easy *data, bool *done);



/*done*/

1. static CURLcode file_done(struct Curl_easy *data,
2.                           CURLcode status, bool premature);
3. static CURLcode file_connect(struct Curl_easy *data, bool *done);
4. static CURLcode file_disconnect(struct Curl_easy *data,
5.                                 struct connectdata *conn,
6.                                 bool dead_connection);
7. static CURLcode file_setup_connection(struct Curl_easy *data,
8.                                       struct connectdata *conn);
9. /*
10.  * FILE scheme handler.",Not Useful,0
/*connect_it*/,"-6. const struct Curl_handler Curl_handler_file = {

/*connect_it*/

111",Not Useful,1
/*disconnect*/,"-4. static CURLcode file_do(struct Curl_easy *data, bool *done);
-3. static CURLcode file_done(struct Curl_easy *data,
-2.                           CURLcode status, bool premature);
-1. static CURLcode file_connect(struct Curl_easy *data, bool *done);
static CURLcode file_disconnect(struct Curl_easy *data,

/*disconnect*/

1.                                 struct connectdata *conn,
2.                                 bool dead_connection);
3. static CURLcode file_setup_connection(struct Curl_easy *data,
4.                                       struct connectdata *conn);",Not Useful,1
/*protocol*/,"-10.   ZERO_NULL,                            /* doing */
-9.   ZERO_NULL,                            /* proto_getsock */
-8.   ZERO_NULL,                            /* doing_getsock */
-7.   ZERO_NULL,                            /* domore_getsock */
-6.   ZERO_NULL,                            /* perform_getsock */
-5.   file_disconnect,                      /* disconnect */
-4.   ZERO_NULL,                            /* readwrite */
-3.   ZERO_NULL,                            /* connection_check */
-2.   ZERO_NULL,                            /* attach connection */
-1.   0,                                    /* defport */
  CURLPROTO_FILE,                       /* protocol */

/*protocol*/

111",Not Useful,1
"/*known size of data to ""upload""*/","-10.   if(data->state.resume_from)
-9.     mode = MODE_DEFAULT|O_APPEND;
-8.   else
-7.     mode = MODE_DEFAULT|O_TRUNC;
-6.   fd = open(file->path, mode, data->set.new_file_perms);
-5.   if(fd < 0) {
-4.     failf(data, ""Can't open %s for writing"", file->path);
-3.     return CURLE_WRITE_ERROR;
-2.   }
-1.   if(-1 != data->state.infilesize)

/*known size of data to ""upload""*/

1.     Curl_pgrsSetUploadSize(data, data->state.infilesize);",Not Useful,1
"/*transfer"");*/","-3.     if(data->state.resume_from <= expected_size)
-2.       expected_size -= data->state.resume_from;
-1.     else {

/*transfer"");*/

1.       return CURLE_BAD_DOWNLOAD_RESUME;
2.     }
3.   }",Not Useful,1
/*The last 3 #include files should be in this order*/,"-10. #include ""sendf.h""
-9. #include ""multiif.h""
-8. #include ""http.h""
-7. #include ""url.h""
-6. #include ""progress.h""
-5. #include ""rtsp.h""
-4. #include ""strcase.h""
-3. #include ""select.h""
-2. #include ""connect.h""
-1. #include ""strdup.h""

/*The last 3 #include files should be in this order*/

1. #include ""curl_printf.h""
2. #include ""curl_memory.h""
3. #include ""memdebug.h""
4. #define RTP_PKT_CHANNEL(p)   ((int)((unsigned char)((p)[1])))
5. #define RTP_PKT_LENGTH(p)  ((((int)((unsigned char)((p)[2]))) << 8) | \
6.                              ((int)((unsigned char)((p)[3]))))",Not Useful,1
/*most requests don't contain a body*/,"-10.   const char *p_uagent = NULL;
-9.   const char *p_proxyuserpwd = NULL;
-8.   const char *p_userpwd = NULL;
-7.   *done = TRUE;
-6.   rtsp->CSeq_sent = data->state.rtsp_next_client_CSeq;
-5.   rtsp->CSeq_recv = 0;

/*most requests don't contain a body*/

1.   switch(rtspreq) {
2.   default:
3.     failf(data, ""Got invalid RTSP request"");
4.     return CURLE_BAD_FUNCTION_ARGUMENT;
5.   case RTSPREQ_OPTIONS:
6.     p_request = ""OPTIONS"";
7.     break;
8.   case RTSPREQ_DESCRIBE:
9.     p_request = ""DESCRIBE"";
10.     data->set.opt_no_body = FALSE;",Not Useful,1
/*GET_PARAMETER's no_body status is determined later*/,"-10.   case RTSPREQ_PLAY:
-9.     p_request = ""PLAY"";
-8.     break;
-7.   case RTSPREQ_PAUSE:
-6.     p_request = ""PAUSE"";
-5.     break;
-4.   case RTSPREQ_TEARDOWN:
-3.     p_request = ""TEARDOWN"";
-2.     break;
-1.   case RTSPREQ_GET_PARAMETER:

/*GET_PARAMETER's no_body status is determined later*/

1.     p_request = ""GET_PARAMETER"";
2.     data->set.opt_no_body = FALSE;
3.     break;
4.   case RTSPREQ_SET_PARAMETER:
5.     p_request = ""SET_PARAMETER"";
6.     break;
7.   case RTSPREQ_RECORD:
8.     p_request = ""RECORD"";
9.     break;
10.   case RTSPREQ_RECEIVE:",Not Useful,0
/*Transport Header for SETUP requests*/,"-6.   if(data->set.str[STRING_RTSP_STREAM_URI]) {
-5.     p_stream_uri = data->set.str[STRING_RTSP_STREAM_URI];
-4.   }
-3.   else {
-2.     p_stream_uri = ""*"";
-1.   }

/*Transport Header for SETUP requests*/

1.   p_transport = Curl_checkheaders(data, STRCONST(""Transport""));
2.   if(rtspreq == RTSPREQ_SETUP && !p_transport) {",Not Useful,0
/*Accept Headers for DESCRIBE requests*/,"-10.       if(!data->state.aptr.rtsp_transport)
-9.         return CURLE_OUT_OF_MEMORY;
-8.     }
-7.     else {
-6.       failf(data,
-5.             ""Refusing to issue an RTSP SETUP without a Transport: header."");
-4.       return CURLE_BAD_FUNCTION_ARGUMENT;
-3.     }
-2.     p_transport = data->state.aptr.rtsp_transport;
-1.   }

/*Accept Headers for DESCRIBE requests*/

1.   if(rtspreq == RTSPREQ_DESCRIBE) {",Not Useful,1
/*Accept Header*/,"-10.       if(!data->state.aptr.rtsp_transport)
-9.         return CURLE_OUT_OF_MEMORY;
-8.     }
-7.     else {
-6.       failf(data,
-5.             ""Refusing to issue an RTSP SETUP without a Transport: header."");
-4.       return CURLE_BAD_FUNCTION_ARGUMENT;
-3.     }
-2.     p_transport = data->state.aptr.rtsp_transport;
-1.   }

/*Accept Header*/

1.   if(rtspreq == RTSPREQ_DESCRIBE) {",Not Useful,1
/*Accept-Encoding header*/,"-2.     p_accept = Curl_checkheaders(data, STRCONST(""Accept""))?
-1.       NULL:""Accept: application/sdp\r\n"";

/*Accept-Encoding header*/

1.     if(!Curl_checkheaders(data, STRCONST(""Accept-Encoding"")) &&
2.        data->set.str[STRING_ENCODING]) {
3.       Curl_safefree(data->state.aptr.accept_encoding);
4.       data->state.aptr.accept_encoding =
5.         aprintf(""Accept-Encoding: %s\r\n"", data->set.str[STRING_ENCODING]);
6.       if(!data->state.aptr.accept_encoding)
7.         return CURLE_OUT_OF_MEMORY;
8.       p_accept_encoding = data->state.aptr.accept_encoding;
9.     }
10.   }",Not Useful,0
/*Referrer*/,"-6.   result = Curl_http_output_auth(data, conn, p_request, HTTPREQ_GET,
-5.                                  p_stream_uri, FALSE);
-4.   if(result)
-3.     return result;
-2.   p_proxyuserpwd = data->state.aptr.proxyuserpwd;
-1.   p_userpwd = data->state.aptr.userpwd;

/*Referrer*/

1.   Curl_safefree(data->state.aptr.ref);
2.   if(data->state.referer && !Curl_checkheaders(data, STRCONST(""Referer"")))
3.     data->state.aptr.ref = aprintf(""Referer: %s\r\n"", data->state.referer);
4.   else
5.     data->state.aptr.ref = NULL;
6.   p_referrer = data->state.aptr.ref;
7.   /*
8.    * Range Header
9.    * Only applies to PLAY, PAUSE, RECORD
10.    *",Not Useful,0
/*CSeq*/,"-10.   if(checks_to_perform & CONNCHECK_ISDEAD) {
-9.     if(rtsp_connisdead(conn))
-8.       ret_val |= CONNRESULT_DEAD;
-7.   }
-6.   return ret_val;
-5. }
-4. static CURLcode rtsp_connect(struct Curl_easy *data, bool *done)
-3. {
-2.   CURLcode httpStatus;
-1.   httpStatus = Curl_http_connect(data, done);

/*CSeq*/

1.   if(data->state.rtsp_next_client_CSeq == 0)
2.     data->state.rtsp_next_client_CSeq = 1;
3.   if(data->state.rtsp_next_server_CSeq == 0)
4.     data->state.rtsp_next_server_CSeq = 1;
5.   data->conn->proto.rtspc.rtp_channel = -1;
6.   return httpStatus;
7. }
8. static CURLcode rtsp_disconnect(struct Curl_easy *data,
9.                                 struct connectdata *conn, bool dead)
10. {",Not Useful,0
/*transport*/,"-7.   const char *p_request = NULL;
-6.   const char *p_session_id = NULL;
-5.   const char *p_accept = NULL;
-4.   const char *p_accept_encoding = NULL;
-3.   const char *p_range = NULL;
-2.   const char *p_referrer = NULL;
-1.   const char *p_stream_uri = NULL;
  const char *p_transport = NULL;

/*transport*/

1.   const char *p_uagent = NULL;
2.   const char *p_proxyuserpwd = NULL;
3.   const char *p_userpwd = NULL;
4.   *done = TRUE;
5.   rtsp->CSeq_sent = data->state.rtsp_next_client_CSeq;
6.   rtsp->CSeq_recv = 0;",Not Useful,0
/*accept*/,"-2.   const char *p_request = NULL;
-1.   const char *p_session_id = NULL;
  const char *p_accept = NULL;

/*accept*/

1.   const char *p_accept_encoding = NULL;
2.   const char *p_range = NULL;
3.   const char *p_referrer = NULL;
4.   const char *p_stream_uri = NULL;
5.   const char *p_transport = NULL;
6.   const char *p_uagent = NULL;
7.   const char *p_proxyuserpwd = NULL;
8.   const char *p_userpwd = NULL;
9.   *done = TRUE;
10.   rtsp->CSeq_sent = data->state.rtsp_next_client_CSeq;",Not Useful,1
/*accept-encoding*/,"-3.   result = Curl_dyn_addf(&req_buffer,

/*accept-encoding*/

111",Not Useful,1
/*range*/,"-4.   const char *p_request = NULL;
-3.   const char *p_session_id = NULL;
-2.   const char *p_accept = NULL;
-1.   const char *p_accept_encoding = NULL;
  const char *p_range = NULL;

/*range*/

1.   const char *p_referrer = NULL;
2.   const char *p_stream_uri = NULL;
3.   const char *p_transport = NULL;
4.   const char *p_uagent = NULL;
5.   const char *p_proxyuserpwd = NULL;
6.   const char *p_userpwd = NULL;
7.   *done = TRUE;
8.   rtsp->CSeq_sent = data->state.rtsp_next_client_CSeq;
9.   rtsp->CSeq_recv = 0;
10.   /* Setup the 'p_request' pointer to the proper p_request string",Not Useful,1
/*referrer*/,"-5.   const char *p_request = NULL;
-4.   const char *p_session_id = NULL;
-3.   const char *p_accept = NULL;
-2.   const char *p_accept_encoding = NULL;
-1.   const char *p_range = NULL;
  const char *p_referrer = NULL;

/*referrer*/

1.   const char *p_stream_uri = NULL;
2.   const char *p_transport = NULL;
3.   const char *p_uagent = NULL;
4.   const char *p_proxyuserpwd = NULL;
5.   const char *p_userpwd = NULL;
6.   *done = TRUE;
7.   rtsp->CSeq_sent = data->state.rtsp_next_client_CSeq;
8.   rtsp->CSeq_recv = 0;
9.   /* Setup the 'p_request' pointer to the proper p_request string
10.    * Since all RTSP requests are included here, there is no need to",Not Useful,1
/*user-agent*/,"-10.       Curl_safefree(data->state.aptr.accept_encoding);
-9.       data->state.aptr.accept_encoding =
-8.         aprintf(""Accept-Encoding: %s\r\n"", data->set.str[STRING_ENCODING]);
-7.       if(!data->state.aptr.accept_encoding)
-6.         return CURLE_OUT_OF_MEMORY;
-5.       p_accept_encoding = data->state.aptr.accept_encoding;
-4.     }
-3.   }
-2.   /* The User-Agent string might have been allocated in url.c already, because
-1.      it might have been used in the proxy connect, but if we have got a header
     with the user-agent string specified, we erase the previously made string

/*user-agent*/

1.      here. */
2.   if(Curl_checkheaders(data, STRCONST(""User-Agent"")) &&
3.      data->state.aptr.uagent) {
4.     Curl_safefree(data->state.aptr.uagent);
5.     data->state.aptr.uagent = NULL;
6.   }
7.   else if(!Curl_checkheaders(data, STRCONST(""User-Agent"")) &&
8.           data->set.str[STRING_USERAGENT]) {
9.     p_uagent = data->state.aptr.uagent;
10.   }",Not Useful,1
/*proxyuserpwd*/,"-9.   const char *p_request = NULL;
-8.   const char *p_session_id = NULL;
-7.   const char *p_accept = NULL;
-6.   const char *p_accept_encoding = NULL;
-5.   const char *p_range = NULL;
-4.   const char *p_referrer = NULL;
-3.   const char *p_stream_uri = NULL;
-2.   const char *p_transport = NULL;
-1.   const char *p_uagent = NULL;
  const char *p_proxyuserpwd = NULL;

/*proxyuserpwd*/

1.   const char *p_userpwd = NULL;
2.   *done = TRUE;
3.   rtsp->CSeq_sent = data->state.rtsp_next_client_CSeq;
4.   rtsp->CSeq_recv = 0;",Not Useful,1
/*userpwd*/,"-9.   const char *p_request = NULL;
-8.   const char *p_session_id = NULL;
-7.   const char *p_accept = NULL;
-6.   const char *p_accept_encoding = NULL;
-5.   const char *p_range = NULL;
-4.   const char *p_referrer = NULL;
-3.   const char *p_stream_uri = NULL;
-2.   const char *p_transport = NULL;
-1.   const char *p_uagent = NULL;
  const char *p_proxyuserpwd = NULL;

/*userpwd*/

1.   const char *p_userpwd = NULL;
2.   *done = TRUE;
3.   rtsp->CSeq_sent = data->state.rtsp_next_client_CSeq;
4.   rtsp->CSeq_recv = 0;",Not Useful,0
/*moving pointer to rtp data*/,"-10.       result = CURLE_ABORTED_BY_CALLBACK;
-9.   }
-8.   return result;
-7. }
-6. static CURLcode rtsp_rtp_readwrite(struct Curl_easy *data,
-5.                                    struct connectdata *conn,
-4.                                    ssize_t *nread,
-3.                                    bool *readmore) {
-2.   struct SingleRequest *k = &data->req;
-1.   struct rtsp_conn *rtspc = &(conn->proto.rtspc);

/*moving pointer to rtp data*/

111",Not Useful,1
/*The length is two bytes*/,"-1.       rtspc->rtp_channel = RTP_PKT_CHANNEL(rtp);

/*The length is two bytes*/

1.       rtp_length = RTP_PKT_LENGTH(rtp);
2.       if(rtp_dataleft < rtp_length + 4) {",Not Useful,1
/*USER*/,"-6. #define FTP_BUFFER_ALLOCSIZE 160
-5. typedef enum {
-4.   PL_UNIX_TOTALSIZE = 0,
-3.   PL_UNIX_FILETYPE,
-2.   PL_UNIX_PERMISSION,
-1.   PL_UNIX_HLINKS,
  PL_UNIX_USER,

/*USER*/

1.   PL_UNIX_GROUP,
2.   PL_UNIX_SIZE,
3.   PL_UNIX_TIME,
4.   PL_UNIX_FILENAME,
5.   PL_UNIX_SYMLINK
6. } pl_unix_mainstate;
7. typedef union {
8.   enum {
9.     PL_UNIX_TOTALSIZE_INIT = 0,
10.     PL_UNIX_TOTALSIZE_READING",Not Useful,1
/*GROUP*/,"-7. #define FTP_BUFFER_ALLOCSIZE 160
-6. typedef enum {
-5.   PL_UNIX_TOTALSIZE = 0,
-4.   PL_UNIX_FILETYPE,
-3.   PL_UNIX_PERMISSION,
-2.   PL_UNIX_HLINKS,
-1.   PL_UNIX_USER,
  PL_UNIX_GROUP,

/*GROUP*/

1.   PL_UNIX_SIZE,
2.   PL_UNIX_TIME,
3.   PL_UNIX_FILENAME,
4.   PL_UNIX_SYMLINK
5. } pl_unix_mainstate;
6. typedef union {
7.   enum {
8.     PL_UNIX_TOTALSIZE_INIT = 0,
9.     PL_UNIX_TOTALSIZE_READING
10.   } total_dirsize;",Not Useful,0
/*others*/,"-10.   if(str[5] == 'x')
-9.     permissions |= 1 << 3;
-8.   else if(str[5] == 's') {
-7.     permissions |= 1 << 3;
-6.     permissions |= 1 << 10;
-5.   }
-4.   else if(str[5] == 'S')
-3.     permissions |= 1 << 10;
-2.   else if(str[5] != '-')
-1.     permissions |= FTP_LP_MALFORMATED_PERM;

/*others*/

1.   if(str[6] == 'r')
2.     permissions |= 1 << 2;
3.   else if(str[6] != '-')
4.     permissions |= FTP_LP_MALFORMATED_PERM;
5.   if(str[7] == 'w')
6.     permissions |= 1 << 1;
7.   else if(str[7] != '-')
8.       permissions |= FTP_LP_MALFORMATED_PERM;
9.   if(str[8] == 'x')
10.     permissions |= 1;",Not Useful,1
/*move finfo pointers to b_data*/,"-10. static CURLcode ftp_pl_insert_finfo(struct Curl_easy *data,
-9.                                     struct fileinfo *infop)
-8. {
-7.   curl_fnmatch_callback compare;
-6.   struct WildcardData *wc = &data->wildcard;
-5.   struct ftp_wc *ftpwc = wc->protdata;
-4.   struct Curl_llist *llist = &wc->filelist;
-3.   struct ftp_parselist_data *parser = ftpwc->parser;
-2.   bool add = TRUE;
-1.   struct curl_fileinfo *finfo = &infop->info;

/*move finfo pointers to b_data*/

1.   char *str = finfo->b_data;
2.   finfo->filename       = str + parser->offsets.filename;
3.   finfo->strings.group  = parser->offsets.group ?
4.                           str + parser->offsets.group : NULL;
5.   finfo->strings.perm   = parser->offsets.perm ?
6.                           str + parser->offsets.perm : NULL;
7.   finfo->strings.target = parser->offsets.symlink_target ?
8.                           str + parser->offsets.symlink_target : NULL;
9.   finfo->strings.time   = str + parser->offsets.time;
10.   finfo->strings.user   = parser->offsets.user ?",Not Useful,0
/*FSM*/,"-3.     parser->os_type = (buffer[0] >= '0' && buffer[0] <= '9') ?
-2.                        OS_TYPE_WIN_NT : OS_TYPE_UNIX;
-1.   }

/*FSM*/

1.     char c = buffer[i];",Not Useful,0
"/*if(ftp_pl_gettime(parser, finfo->b_data + parser->item_offset)) {
                parser->file_data->flags |= CURLFINFOFLAG_KNOWN_TIME;
              }*/","parser->error = CURLE_FTP_BAD_FILE_LIST;
            goto fail;
          }
        }
        else if(parser->item_length == 9) {
          if(c == ' ') {
            parser->state.NT.main = PL_WINNT_TIME;
            parser->state.NT.sub.time = PL_WINNT_TIME_PRESPACE;
          }
          else {
            parser->error = CURLE_FTP_BAD_FILE_LIST;
            goto fail;
          }
        }
        else {
          parser->error = CURLE_FTP_BAD_FILE_LIST;
          goto fail;
        }
        break;
      case PL_WINNT_TIME:
        parser->item_length++;
        switch(parser->state.NT.sub.time) {
        case PL_WINNT_TIME_PRESPACE:
          if(!ISSPACE(c)) {
            parser->state.NT.sub.time = PL_WINNT_TIME_TIME;
          }
          break;
        case PL_WINNT_TIME_TIME:
          if(c == ' ') {
            parser->offsets.time = parser->item_offset;
            finfo->b_data[parser->item_offset + parser->item_length -1] = 0;
            parser->state.NT.main = PL_WINNT_DIRORSIZE;
            parser->state.NT.sub.dirorsize = PL_WINNT_DIRORSIZE_PRESPACE;
            parser->item_length = 0;
          }
          else if(!strchr(""APM0123456789:"", c)) {
            parser->error = CURLE_FTP_BAD_FILE_LIST;
            goto fail;
          }
          break;
        }
        break;
      case PL_WINNT_DIRORSIZE:
        switch(parser->state.NT.sub.dirorsize) {
        case PL_WINNT_DIRORSIZE_PRESPACE:
          if(c != ' ') {
            parser->item_offset = finfo->b_used - 1;
            parser->item_length = 1;
            parser->state.NT.sub.dirorsize = PL_WINNT_DIRORSIZE_CONTENT;
          }
          break;
        case PL_WINNT_DIRORSIZE_CONTENT:
          parser->item_length ++;
          if(c == ' ') {
            finfo->b_data[parser->item_offset + parser->item_length - 1] = 0;
            if(strcmp(""<DIR>"", finfo->b_data + parser->item_offset) == 0) {
              finfo->filetype = CURLFILETYPE_DIRECTORY;
              finfo->size = 0;
            }
            else {
              char *endptr;
              if(curlx_strtoofft(finfo->b_data +
                                 parser->item_offset,
                                 &endptr, 10, &finfo->size)) {
                parser->error = CURLE_FTP_BAD_FILE_LIST;
                goto fail;
              }

/*if(ftp_pl_gettime(parser, finfo->b_data + parser->item_offset)) {
                parser->file_data->flags |= CURLFINFOFLAG_KNOWN_TIME;
              }*/

111",Not Useful,1
/*Query the security package for NTLM*/,"-10.  * This is used to evaluate if NTLM is supported.
-9.  *
-8.  * Parameters: None
-7.  *
-6.  * Returns TRUE if NTLM is supported by Windows SSPI.
-5.  */
-4. bool Curl_auth_is_ntlm_supported(void)
-3. {
-2.   PSecPkgInfo SecurityPackage;
-1.   SECURITY_STATUS status;

/*Query the security package for NTLM*/

1.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_NTLM),
2.                                               &SecurityPackage);",Not Useful,1
